From aead9419bbea881e5d41d69d13cbcbc135b6abfa Mon Sep 17 00:00:00 2001
From: Shareef Ali <shareefalis@gmail.com>
Date: Sun, 4 Mar 2012 15:49:59 -0500
Subject: [PATCH 1/4] epicmtd: change MFC driver to Crespo and enable Samsung
 MFC caching. revert memory probe changes made for 3.0
 kernels. Tweak mmap setting for MFC and enable true
 dual channel for both bank. Bring back default memory
 and buffer changes for hummingbird SoC because we have
 enough mmap memory for MFC.

Change-Id: I725bddc3a344a189df72341aac37f46fea17355a

diff --git a/Kernel/arch/arm/mach-s5pv210/mach-victory.c b/Kernel/arch/arm/mach-s5pv210/mach-victory.c
index 6c20242..a1e2e5c 100644
--- a/Kernel/arch/arm/mach-s5pv210/mach-victory.c
+++ b/Kernel/arch/arm/mach-s5pv210/mach-victory.c
@@ -367,8 +367,8 @@ static struct s3cfb_lcd nt35580 = {
 #define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0 (12288 * SZ_1K)
 #define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC1 (9900 * SZ_1K)
 #define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC2 (12288 * SZ_1K)
-#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0 (13312 * SZ_1K) // 13MB
-#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1 (21504 * SZ_1K) // 21MB
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0 (24064 * SZ_1K) // 23.5MB
+#define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1 (24064 * SZ_1K) // 23.5MB
 #define  S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMD (800 * 480 * 4 * \
 		(CONFIG_FB_S3C_NR_BUFFERS + \
 		(CONFIG_FB_S3C_NUM_OVLY_WIN * \
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc.c b/Kernel/drivers/media/video/samsung/mfc50/mfc.c
old mode 100644
new mode 100755
index 8f1546c..7379bbe
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc.c
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc.c
@@ -183,7 +183,6 @@ static int mfc_release(struct inode *inode, struct file *file)
 
 	ret = 0;
 
-out_release:
 	if (!mfc_is_running()) {
 #ifdef CONFIG_DVFS_LIMIT
 		s5pv210_unlock_dvfs_high_level(DVFS_LOCK_TOKEN_1);
@@ -192,14 +191,17 @@ out_release:
 		ret = regulator_disable(mfc_pd_regulator);
 		if (ret < 0) {
 			mfc_err("MFC_RET_POWER_DISABLE_FAIL\n");
+			goto out_release;
 		}
 	}
 
+out_release:
+
 	mutex_unlock(&mfc_mutex);
 	return ret;
 }
 
-static int mfc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+static long mfc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret, ex_ret;
 	struct mfc_inst_ctx *mfc_ctx = NULL;
@@ -364,6 +366,8 @@ static int mfc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, u
 		else
 			in_param.ret_code = mfc_allocate_buffer(mfc_ctx, &in_param.args, 1);
 
+		mfc_ctx->desc_buff_paddr = in_param.args.mem_alloc.out_paddr + CPB_BUF_SIZE;
+
 		ret = in_param.ret_code;
 		mutex_unlock(&mfc_mutex);
 		break;
@@ -415,14 +419,15 @@ static int mfc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, u
 
 		break;
 
-       case IOCTL_MFC_BUF_CACHE:
+	case IOCTL_MFC_BUF_CACHE:
 		mutex_lock(&mfc_mutex);
-		
+
+		in_param.ret_code = MFCINST_RET_OK;
 		mfc_ctx->buf_type = in_param.args.buf_type;
 
 		mutex_unlock(&mfc_mutex);
 		break;
-		
+
 	default:
 		mfc_err("Requested ioctl command is not defined. (ioctl cmd=0x%08x)\n", cmd);
 		in_param.ret_code  = MFCINST_ERR_INVALID_PARAM;
@@ -470,30 +475,9 @@ static int mfc_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	mfc_ctx->port0_mmap_size = (vir_size / 2);
 
-	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
-		vma->vm_flags |= VM_RESERVED | VM_IO;
-	 	/*
- 	  	* port0 mapping for stream buf & frame buf (chroma + MV)
- 	  	*/
- 	  	page_frame_no = __phys_to_pfn(mfc_get_port0_buff_paddr());
-	 	if (remap_pfn_range(vma, vma->vm_start, page_frame_no,
-	 		mfc_ctx->port0_mmap_size, vma->vm_page_prot)) {
-	 		 mfc_err("mfc remap port0 error\n");
-	 		 return -EAGAIN;
-	 	}
-		vma->vm_flags |= VM_RESERVED | VM_IO;
-		/*
-	 	* port1 mapping for frame buf (luma)
-	 	*/
-	 	page_frame_no = __phys_to_pfn(mfc_get_port1_buff_paddr());
-		if (remap_pfn_range(vma, vma->vm_start + mfc_ctx->port0_mmap_size,
-			page_frame_no, vir_size - mfc_ctx->port0_mmap_size, vma->vm_page_prot)) {
-			mfc_err("mfc remap port1 error\n");
-			return -EAGAIN;
-		 }
-	} else {
 	vma->vm_flags |= VM_RESERVED | VM_IO;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (mfc_ctx->buf_type != MFC_BUFFER_CACHE)
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	/*
 	 * port0 mapping for stream buf & frame buf (chroma + MV)
 	 */
@@ -505,7 +489,8 @@ static int mfc_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	vma->vm_flags |= VM_RESERVED | VM_IO;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (mfc_ctx->buf_type != MFC_BUFFER_CACHE)
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	/*
 	 * port1 mapping for frame buf (luma)
 	 */
@@ -515,7 +500,6 @@ static int mfc_mmap(struct file *filp, struct vm_area_struct *vma)
 		mfc_err("mfc remap port1 error\n");
 		return -EAGAIN;
 	}
-	}	
 
 	mfc_debug("virtual requested mem = %ld, physical reserved data mem = %ld\n", vir_size, phy_size);
 
@@ -526,7 +510,7 @@ static const struct file_operations mfc_fops = {
 	.owner      = THIS_MODULE,
 	.open       = mfc_open,
 	.release    = mfc_release,
-	.ioctl      = mfc_ioctl,
+	.unlocked_ioctl = mfc_ioctl,
 	.mmap       = mfc_mmap
 };
 
@@ -628,8 +612,8 @@ static int mfc_probe(struct platform_device *pdev)
 	mfc_debug(" mfc_port1_base_paddr= 0x%x \n", mfc_port1_base_paddr);
 	mfc_debug(" mfc_port1_memsize = 0x%x \n", mfc_port1_memsize);
 
-	mfc_port1_base_paddr = ALIGN_TO_128KB(mfc_port1_base_paddr);
-	mfc_port1_base_vaddr = phys_to_virt(mfc_port1_base_paddr);
+    mfc_port1_base_paddr = ALIGN_TO_128KB(mfc_port1_base_paddr);
+    mfc_port1_base_vaddr = phys_to_virt(mfc_port1_base_paddr);
 
 	if (mfc_port1_base_vaddr == NULL) {
 		mfc_err("fail to mapping port1 buffer\n");
@@ -698,7 +682,7 @@ err_irq_req:
 err_irq_res:
 	iounmap(mfc_sfr_base_vaddr);
 err_mem_map:
-	release_mem_region((unsigned int)mfc_mem, size);
+	release_mem_region(mfc_mem, size);
 err_mem_req:
 probe_out:
 	dev_err(&pdev->dev, "not found (%d).\n", ret);
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc_interface.h b/Kernel/drivers/media/video/samsung/mfc50/mfc_interface.h
index 1492b12..7ef6cdc 100644
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc_interface.h
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc_interface.h
@@ -38,7 +38,7 @@
 #define IOCTL_MFC_BUF_CACHE			0x00801000
 
 /* MFC H/W support maximum 32 extra DPB */
-#define MFC_MAX_EXTRA_DPB                      4 //5
+#define MFC_MAX_EXTRA_DPB                      5
 
 #define ENC_PROFILE_LEVEL(profile, level)      ((profile) | ((level) << 8))
 
@@ -105,8 +105,7 @@ enum  ssbsip_mfc_enc_conf {
 	MFC_ENC_SETCONF_CHANGE_BIT_RATE,
 	MFC_ENC_SETCONF_FRAME_TAG,
 	MFC_ENC_SETCONF_ALLOW_FRAME_SKIP,
-	MFC_ENC_GETCONF_FRAME_TAG,
-	MFC_ENC_SETCONF_I_PERIOD
+	MFC_ENC_GETCONF_FRAME_TAG
 };
 
 struct mfc_strm_ref_buf_arg {
@@ -146,8 +145,8 @@ struct mfc_enc_init_mpeg4_arg {
 	int in_cb_pad_val;
 	int in_cr_pad_val;
 
-	int in_frame_map;				/* [IN] Encoding input NV12 type ( 0 : tiled , 1: linear)   */
-    
+	int in_frame_map;                    /* [IN] Encoding input NV12 type linear(0) TILE(1)   */
+
 	unsigned int in_mapped_addr;
 	struct mfc_strm_ref_buf_arg out_u_addr;
 	struct mfc_strm_ref_buf_arg out_p_addr;
@@ -160,6 +159,8 @@ struct mfc_enc_init_mpeg4_arg {
 	int in_time_vop_time_increament;     /* [IN] time increment                                  */
 };
 
+//struct mfc_enc_init_mpeg4_arg mfc_enc_init_h263_arg;
+
 struct mfc_enc_init_h264_arg {
 	enum ssbsip_mfc_codec_type in_codec_type; /* [IN] codec type                                       */
 	int in_width;                        /* [IN] width  of YUV420 frame to be encoded             */
@@ -187,8 +188,8 @@ struct mfc_enc_init_h264_arg {
 	int in_cb_pad_val;                   /* [IN] CB pel value used to fill padding area           */
 	int in_cr_pad_val;                   /* [IN] CR pel value used to fill padding area           */
 
-	int in_frame_map;				/* [IN] Encoding input NV12 type ( 0 : tiled , 1: linear)   */
-	
+	int in_frame_map;                    /* [IN] Encoding input NV12 type linear(0) TILE(1)       */
+
 	unsigned int in_mapped_addr;
 	struct mfc_strm_ref_buf_arg out_u_addr;
 	struct mfc_strm_ref_buf_arg out_p_addr;
@@ -307,10 +308,10 @@ struct mfc_mem_free_arg {
 	unsigned int u_addr;
 };
 
-typedef enum {
+enum mfc_buffer_type {
 	MFC_BUFFER_NO_CACHE = 0,
 	MFC_BUFFER_CACHE = 1
-} mfc_buffer_type;	
+};
 
 union mfc_args {
 	struct mfc_enc_init_mpeg4_arg enc_init_mpeg4;
@@ -328,7 +329,7 @@ union mfc_args {
 	struct mfc_mem_free_arg mem_free;
 	struct mfc_get_phys_addr_arg get_phys_addr;
 
-	mfc_buffer_type buf_type;
+	enum mfc_buffer_type buf_type;
 };
 
 struct mfc_common_args {
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.c b/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.c
index 8668b52..b14b72f 100644
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.c
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.c
@@ -32,6 +32,7 @@ void __iomem *mfc_sfr_base_vaddr;
 unsigned int mfc_port0_base_paddr, mfc_port1_base_paddr;
 unsigned char *mfc_port0_base_vaddr, *mfc_port1_base_vaddr;
 unsigned int  mfc_port0_memsize, mfc_port1_memsize;
+unsigned int mfc_port1_alloc_base;
 
 unsigned int mfc_get_fw_buff_paddr(void)
 {
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.h b/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.h
index 99ca5d2..ae45eec 100644
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.h
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc_memory.h
@@ -36,11 +36,11 @@
  * MFC_FW_TOTAL_BUF_SIZE should be aligned to 4KB (page size)
  */
 #define MFC_FW_TOTAL_BUF_SIZE (ALIGN_TO_4KB(MFC_FW_MAX_SIZE + MFC_MAX_INSTANCE_NUM * MFC_FW_BUF_SIZE))
-#define MFC_FW_MAX_SIZE       (512 * 1024) /* 512KB : 512x1024 */
+#define MFC_FW_MAX_SIZE       (2 * 1024 * 1024) /* 2MB : 2x1024x1024                  */
 #define MFC_FW_BUF_SIZE       (512 * 1024)     /* 512KB : 512x1024 size per instance */
 
 #define RISC_BUF_SIZE         (0x80000)        /* 512KB : 512x1024 size per instance */
-#define CPB_BUF_SIZE           (0x180000)       /* 1.5MB   : 1.5x1024x1024 for decoder    */
+#define CPB_BUF_SIZE          (0x300000)       /* 3MB   : 3x1024x1024 for decoder    */
 #define DESC_BUF_SIZE         (0x20000)        /* 128KB : 128x1024                   */
 #define SHARED_BUF_SIZE       (0x10000)        /* 64KB  :  64x1024                   */
 #define PRED_BUF_SIZE         (0x10000)        /* 64KB  :  64x1024                   */
@@ -66,7 +66,7 @@
 #define MFC_FW_BUF_SIZE       (512 * 1024)     /* 512KB : 512x1024 size per instance */
 
 #define RISC_BUF_SIZE         (0x80000)        /* 512KB : 512x1024 size per instance */
-#define CPB_BUF_SIZE          (0x300000)       /* 3MB   : 3x1024x1024 for decoder    */
+#define CPB_BUF_SIZE          (0x300000)       /* 3MB   : 30x1024x1024 for decoder    */
 #define DESC_BUF_SIZE         (0x20000)        /* 128KB : 128x1024                   */
 #define SHARED_BUF_SIZE       (0x10000)        /* 64KB  :  64x1024                   */
 #define PRED_BUF_SIZE         (0x10000)        /* 64KB  :  64x1024                   */
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.c b/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.c
index e6a3418..39ca126 100644
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.c
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.c
@@ -35,6 +35,8 @@
 #include <linux/mm.h>
 #include <linux/io.h>
 #include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/dma-mapping.h>
 #include <plat/regs-mfc.h>
 #include <asm/cacheflush.h>
 #include <mach/map.h>
@@ -53,6 +55,7 @@
 #define DEBUG_MAKE_RAW					0 /* Making Dec/Enc Debugging Files */
 #define ENABLE_DEBUG_MFC_INIT				0
 #define ENABLE_MFC_REGISTER_DEBUG			0 /* 0: Disable	1: Enable */
+#define ENABLE_ENC_MB					1
 
 #define ENABLE_CHECK_START_CODE				1
 #define ENABLE_CHECK_NULL_STREAM			1
@@ -71,9 +74,11 @@
 #endif
 #endif
 
-#define WRITEL_SHARED_MEM(data, address) \
-	{ writel(data, address); \
-	dmac_flush_range((void *)address, (void *)(address + 4));}
+#define WRITEL_SHARED_MEM(data, address)	\
+	do {									\
+		writel(data, address);				\
+		dmac_flush_range((void *)address, (void *)(address + 4)); \
+	} while (0)
 
 #if DEBUG_MAKE_RAW
 #include <linux/kernel.h>
@@ -111,6 +116,7 @@ static int CheckNullStream(unsigned char *src_mem, unsigned int streamSize);
 static int mfc_mem_inst_no[MFC_MAX_INSTANCE_NUM];
 static bool mCheckType;
 
+
 /*
  * Debugging Functions	Definition
  * tile_to_linear_4x2(..)
@@ -164,9 +170,6 @@ static unsigned char pResLinearbuf[1280*720*3/2];
 #endif
 #endif
 
-static	unsigned int predisplay_Yaddr;
-static	unsigned int predisplay_Caddr;
-
 #define MC_STATUS_TIMEOUT	1000	/* ms */
 
 bool mfc_cmd_reset(void)
@@ -239,13 +242,11 @@ static void mfc_set_dec_stream_buffer(struct mfc_inst_ctx *mfc_ctx, int buf_addr
 	unsigned int port0_base_paddr;
 
 	mfc_debug_L0("inst_no : %d, buf_addr : 0x%08x, buf_size : 0x%08x\n", mfc_ctx->InstNo, buf_addr, buf_size);
-
 	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
 		unsigned char *in_vir;
 		in_vir = phys_to_virt(buf_addr);
-		dmac_unmap_area(in_vir, 1, ALIGN_TO_32B(buf_size));
-	}	
-	
+		dma_map_single(NULL, in_vir, buf_size, DMA_TO_DEVICE);
+	}
 	port0_base_paddr = mfc_port0_base_paddr;
 
 	/* release buffer */
@@ -255,7 +256,7 @@ static void mfc_set_dec_stream_buffer(struct mfc_inst_ctx *mfc_ctx, int buf_addr
 	WRITEL((buf_addr - port0_base_paddr) >> 11, MFC_SI_CH0_ES_ADDR);
 	WRITEL(buf_size, MFC_SI_CH0_ES_DEC_UNIT_SIZE);
 	WRITEL(CPB_BUF_SIZE, MFC_SI_CH0_CPB_SIZE);
-	WRITEL((buf_addr + CPB_BUF_SIZE - port0_base_paddr) >> 11, MFC_SI_CH0_DESC_ADDR);
+	WRITEL((mfc_ctx->desc_buff_paddr - port0_base_paddr) >> 11, MFC_SI_CH0_DESC_ADDR);
 	WRITEL(DESC_BUF_SIZE, MFC_SI_CH0_DESC_SIZE);
 
 	mfc_debug_L0("stream_paddr: 0x%08x, desc_paddr: 0x%08x\n", buf_addr, buf_addr + CPB_BUF_SIZE);
@@ -678,8 +679,8 @@ static void mfc_set_encode_init_param(struct mfc_inst_ctx *mfc_ctx, union mfc_ar
 	/* Set circular intra refresh MB count */
 	WRITEL(enc_init_mpeg4_arg->in_mb_refresh, MFC_ENC_CIR_CTRL);
 
-	if(enc_init_mpeg4_arg->in_frame_map == 1)
-	        WRITEL(MEM_STRUCT_TILE_ENC, MFC_ENC_MAP_FOR_CUR);
+	if (enc_init_mpeg4_arg->in_frame_map == 1)
+		WRITEL(MEM_STRUCT_TILE_ENC, MFC_ENC_MAP_FOR_CUR);
 	else
 		WRITEL(MEM_STRUCT_LINEAR, MFC_ENC_MAP_FOR_CUR);
 
@@ -707,6 +708,14 @@ static void mfc_set_encode_init_param(struct mfc_inst_ctx *mfc_ctx, union mfc_ar
 		WRITEL(((enc_init_h264_arg->in_deblock_beta * 2) & 0x1f), MFC_LF_BETA_OFF);
 		WRITEL(1, MFC_EDFU_SF_EPB_ON_CTRL); /* Auto EPB insertion on, only for h264 */
 
+		/* if in_RC_mb_enable is '1' */
+#if ENABLE_ENC_MB
+		if (enc_init_h264_arg->in_RC_frm_enable != 1)
+			enc_init_h264_arg->in_RC_frm_enable = 1;
+		if (enc_init_h264_arg->in_RC_mb_enable != 1)
+			enc_init_h264_arg->in_RC_mb_enable = 1;
+#endif
+
 		WRITEL((enc_init_h264_arg->in_RC_frm_enable << 9) |
 			(enc_init_h264_arg->in_RC_mb_enable << 8) |
 			(enc_init_h264_arg->in_frame_qp & 0x3f),
@@ -770,7 +779,7 @@ int mfc_load_firmware(const unsigned char *data, size_t size)
 
 	invalidate_kernel_vmap_range((void *)data, size);
 	memcpy((void *)fw_virbuf, data, size);
-	dmac_flush_range((void *)fw_virbuf, (void *)fw_virbuf + size);
+	flush_kernel_vmap_range((void *)fw_virbuf, size);
 
 	mfc_debug("mfc_load_firmware : MFC F/W Loading Stop.................(fw_virbuf: 0x%08x)\n", fw_virbuf);
 
@@ -1142,11 +1151,9 @@ static enum mfc_error_code mfc_encode_header(struct mfc_inst_ctx *mfc_ctx, union
 	init_arg->out_header_size = READL(MFC_SI_ENC_STREAM_SIZE);
 
 	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
-		unsigned char *in_vir;
-		in_vir = phys_to_virt(init_arg->out_p_addr.strm_ref_y);
-		dmac_map_area(in_vir, 1, init_arg->out_header_size);
-	}	
-		
+		dma_unmap_single(NULL, init_arg->out_p_addr.strm_ref_y,
+				init_arg->out_header_size, DMA_FROM_DEVICE);
+	}
 	mfc_debug("encoded header size (%d)\n", init_arg->out_header_size);
 
 	return MFCINST_RET_OK;
@@ -1200,12 +1207,9 @@ static enum mfc_error_code mfc_encode_one_frame(struct mfc_inst_ctx *mfc_ctx, un
 		WRITEL((0x1 << 1), MFC_SI_CH0_ENC_PARA);
 	else if (mfc_ctx->forceSetFrameType == I_FRAME)
 		WRITEL(0x1, MFC_SI_CH0_ENC_PARA);
-	else
-		WRITEL(0x0, MFC_SI_CH0_ENC_PARA);
 
 	mfc_ctx->forceSetFrameType = DONT_CARE;
 
-	/* Check MFC status */
 	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
 		unsigned char *in_vir;
 		unsigned int aligned_width;
@@ -1214,31 +1218,13 @@ static enum mfc_error_code mfc_encode_one_frame(struct mfc_inst_ctx *mfc_ctx, un
 		in_vir = phys_to_virt(enc_arg->in_Y_addr);
 		aligned_width = ALIGN_TO_128B(mfc_ctx->img_width);
 		aligned_height = ALIGN_TO_32B(mfc_ctx->img_height);
-		dmac_unmap_area(in_vir, 1, aligned_width*aligned_height);
+		dma_map_single(NULL, in_vir, aligned_width*aligned_height,
+				DMA_TO_DEVICE);
 
 		in_vir = phys_to_virt(enc_arg->in_CbCr_addr);
 		aligned_height = ALIGN_TO_32B(mfc_ctx->img_height/2);
-		dmac_unmap_area(in_vir, 1, aligned_width*aligned_height);
-	}	
-		
-        if (mfc_ctx->dynamic_framerate != 0) {
-		mfc_debug("mfc_ctx->dynamic_framerate = %d\n", mfc_ctx->dynamic_framerate);
-		WRITEL_SHARED_MEM((1 << 1), mfc_ctx->shared_mem_vaddr + 0x2c);
-		WRITEL_SHARED_MEM(mfc_ctx->dynamic_framerate,  mfc_ctx->shared_mem_vaddr + 0x94);
-        } 
-
-	if (mfc_ctx->dynamic_bitrate != 0) {
-		mfc_debug("mfc_ctx->dynamic_bitrate = 0x%x\n", mfc_ctx->dynamic_bitrate);
-		WRITEL_SHARED_MEM((1 << 2), mfc_ctx->shared_mem_vaddr + 0x2c);
-		WRITEL_SHARED_MEM(mfc_ctx->dynamic_bitrate,
-					  mfc_ctx->shared_mem_vaddr + 0x90);
-	}
-
-	if (mfc_ctx->dynamic_iperoid != 0) {
-		mfc_debug("mfc_ctx->dynamic_iperoid = 0x%x\n", mfc_ctx->dynamic_iperoid);
-		WRITEL_SHARED_MEM((1 << 0), mfc_ctx->shared_mem_vaddr + 0x2c);
-		WRITEL_SHARED_MEM(mfc_ctx->dynamic_bitrate,
-					  mfc_ctx->shared_mem_vaddr + 0x98);
+		dma_map_single(NULL, in_vir, aligned_width*aligned_height,
+				DMA_TO_DEVICE);
 	}
 
 	/* Try frame encoding */
@@ -1262,15 +1248,9 @@ static enum mfc_error_code mfc_encode_one_frame(struct mfc_inst_ctx *mfc_ctx, un
 	enc_arg->out_encoded_C_paddr = READL(MFC_SI_ENCODED_C_ADDR);
 
 	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
-		unsigned char *in_vir;
-		in_vir = phys_to_virt(enc_arg->in_strm_st);
-		dmac_map_area(in_vir, 1, enc_arg->out_encoded_size);
-	}	
-	
-	WRITEL_SHARED_MEM(0,  mfc_ctx->shared_mem_vaddr + 0x2c);
-	mfc_ctx->dynamic_framerate = 0;
-	mfc_ctx->dynamic_bitrate = 0;
-        mfc_ctx->dynamic_iperoid = 0;
+		dma_unmap_single(NULL, enc_arg->in_strm_st,
+				enc_arg->out_encoded_size, DMA_FROM_DEVICE);
+	}
 
 	mfc_debug("-- frame type(%d) encodedSize(%d)\r\n",
 		   enc_arg->out_frame_type, enc_arg->out_encoded_size);
@@ -1374,7 +1354,7 @@ enum mfc_error_code mfc_init_decode(struct mfc_inst_ctx *mfc_ctx, union mfc_args
 		return ret_code;
 	}
 
-	if (init_arg->in_strm_size < 0)
+	if (nReturnErrCode < 0)
 		return MFCINST_ERR_DEC_INVALID_STRM;
 
 	mfc_set_dec_stream_buffer(mfc_ctx, init_arg->in_strm_buf, init_arg->in_strm_size);
@@ -1386,6 +1366,25 @@ enum mfc_error_code mfc_init_decode(struct mfc_inst_ctx *mfc_ctx, union mfc_args
 			(mfc_ctx->displayDelay << 16)) : 0)),
 			MFC_SI_CH0_DPB_CONFIG_CTRL);
 
+	/* Set Available Type */
+	if (mCheckType == false) {
+		nSize = mfc_ctx->img_width * mfc_ctx->img_height;
+		mfc_ctx->shared_mem.p720_limit_enable = 49425;
+		if (nSize > BOUND_MEMORY_SIZE) {
+			/* In case of no instance, we should not release codec instance */
+			if (mfc_ctx->InstNo >= 0)
+				mfc_return_inst_no(mfc_ctx->InstNo, mfc_ctx->MfcCodecType);
+
+			return MFCINST_ERR_FRM_BUF_SIZE;
+		}
+	} else {
+		mfc_ctx->shared_mem.p720_limit_enable = 49424;
+	}
+
+	WRITEL_SHARED_MEM(mfc_ctx->shared_mem.p720_limit_enable,
+			  mfc_ctx->shared_mem_vaddr + P720_LIMIT_ENABLE);
+	WRITEL((mfc_ctx->shared_mem_paddr - mfc_port0_base_paddr), MFC_SI_CH0_HOST_WR_ADR);
+
 	/* Codec Command : Decode a sequence header */
 	WRITEL((SEQ_HEADER << 16) | (mfc_ctx->InstNo), MFC_SI_CH0_INST_ID);
 
@@ -1478,23 +1477,6 @@ enum mfc_error_code mfc_init_decode(struct mfc_inst_ctx *mfc_ctx, union mfc_args
 
 	mfc_set_dec_frame_buffer(mfc_ctx);
 
-	/*
-	  * Set Available Type
-	  */
-   if (mCheckType == false) {
-		nSize = mfc_ctx->img_width * mfc_ctx->img_height;
-		mfc_ctx->shared_mem.p720_limit_enable = 49425;
-		if (nSize > BOUND_MEMORY_SIZE) {
-			/* In case of no instance, we should not release codec instance */
-			if (mfc_ctx->InstNo >= 0)
-				mfc_return_inst_no(mfc_ctx->InstNo, mfc_ctx->MfcCodecType);
-
-			return MFCINST_ERR_FRM_BUF_SIZE;
-		}
-   } else {
-	   mfc_ctx->shared_mem.p720_limit_enable = 49424;
-   }
-
 #ifdef ENABLE_DEBUG_MFC_INIT
 #if ENABLE_DEBUG_MFC_INIT
 	printk_mfc_init_info(mfc_ctx, init_arg);
@@ -1654,29 +1636,11 @@ static enum mfc_error_code mfc_decode_one_frame(struct mfc_inst_ctx *mfc_ctx, st
 
 	dec_arg->out_res_change = (READL(MFC_SI_DISPLAY_STATUS) >> 4) & 0x3;
 
-	frame_type = READL(MFC_SI_FRAME_TYPE);
-	mfc_ctx->FrameType = (enum mfc_frame_type)(frame_type & 0x3);
-	
 	if (((READL(MFC_SI_DISPLAY_STATUS) & 0x3) != DECODING_DISPLAY) &&
 		((READL(MFC_SI_DISPLAY_STATUS) & 0x3) != DISPLAY_ONLY)) {
 		dec_arg->out_display_Y_addr = 0;
 		dec_arg->out_display_C_addr = 0;
 		mfc_debug("DECODING_ONLY frame decoded\n");
-	} else if (mfc_ctx->IsPackedPB) {
-		if ((mfc_ctx->FrameType == MFC_RET_FRAME_P_FRAME) ||
-		    (mfc_ctx->FrameType == MFC_RET_FRAME_I_FRAME)) {
-			dec_arg->out_display_Y_addr = READL(MFC_SI_DISPLAY_Y_ADR) << 11;
-			dec_arg->out_display_C_addr = READL(MFC_SI_DISPLAY_C_ADR) << 11;
-		} else {
-   		       dec_arg->out_display_Y_addr = predisplay_Yaddr;
-			dec_arg->out_display_C_addr = predisplay_Caddr;
-		}
-		/* save the display addr */
-		predisplay_Yaddr =  READL(MFC_SI_DISPLAY_Y_ADR) << 11;
-		predisplay_Caddr = READL(MFC_SI_DISPLAY_C_ADR) << 11;
-		mfc_debug("(pre_Y_ADDR : 0x%08x  pre_C_ADDR : 0x%08x)\r\n",
-			(predisplay_Yaddr ),
-			(predisplay_Caddr ));
 	} else {
 		/* address shift */
 		dec_arg->out_display_Y_addr = READL(MFC_SI_DISPLAY_Y_ADR) << 11;
@@ -1693,6 +1657,9 @@ static enum mfc_error_code mfc_decode_one_frame(struct mfc_inst_ctx *mfc_ctx, st
 	else
 		dec_arg->out_display_status = 3;
 
+	frame_type = READL(MFC_SI_FRAME_TYPE);
+	mfc_ctx->FrameType = (enum mfc_frame_type)(frame_type & 0x3);
+
 	mfc_debug_L0("(Y_ADDR : 0x%08x  C_ADDR : 0x%08x)\r\n",
 			dec_arg->out_display_Y_addr, dec_arg->out_display_C_addr);
 
@@ -1776,23 +1743,21 @@ enum mfc_error_code mfc_exe_decode(struct mfc_inst_ctx *mfc_ctx, union mfc_args
 
 	if (mfc_ctx->buf_type == MFC_BUFFER_CACHE) {
 		if (((READL(MFC_SI_DISPLAY_STATUS) & 0x3) == DECODING_DISPLAY) ||
-			 ((READL(MFC_SI_DISPLAY_STATUS) & 0x3) == DISPLAY_ONLY)) {
-				 unsigned char *out_Y_vir;
-				 unsigned char *out_C_vir;
-				 unsigned int aligned_width;
-				 unsigned int aligned_height;
-
-				 out_Y_vir = phys_to_virt(dec_arg->out_display_Y_addr);
-				 aligned_width = ALIGN_TO_128B(mfc_ctx->img_width);
-				 aligned_height = ALIGN_TO_32B(mfc_ctx->img_height);
-				 dmac_map_area(out_Y_vir, 1, aligned_width*aligned_height);
-
-				 out_C_vir = phys_to_virt(dec_arg->out_display_C_addr);	
-				 aligned_height = ALIGN_TO_32B(mfc_ctx->img_height/2);
-				 dmac_map_area(out_C_vir, 1, aligned_width*aligned_height);
-		}	 
-	}	  
-		
+		((READL(MFC_SI_DISPLAY_STATUS) & 0x3) == DISPLAY_ONLY)) {
+			unsigned int aligned_width;
+			unsigned int aligned_height;
+
+			aligned_width = ALIGN_TO_128B(mfc_ctx->img_width);
+			aligned_height = ALIGN_TO_32B(mfc_ctx->img_height);
+			dma_unmap_single(NULL, dec_arg->out_display_Y_addr,
+				aligned_width*aligned_height, DMA_FROM_DEVICE);
+
+			aligned_height = ALIGN_TO_32B(mfc_ctx->img_height/2);
+			dma_unmap_single(NULL, dec_arg->out_display_C_addr,
+				aligned_width*aligned_height, DMA_FROM_DEVICE);
+		}
+	}
+
 	mfc_debug_L0("--\n");
 
 	return ret_code;
@@ -1952,28 +1917,20 @@ enum mfc_error_code mfc_set_config(struct mfc_inst_ctx *mfc_ctx, union mfc_args
 			mfc_ctx->shared_mem.ext_enc_control = (mfc_ctx->shared_mem.ext_enc_control | (0x1 << 1));
 		break;
 
+		/* XXX: need to implement */
 	case MFC_ENC_SETCONF_CHANGE_FRAME_RATE:
 		if (mfc_ctx->MfcState != MFCINST_STATE_ENC_EXE) {
 			mfc_err("MFC_ENC_SETCONF_FRAME_TYPE : state is invalid\n");
 			return MFCINST_ERR_STATE_INVALID;
 		}
-		mfc_ctx->dynamic_framerate = set_cnf_arg->in_config_value[0];
 		break;
 
+		/* XXX: need to implement */
 	case MFC_ENC_SETCONF_CHANGE_BIT_RATE:
 		if (mfc_ctx->MfcState != MFCINST_STATE_ENC_EXE) {
 			mfc_err("MFC_ENC_SETCONF_FRAME_TYPE : state is invalid\n");
 			return MFCINST_ERR_STATE_INVALID;
 		}
-		mfc_ctx->dynamic_bitrate = set_cnf_arg->in_config_value[0];
-		break;
-
-	case MFC_ENC_SETCONF_I_PERIOD:
-		if (mfc_ctx->MfcState != MFCINST_STATE_ENC_EXE) {
-			mfc_err("MFC_ENC_SETCONF_I_PERIOD : state is invalid\n");
-			return MFCINST_ERR_STATE_INVALID;
-		}
-		mfc_ctx->dynamic_iperoid = set_cnf_arg->in_config_value[0];
 		break;
 
 	default:
@@ -2447,7 +2404,6 @@ makefile_mfc_dec_err_info(struct mfc_inst_ctx *mfc_ctx,
 	mfc_dec_in_base_vaddr = phys_to_virt(dec_arg->in_strm_buf);
 	ctx_virbuf = phys_to_virt(mcontext_addr);
 
-	if (mfc_ctx->buf_type == MFC_BUFFER_NO_CACHE)
 	write_file(fileName0, mfc_dec_in_base_vaddr, dec_arg->in_strm_size);
 	write_file(fileName1, ctx_virbuf, mcontext_size);
 
@@ -2474,7 +2430,6 @@ void makefile_mfc_decinit_err_info(struct mfc_inst_ctx *mfc_ctx, struct mfc_dec_
 	mfc_dec_in_base_vaddr = phys_to_virt(decinit_arg->in_strm_buf);
 	ctx_virbuf = phys_to_virt(mcontext_addr);
 
-	if (mfc_ctx->buf_type == MFC_BUFFER_NO_CACHE)
 	write_file(fileName0, mfc_dec_in_base_vaddr, decinit_arg->in_strm_size);
 	write_file(fileName1, ctx_virbuf, mcontext_size);
 }
diff --git a/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.h b/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.h
index c3ba1b5..18cfe53 100644
--- a/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.h
+++ b/Kernel/drivers/media/video/samsung/mfc50/mfc_opr.h
@@ -153,9 +153,6 @@ struct mfc_inst_ctx {
 	unsigned int postEnable;
 	unsigned int endOfFrame;
 	unsigned int forceSetFrameType;
-	unsigned int dynamic_framerate;
-	unsigned int dynamic_bitrate;
-	unsigned int dynamic_iperoid;
 	unsigned int img_width;
 	unsigned int img_height;
 	unsigned int dwAccess;  /* for Power Management. */
@@ -177,7 +174,8 @@ struct mfc_inst_ctx {
 	unsigned int shared_mem_vaddr;
 	unsigned int IsStartedIFrame;
 	struct mfc_shared_mem shared_mem;
-	mfc_buffer_type buf_type;
+	enum mfc_buffer_type buf_type;
+	unsigned int desc_buff_paddr;
 };
 
 int mfc_load_firmware(const unsigned char *data, size_t size);
-- 
1.7.5.4

