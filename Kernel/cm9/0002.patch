From f952cc9b6358b1af2d3425f3b3c7f24e95d6ac27 Mon Sep 17 00:00:00 2001
From: Brian Beloshapka <bbelos@hotmail.com>
Date: Sun, 4 Mar 2012 20:02:15 -0600
Subject: [PATCH 2/4] DockAudio:  Add support for audio redirection to samsung
 docks with the help of the "Galaxy Dock Sound
 Redirector" market app.

Change-Id: I51eb7675e3765aae8cf94fb4cd93ce7296c25737

diff --git a/Kernel/drivers/misc/fsa9480.c b/Kernel/drivers/misc/fsa9480.c
index 170084c..d2cdd87 100644
--- a/Kernel/drivers/misc/fsa9480.c
+++ b/Kernel/drivers/misc/fsa9480.c
@@ -545,7 +545,7 @@ static void fsa9480_detect_dev(struct fsa9480_usbsw *usbsw)
 				dock_status = 1;
 			
 			ret = i2c_smbus_write_byte_data(client,
-					FSA9480_REG_MANSW1, SW_DHOST);
+					FSA9480_REG_MANSW1, SW_VAUDIO);
 			if (ret < 0)
 				dev_err(&client->dev,
 					"%s: err %d\n", __func__, ret);
@@ -566,6 +566,24 @@ static void fsa9480_detect_dev(struct fsa9480_usbsw *usbsw)
 			if (pdata->cardock_cb)
 				pdata->cardock_cb(FSA9480_ATTACHED);
 			dock_status = 1;
+
+                        ret = i2c_smbus_write_byte_data(client,
+                                        FSA9480_REG_MANSW1, SW_VAUDIO);
+                        if (ret < 0)
+                                dev_err(&client->dev,
+                                        "%s: err %d\n", __func__, ret);
+
+                        ret = i2c_smbus_read_byte_data(client,
+                                        FSA9480_REG_CTRL);
+                        if (ret < 0)
+                                dev_err(&client->dev,
+                                        "%s: err %d\n", __func__, ret);
+
+                        ret = i2c_smbus_write_byte_data(client,
+                                FSA9480_REG_CTRL, ret & ~CON_MANUAL_SW);
+                        if (ret < 0)
+                                dev_err(&client->dev,
+                                        "%s: err %d\n", __func__, ret);
 		}
 	/* Detached */
 	} else {
@@ -628,6 +646,18 @@ static void fsa9480_detect_dev(struct fsa9480_usbsw *usbsw)
 			if (pdata->cardock_cb)
 				pdata->cardock_cb(FSA9480_DETACHED);
 			dock_status = 0;
+
+                        ret = i2c_smbus_read_byte_data(client,
+                                        FSA9480_REG_CTRL);
+                        if (ret < 0)
+                                dev_err(&client->dev,
+                                        "%s: err %d\n", __func__, ret);
+
+                        ret = i2c_smbus_write_byte_data(client,
+                                        FSA9480_REG_CTRL, ret | CON_MANUAL_SW);
+                        if (ret < 0)
+                                dev_err(&client->dev,
+                                        "%s: err %d\n", __func__, ret);
 		}
 	}
 
diff --git a/Kernel/sound/soc/codecs/crespo/wm8994_herring.c b/Kernel/sound/soc/codecs/crespo/wm8994_herring.c
index d0def6b..5ebd316 100644
--- a/Kernel/sound/soc/codecs/crespo/wm8994_herring.c
+++ b/Kernel/sound/soc/codecs/crespo/wm8994_herring.c
@@ -659,7 +659,32 @@ struct gain_info_t playback_gain_table[PLAYBACK_GAIN_NUM] = {
 		.reg  = WM8994_RIGHT_OPGA_VOLUME,   /* 21h */
 		.mask = WM8994_MIXOUTR_VOL_MASK,
 		.gain = WM8994_MIXOUT_VU | 0x39
-    },
+    }, { /* DOCK */
+                .mode = PLAYBACK_EXTRA_DOCK_SPEAKER,
+                .reg  = WM8994_OUTPUT_MIXER_5,          /* 31h */
+                .mask = WM8994_DACL_MIXOUTL_VOL_MASK,
+                .gain = 0x0 << WM8994_DACL_MIXOUTL_VOL_SHIFT
+        }, {
+                .mode = PLAYBACK_EXTRA_DOCK_SPEAKER,
+                .reg  = WM8994_OUTPUT_MIXER_6,          /* 32h */
+                .mask = WM8994_DACR_MIXOUTR_VOL_MASK,
+                .gain = 0x0 << WM8994_DACR_MIXOUTR_VOL_SHIFT
+        }, {
+                .mode = PLAYBACK_EXTRA_DOCK_SPEAKER,
+                .reg  = WM8994_LEFT_OPGA_VOLUME,        /* 20h */
+                .mask = WM8994_MIXOUTL_VOL_MASK,
+                .gain = WM8994_MIXOUT_VU | 0x39
+        }, {
+                .mode = PLAYBACK_EXTRA_DOCK_SPEAKER,
+                .reg  = WM8994_RIGHT_OPGA_VOLUME,       /* 21h */
+                .mask = WM8994_MIXOUTR_VOL_MASK,
+                .gain = WM8994_MIXOUT_VU | 0x39
+        }, {
+                .mode = PLAYBACK_EXTRA_DOCK_SPEAKER,
+                .reg  = WM8994_LINE_OUTPUTS_VOLUME,     /* 1Eh */
+                .mask = WM8994_LINEOUT2_VOL_MASK,
+                .gain = 0x0 << WM8994_LINEOUT2_VOL_SHIFT
+        },
 };
 
 struct gain_info_t voicecall_gain_table[VOICECALL_GAIN_NUM] = {
@@ -2072,6 +2097,37 @@ void wm8994_set_playback_headset(struct snd_soc_codec *codec)
 	val |= WM8994_AIF1DAC1_UNMUTE;
 	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
 
+
+}
+
+void wm8994_set_playback_extra_dock_speaker(struct snd_soc_codec *codec)
+{
+    /* Volume Setting */
+    wm8994_write(codec, 0x0031, 0x0000);    // Output Mixer 5
+    wm8994_write(codec, 0x0032, 0x0000);    // Output Mixer 6
+    wm8994_write(codec, 0x0020, 0x0177);    // Left OPGA Volume
+    wm8994_write(codec, 0x0021, 0x0177);    // Right OPGA Volume
+    wm8994_write(codec, 0x001E, 0x0000);    // Lineout Volume
+    wm8994_write(codec, 0x0610, 0x01C0);    // DAC1 Left Volume
+    wm8994_write(codec, 0x0611, 0x01C0);    // DAC 1 Right Volume
+    wm8994_write(codec, 0x0402, 0x01C0);    // AIF1 DAC 1 Left Volume
+    wm8994_write(codec, 0x0403, 0x01C0);    // AIF1 DAC 1 Rigt Volume
+
+    /* Output Path Routing */
+    wm8994_write(codec, 0x002D, 0x0001);    // Output Mixer1
+    wm8994_write(codec, 0x002E, 0x0001);    // Output Mixer2
+    wm8994_write(codec, 0x0035, 0x0031);    // Line Mixer 2
+    wm8994_write(codec, 0x0005, 0x0303);    // Power Management5
+    wm8994_write(codec, 0x0601, 0x0001);    // DAC1 Left Mixer Routing
+    wm8994_write(codec, 0x0602, 0x0001);    // DAC1 Right Mixer Routing
+    wm8994_write(codec, 0x0208, 0x000A);    // Clocking 1
+    wm8994_write(codec, 0x0003, 0x0CF0);    // Power Management 3
+    wm8994_write(codec, 0x0420, 0x0000);    // DAC1 Filter
+
+    /* Channel Seperation */
+    wm8994_write(codec, 0x0037, 0x0000);    // Lineout Control
+    wm8994_write(codec, 0x0038, 0x0080);    // AntiPop1
+
 }
 
 void wm8994_set_playback_speaker(struct snd_soc_codec *codec)
@@ -3836,6 +3892,9 @@ int wm8994_set_codec_gain(struct snd_soc_codec *codec, u16 mode, u16 device)
 		case PLAYBACK_HP_NO_MIC:
 			gain_set_bits |= PLAYBACK_HP_NO_MIC;
 			break;
+		case PLAYBACK_EXTRA_DOCK_SPEAKER:
+			gain_set_bits |= PLAYBACK_EXTRA_DOCK_SPEAKER;
+			break;
 		default:
 			pr_err("playback modo gain flag is wrong\n");
 			break;
diff --git a/Kernel/sound/soc/codecs/crespo/wm8994_samsung.c b/Kernel/sound/soc/codecs/crespo/wm8994_samsung.c
index 7ac2313..011a6fd 100644
--- a/Kernel/sound/soc/codecs/crespo/wm8994_samsung.c
+++ b/Kernel/sound/soc/codecs/crespo/wm8994_samsung.c
@@ -48,6 +48,8 @@
 #define HDMI_USE_AUDIO
 #endif
 
+bool _dockredir = false;
+
 /*
  *Definitions of clock related.
 */
@@ -117,7 +119,7 @@ select_route universal_wm8994_playback_paths[] = {
 	wm8994_disable_path, wm8994_set_playback_receiver,
 	wm8994_set_playback_speaker, wm8994_set_playback_headset,
 	wm8994_set_playback_headset, wm8994_set_playback_bluetooth,
-	wm8994_set_playback_speaker_headset
+	wm8994_set_playback_speaker_headset, wm8994_set_playback_extra_dock_speaker
 };
 
 select_route universal_wm8994_voicecall_paths[] = {
@@ -278,7 +280,7 @@ static int wm899x_inpga_put_volsw_vu(struct snd_kcontrol *kcontrol,
 #define MAX_VOICECALL_PATH 8
 static const char *playback_path[] = {
 	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT", "SPK_HP",
-	"RING_SPK", "RING_HP", "RING_NO_MIC", "RING_SPK_HP"
+	"RING_SPK", "RING_HP", "RING_NO_MIC", "RING_SPK_HP", "EXTRA_DOCK_SPEAKER"
 };
 static const char *voicecall_path[] = { "OFF", "RCV", "SPK", "HP",
 					"HP_NO_MIC", "BT", "TTY_VCO",
@@ -360,6 +362,8 @@ static int wm8994_set_path(struct snd_kcontrol *kcontrol,
 		DEBUG_LOG_ERR("Unknown Path\n");
 		return -ENODEV;
 	}
+	if (path_num == 4 && _dockredir)
+		path_num = 11;
 
 	switch (path_num) {
 	case OFF:
@@ -386,6 +390,11 @@ static int wm8994_set_path(struct snd_kcontrol *kcontrol,
 		wm8994->ringtone_active = RING_ON;
 		path_num -= 4;
 		break;
+	case EXTRA_DOCK_SPEAKER:
+		DEBUG_LOG("routing to %s\n", mc->texts[path_num]);
+		wm8994->ringtone_active = RING_OFF;
+		path_num -= 4;
+		break;
 	default:
 		DEBUG_LOG_ERR("audio path[%d] does not exists!!\n", path_num);
 		return -ENODEV;
@@ -408,6 +417,39 @@ static int wm8994_set_path(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static ssize_t get_dockredir_kernel_support(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf,"%u\n",1);
+}
+
+static ssize_t store_usedock(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	unsigned short enable;
+	if (sscanf(buf, "%hu", &enable) == 1)
+	{
+		_dockredir = enable == 0 ? false : true;
+	}
+	return size;
+}
+
+static DEVICE_ATTR(usedock, S_IWUGO , NULL, store_usedock);
+static DEVICE_ATTR(dockredir_support, S_IRUGO , get_dockredir_kernel_support, NULL);
+
+static struct attribute *dockredir_attributes[] = {
+	&dev_attr_usedock.attr,
+	&dev_attr_dockredir_support.attr,
+	NULL
+};
+
+static struct attribute_group dockredir_group = {
+	.attrs = dockredir_attributes,
+};
+
+static struct miscdevice dockredir_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "dockredir",
+};
+
 static int wm8994_get_voice_path(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_value *ucontrol)
 {
@@ -3017,6 +3059,9 @@ static int wm8994_i2c_probe(struct i2c_client *i2c,
 		goto err_init;
 	}
 
+	misc_register(&dockredir_device);
+	sysfs_create_group(&dockredir_device.this_device->kobj, &dockredir_group);
+
 	return ret;
 
 err_init:
diff --git a/Kernel/sound/soc/codecs/crespo/wm8994_samsung.h b/Kernel/sound/soc/codecs/crespo/wm8994_samsung.h
index 9b0e72b..acba65f 100644
--- a/Kernel/sound/soc/codecs/crespo/wm8994_samsung.h
+++ b/Kernel/sound/soc/codecs/crespo/wm8994_samsung.h
@@ -81,6 +81,7 @@ Codec Output Path BIT
 #define PLAYBACK_RING_HP	(0x01 << 7)
 #define PLAYBACK_RING_SPK_HP	(0x01 << 8)
 #define PLAYBACK_HP_NO_MIC  (0x01 << 9)
+#define PLAYBACK_EXTRA_DOCK_SPEAKER (0x01 << 10)
 
 #define VOICECALL_RCV		(0x01 << 1)
 #define VOICECALL_SPK		(0x01 << 2)
@@ -113,7 +114,7 @@ Codec Output Path BIT
  */
 enum audio_path	{
 	OFF, RCV, SPK, HP, HP_NO_MIC, BT, SPK_HP,
-	RING_SPK, RING_HP, RING_NO_MIC, RING_SPK_HP
+	RING_SPK, RING_HP, RING_NO_MIC, RING_SPK_HP, EXTRA_DOCK_SPEAKER
 };
 enum call_path		{
 	CALL_OFF, CALL_RCV, CALL_SPK, CALL_HP,
@@ -201,6 +202,7 @@ void wm8994_set_playback_headset(struct snd_soc_codec *codec);
 void wm8994_set_playback_speaker(struct snd_soc_codec *codec);
 void wm8994_set_playback_bluetooth(struct snd_soc_codec *codec);
 void wm8994_set_playback_speaker_headset(struct snd_soc_codec *codec);
+void wm8994_set_playback_extra_dock_speaker(struct snd_soc_codec *codec);
 void wm8994_set_voicecall_common_setting(struct snd_soc_codec *codec);
 void wm8994_set_voicecall_receiver(struct snd_soc_codec *codec);
 void wm8994_set_voicecall_headset(struct snd_soc_codec *codec);
-- 
1.7.5.4

