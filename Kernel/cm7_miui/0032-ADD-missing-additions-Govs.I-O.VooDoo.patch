From 2bb94a2b7cf4cf55a092f9d3aded4fcca1664364 Mon Sep 17 00:00:00 2001
From: Justin <earthbound.iap@gmail.com>
Date: Sun, 5 Feb 2012 21:56:01 -0500
Subject: [PATCH 32/35] ADD: missing additions Govs.I/O.VooDoo


diff --git a/.gitignore b/.gitignore
index f87dcdd..1e7bd56 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,6 +6,8 @@
 *.o.d
 *.order
 *~
+*.orig
+*.rej
 tools/kexec-cwm-test-zip/META-INF/com/google/android/update-binary
 tools/kexec-cwm-test-zip/zImage
 boot_zImage.zip
diff --git a/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.orig b/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.orig
new file mode 100644
index 0000000..827a620
--- /dev/null
+++ b/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.orig
@@ -0,0 +1,2319 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.35.7
+# Mon Jan 23 04:51:40 2012
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_ARCH_USES_GETTIMEOFFSET=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=20
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="usr/epicmtd_initramfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_SEC_LOG=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_SLOW_WORK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_MODULE_LOOSE_VERMAGIC=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_CGROUP_BFQIO=y
+CONFIG_IOSCHED_SIO=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_BFQ is not set
+# CONFIG_DEFAULT_SIO is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+CONFIG_ARCH_S5PV210=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+# CONFIG_S3C_ADC is not set
+CONFIG_S3C_DEV_HSMMC=y
+CONFIG_S3C_DEV_HSMMC1=y
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C2=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_PL330_DMA=y
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+CONFIG_PLAT_S5P=y
+CONFIG_SYSTIMER_S5P=y
+CONFIG_S5P_EXT_INT=y
+CONFIG_S5P_DEV_FB=y
+CONFIG_S5P_HIGH_RES_TIMERS=y
+CONFIG_HRT_RTC=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_SETUP_MFC=y
+CONFIG_CPU_S5PV210=y
+CONFIG_S5PV210_SETUP_I2C1=y
+CONFIG_S5PV210_SETUP_I2C2=y
+CONFIG_S5PV210_SETUP_SDHCI=y
+CONFIG_S5PV210_SETUP_SDHCI_GPIO=y
+CONFIG_S5PV210_POWER_DOMAIN=y
+CONFIG_DDR_RAM_3G=y
+# CONFIG_DDR_RAM_2G is not set
+# CONFIG_MACH_AQUILA is not set
+# CONFIG_MACH_GONI is not set
+
+#
+# MMC/SD slot setup
+#
+
+#
+# Use 8-bit bus width
+#
+# CONFIG_S5PV210_SD_CH0_8BIT is not set
+# CONFIG_S5PV210_SD_CH2_8BIT is not set
+CONFIG_S5PC110_DEV_ONENAND=y
+# CONFIG_MACH_SMDKV210 is not set
+# CONFIG_MACH_SMDKC110 is not set
+# CONFIG_MACH_HERRING is not set
+# CONFIG_MACH_ARIES is not set
+# CONFIG_MACH_CRESPO is not set
+# CONFIG_MACH_ATLAS is not set
+# CONFIG_MACH_FORTE is not set
+CONFIG_MACH_VICTORY=y
+CONFIG_S5PV210_SETUP_FB=y
+CONFIG_S5P_ADC=y
+CONFIG_S5PV210_SETUP_FIMC0=y
+CONFIG_S5PV210_SETUP_FIMC1=y
+CONFIG_S5PV210_SETUP_FIMC2=y
+CONFIG_S5PV210_SETUP_CSIS=y
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_DVFS_LIMIT=y
+CONFIG_CPU_DIDLE=y
+CONFIG_POKE_REC_BOOT_MAGIC=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+CONFIG_ARM_VIC=y
+CONFIG_ARM_VIC_NR=4
+CONFIG_PL330=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Samsung Kernel Debug Features
+#
+CONFIG_KERNEL_DEBUG_SEC=y
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=256
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_NODES_SHIFT=2
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC2,115200 init=/linuxrc"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+CONFIG_KEXEC_HARDBOOT=y
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVEX is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS2 is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVEX=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_SMARTASS is not set
+CONFIG_CPU_FREQ_GOV_SMARTASS2=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND_NVS=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_APM_EMULATION=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_OPS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=n
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+# CONFIG_NF_NAT_SNMP_BASIC is not set
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_NF_CONNTRACK_IPV6 is not set
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+# CONFIG_BT_L2CAP_EXT_FEATURES is not set
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND_IDS is not set
+# CONFIG_MTD_NAND is not set
+CONFIG_MTD_ONENAND=y
+# CONFIG_MTD_ONENAND_VERIFY_WRITE is not set
+# CONFIG_MTD_ONENAND_GENERIC is not set
+# CONFIG_MTD_ONENAND_SAMSUNG is not set
+CONFIG_MTD_ONENAND_SAMSUNG_AUDI=y
+# CONFIG_MTD_ONENAND_OTP is not set
+# CONFIG_MTD_ONENAND_2X_PROGRAM is not set
+# CONFIG_MTD_ONENAND_SIM is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=8192
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=3072
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_ADSP=6144
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_WL127X_RFKILL is not set
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+CONFIG_VIBETONZ=m
+CONFIG_SAMSUNG_JACK=y
+CONFIG_USB_SWITCH_FSA9480=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+# CONFIG_SAMSUNG_MODEMCTL is not set
+CONFIG_PN544=y
+# CONFIG_LEVEL is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_IFB=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+CONFIG_WIMAX_VICTORY=y
+CONFIG_WIMAX_GPIO_VICTORY=y
+CONFIG_BCM4329=m
+CONFIG_BCM4329_FW_PATH="/system/vendor/firmware/fw_bcm4329.bin"
+CONFIG_BCM4329_NVRAM_PATH="/system/etc/wifi/nvram_net.txt"
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_APMPOWER is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYPAD_CYPRESS_TOUCH=y
+CONFIG_KEYPAD_S3C=y
+CONFIG_KEYPAD_S3C_VICTORY=y
+# CONFIG_KEYPAD_S3C_FORTE is not set
+CONFIG_KEYPAD_S3C_EXPORT_DELAYS=y
+CONFIG_KEYPAD_S3C_SENSITIVE_PRINTKS=y
+CONFIG_S3C_KEYPAD_DEBUG=y
+CONFIG_KEYPAD_S3C_INT=y
+# CONFIG_KEYPAD_S3C_MSM is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_QT602240=y
+# CONFIG_QT602240_TOUCHKEY is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_MXT224 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ACCEL_KR3DH is not set
+CONFIG_INPUT_GYRO_K3G=y
+# CONFIG_INPUT_AD714X is not set
+CONFIG_INPUT_BMA023=y
+CONFIG_INPUT_BMA023_POSITION=5
+CONFIG_INPUT_YAS529=y
+CONFIG_INPUT_YAS529_POSITION=4
+CONFIG_INPUT_ORIENTATION=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+CONFIG_OPTICAL_GP2A=y
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S5PV210=y
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_S3C_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_APM_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_BATTERY_MAX17040=y
+# CONFIG_BATTERY_S3C is not set
+CONFIG_BATTERY_S5PC110=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_HAVE_S3C2410_WATCHDOG=y
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TC35892 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+CONFIG_MFD_MAX8998=y
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_AB8500_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+CONFIG_REGULATOR_MAX8998=y
+CONFIG_REGULATOR_MAX8893=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_IR_CORE is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_CE147=y
+CONFIG_VIDEO_S5KA3DFX=y
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_S5K5CCGX is not set
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+# CONFIG_VIDEO_FIMC_RANGE_WIDE is not set
+# CONFIG_VIDEO_FIMC_DEBUG is not set
+# CONFIG_VIDEO_FIMC_MIPI is not set
+CONFIG_VIDEO_MFC50=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+# CONFIG_VIDEO_MFC50_DEBUG is not set
+CONFIG_VIDEO_JPEG_V2=y
+# CONFIG_VIDEO_JPEG_DEBUG is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+CONFIG_PVR_SGX=y
+CONFIG_PVR_BUILD_RELEASE=y
+# CONFIG_PVR_BUILD_DEBUG is not set
+CONFIG_PVR_NEED_PVR_DPF=y
+CONFIG_PVR_NEED_PVR_ASSERT=y
+CONFIG_PVR_PERCONTEXT_PB=y
+CONFIG_PVR_ACTIVE_POWER_MANAGEMENT=y
+CONFIG_PVR_ACTIVE_POWER_LATENCY_MS=100
+CONFIG_PVR_SGX_LOW_LATENCY_SCHEDULING=y
+CONFIG_PVR_USSE_EDM_STATUS_DEBUG=y
+CONFIG_PVR_DUMP_MK_TRACE=y
+# CONFIG_PVR_PDUMP is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S3C=y
+CONFIG_FB_S3C_SPLASH_SCREEN=y
+CONFIG_FB_S3C_LCD_INIT=y
+# CONFIG_FB_S3C_DEBUG is not set
+# CONFIG_FB_S3C_TRACE_UNDERRUN is not set
+CONFIG_FB_S3C_DEFAULT_WINDOW=2
+CONFIG_FB_S3C_NR_BUFFERS=7
+CONFIG_FB_S3C_NUM_OVLY_WIN=1
+CONFIG_FB_S3C_NUM_BUF_OVLY_WIN=3
+# CONFIG_FB_S3C_VIRTUAL is not set
+# CONFIG_FB_S3C_LTE480WV is not set
+# CONFIG_FB_S3C_HT101HD1 is not set
+CONFIG_FB_S3C_TL2796=y
+# CONFIG_FB_S3C_S6D16A0X is not set
+# CONFIG_FB_S3C_NT35580 is not set
+# CONFIG_FB_S3C_LVDS is not set
+# CONFIG_FB_S3C_AMS701KA is not set
+CONFIG_FB_S3C_MDNIE=y
+CONFIG_FB_S3C_TL2796_ACL=y
+CONFIG_FB_VOODOO=y
+# CONFIG_FB_VOODOO_DEBUG_LOG is not set
+CONFIG_VOODOO_MDNIE=y
+CONFIG_VOODOO_MDNIE_VIDEOS_ALT_PRESETS=y
+# CONFIG_FB_S3C_CMC623 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_BD60910 is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_SOC=y
+CONFIG_SND_S3C24XX_SOC=y
+CONFIG_SND_S3C_I2SV2_SOC=y
+CONFIG_SND_S5PC1XX_SOC_I2S=y
+# CONFIG_SND_C110_PCM is not set
+CONFIG_SND_S5P_SOC_WM8994=y
+CONFIG_SND_S5P_WM8994=y
+CONFIG_SND_S5P_WM8994_MASTER=y
+# CONFIG_S5P_INTERNAL_DMA is not set
+CONFIG_ANDROID_BUF_NUM=1
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM_HUBS=y
+CONFIG_SND_SOC_WM8994=y
+# CONFIG_SND_SOC_WM8994_ATLAS is not set
+CONFIG_SND_SOC_WM8994_VICTORY=y
+CONFIG_SND_VOODOO=y
+CONFIG_SND_VOODOO_HP_LEVEL_CONTROL=y
+CONFIG_SND_VOODOO_HP_LEVEL=47
+CONFIG_SND_VOODOO_RECORD_PRESETS=y
+# CONFIG_SND_VOODOO_DEVELOPMENT is not set
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_SND_S5P_RP is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_HID=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+CONFIG_USB_GADGET_S3C_OTGD=y
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+
+#
+# NOTE: S3C OTG device role enables the controller driver below
+#
+CONFIG_USB_S3C_OTGD=y
+CONFIG_USB_GADGET_S3C_OTGD_DMA_MODE=y
+# CONFIG_USB_GADGET_S3C_OTGD_SLAVE_MODE is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_ANDROID=y
+CONFIG_USB_ANDROID_ACM=y
+CONFIG_USB_DUN_SUPPORT=y
+CONFIG_USB_ANDROID_ADB=y
+CONFIG_USB_ANDROID_MASS_STORAGE=y
+# CONFIG_USB_ANDROID_MTP is not set
+CONFIG_USB_ANDROID_RNDIS=y
+# CONFIG_USB_ANDROID_RNDIS_WCEIS is not set
+CONFIG_USB_ANDROID_RNDIS_DWORD_ALIGNED=y
+CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE=y
+# CONFIG_USB_ANDROID_SAMSUNG_ESCAPE is not set
+# CONFIG_CONFIG_USB_ANDROID_SAMSUNG_RNDIS_WITH_MS_COMPOSITE is not set
+CONFIG_USB_ANDROID_SAMSUNG_MTP=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_GPIO_PLATFORM is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+# CONFIG_LEDS_TRIGGER_SLEEP is not set
+CONFIG_LEDS_TRIGGER_NOTIFICATION=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_IIO is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_FB_SM7XX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_ST_BT is not set
+# CONFIG_ADIS16255 is not set
+CONFIG_SAMSUNG_PHONE_TTY=y
+CONFIG_ONEDRAM_READ_FILE=y
+# CONFIG_ONEDRAM_READ_FSR is not set
+CONFIG_ONEDRAM_DGSINFO=y
+CONFIG_ONEDRAM_HWREV=y
+CONFIG_ONEDRAM_TX_RETRY=10
+# CONFIG_ONEDRAM_CHECKBIT is not set
+# CONFIG_ONEDRAM_IRQPENDING is not set
+# CONFIG_ONEDRAM_IRQ_PENDING is not set
+
+#
+# TinyFSR Support for cramfs
+#
+# CONFIG_TINY_FSR is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+CONFIG_YAFFS_XATTR=y
+# CONFIG_JFFS2_FS is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
+CONFIG_SYSV_FS=y
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+CONFIG_CIFS_EXPERIMENTAL=y
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+CONFIG_SOLARIS_X86_PARTITION=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_PI_LIST=y
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_DETECTOR=y
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=2
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.rej b/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.rej
new file mode 100644
index 0000000..e372087
--- /dev/null
+++ b/Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig.rej
@@ -0,0 +1,17 @@
+--- Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig
++++ Kernel/arch/arm/configs/cyanogenmod_epicmtd_defconfig
+@@ -2,10 +2,14 @@
+ # Automatically generated make config: don't edit
+ # Linux kernel version: 2.6.35.7
+ <<<<<<< HEAD
++<<<<<<< HEAD
+ # Mon Jan 23 04:51:40 2012
+ =======
+ # Mon Jan  9 21:23:52 2012
+ >>>>>>> c31656f239a1f377ddbc624af8f66c740eb5a02c
++=======
++# Tue Jan 10 00:37:28 2012
++>>>>>>> 78eac97... Enable voodoo sound.
+ #
+ CONFIG_ARM=y
+ CONFIG_HAVE_PWM=y
diff --git a/Kernel/block/vr-iosched.c b/Kernel/block/vr-iosched.c
new file mode 100644
index 0000000..2c0c0f0
--- /dev/null
+++ b/Kernel/block/vr-iosched.c
@@ -0,0 +1,446 @@
+/*
+* V(R) I/O Scheduler
+*
+* Copyright (C) 2007 Aaron Carroll <aaronc@gelato.unsw.edu.au>
+*
+*
+* The algorithm:
+*
+* The next request is decided based on its distance from the last
+* request, with a multiplicative penalty of `rev_penalty' applied
+* for reversing the head direction. A rev_penalty of 1 means SSTF
+* behaviour. As this variable is increased, the algorithm approaches
+* pure SCAN. Setting rev_penalty to 0 forces SCAN.
+*
+* Async and synch requests are not treated seperately. Instead we
+* rely on deadlines to ensure fairness.
+*
+*/
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/rbtree.h>
+
+#include <asm/div64.h>
+
+enum vr_data_dir {
+ASYNC,
+SYNC,
+};
+
+enum vr_head_dir {
+FORWARD,
+BACKWARD,
+};
+
+static const int sync_expire = HZ / 2; /* max time before a sync is submitted. */
+static const int async_expire = 5 * HZ; /* ditto for async, these limits are SOFT! */
+static const int fifo_batch = 1;
+static const int rev_penalty = 10; /* penalty for reversing head direction */
+
+struct vr_data {
+struct rb_root sort_list;
+struct list_head fifo_list[2];
+
+struct request *next_rq;
+struct request *prev_rq;
+
+unsigned int nbatched;
+sector_t last_sector; /* head position */
+int head_dir;
+
+/* tunables */
+int fifo_expire[2];
+int fifo_batch;
+int rev_penalty;
+};
+
+static void vr_move_request(struct vr_data *, struct request *);
+
+static inline struct vr_data *
+vr_get_data(struct request_queue *q)
+{
+return q->elevator->elevator_data;
+}
+
+static void
+vr_add_rq_rb(struct vr_data *vd, struct request *rq)
+{
+struct request *alias = elv_rb_add(&vd->sort_list, rq);
+
+if (unlikely(alias)) {
+vr_move_request(vd, alias);
+alias = elv_rb_add(&vd->sort_list, rq);
+BUG_ON(alias);
+}
+
+if (blk_rq_pos(rq) >= vd->last_sector) {
+if (!vd->next_rq || blk_rq_pos(vd->next_rq) > blk_rq_pos(rq))
+vd->next_rq = rq;
+}
+else {
+if (!vd->prev_rq || blk_rq_pos(vd->prev_rq) < blk_rq_pos(rq))
+vd->prev_rq = rq;
+}
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+BUG_ON(vd->next_rq && vd->prev_rq && blk_rq_pos(vd->next_rq) < blk_rq_pos(vd->prev_rq));
+}
+
+static void
+vr_del_rq_rb(struct vr_data *vd, struct request *rq)
+{
+/*
+* We might be deleting our cached next request.
+* If so, find its sucessor.
+*/
+
+if (vd->next_rq == rq)
+vd->next_rq = elv_rb_latter_request(NULL, rq);
+else if (vd->prev_rq == rq)
+vd->prev_rq = elv_rb_former_request(NULL, rq);
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+BUG_ON(vd->next_rq && vd->prev_rq && blk_rq_pos(vd->next_rq) < blk_rq_pos(vd->prev_rq));
+
+elv_rb_del(&vd->sort_list, rq);
+}
+
+/*
+* add rq to rbtree and fifo
+*/
+static void
+vr_add_request(struct request_queue *q, struct request *rq)
+{
+struct vr_data *vd = vr_get_data(q);
+const int dir = rq_is_sync(rq);
+
+vr_add_rq_rb(vd, rq);
+
+if (vd->fifo_expire[dir]) {
+rq_set_fifo_time(rq, jiffies + vd->fifo_expire[dir]);
+list_add_tail(&rq->queuelist, &vd->fifo_list[dir]);
+}
+}
+
+/*
+* remove rq from rbtree and fifo.
+*/
+static void
+vr_remove_request(struct request_queue *q, struct request *rq)
+{
+struct vr_data *vd = vr_get_data(q);
+
+rq_fifo_clear(rq);
+vr_del_rq_rb(vd, rq);
+}
+
+static int
+vr_merge(struct request_queue *q, struct request **rqp, struct bio *bio)
+{
+sector_t sector = bio->bi_sector + bio_sectors(bio);
+struct vr_data *vd = vr_get_data(q);
+struct request *rq = elv_rb_find(&vd->sort_list, sector);
+
+if (rq && elv_rq_merge_ok(rq, bio)) {
+*rqp = rq;
+return ELEVATOR_FRONT_MERGE;
+}
+return ELEVATOR_NO_MERGE;
+}
+
+static void
+vr_merged_request(struct request_queue *q, struct request *req, int type)
+{
+struct vr_data *vd = vr_get_data(q);
+
+/*
+* if the merge was a front merge, we need to reposition request
+*/
+if (type == ELEVATOR_FRONT_MERGE) {
+vr_del_rq_rb(vd, req);
+vr_add_rq_rb(vd, req);
+}
+}
+
+static void
+vr_merged_requests(struct request_queue *q, struct request *rq,
+struct request *next)
+{
+/*
+* if next expires before rq, assign its expire time to rq
+* and move into next position (next will be deleted) in fifo
+*/
+if (!list_empty(&rq->queuelist) && !list_empty(&next->queuelist)) {
+if (time_before(rq_fifo_time(next), rq_fifo_time(rq))) {
+list_move(&rq->queuelist, &next->queuelist);
+rq_set_fifo_time(rq, rq_fifo_time(next));
+}
+}
+
+vr_remove_request(q, next);
+}
+
+/*
+* move an entry to dispatch queue
+*/
+static void
+vr_move_request(struct vr_data *vd, struct request *rq)
+{
+struct request_queue *q = rq->q;
+
+if (blk_rq_pos(rq) > vd->last_sector)
+vd->head_dir = FORWARD;
+else
+vd->head_dir = BACKWARD;
+
+vd->last_sector = blk_rq_pos(rq);
+vd->next_rq = elv_rb_latter_request(NULL, rq);
+vd->prev_rq = elv_rb_former_request(NULL, rq);
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+
+vr_remove_request(q, rq);
+elv_dispatch_add_tail(q, rq);
+vd->nbatched++;
+}
+
+/*
+* get the first expired request in direction ddir
+*/
+static struct request *
+vr_expired_request(struct vr_data *vd, int ddir)
+{
+struct request *rq;
+
+if (list_empty(&vd->fifo_list[ddir]))
+return NULL;
+
+rq = rq_entry_fifo(vd->fifo_list[ddir].next);
+if (time_after(jiffies, rq_fifo_time(rq)))
+return rq;
+
+return NULL;
+}
+
+/*
+* Returns the oldest expired request
+*/
+static struct request *
+vr_check_fifo(struct vr_data *vd)
+{
+struct request *rq_sync = vr_expired_request(vd, SYNC);
+struct request *rq_async = vr_expired_request(vd, ASYNC);
+
+if (rq_async && rq_sync) {
+if (time_after(rq_fifo_time(rq_async), rq_fifo_time(rq_sync)))
+return rq_sync;
+}
+else if (rq_sync)
+return rq_sync;
+
+return rq_async;
+}
+
+/*
+* Return the request with the lowest penalty
+*/
+static struct request *
+vr_choose_request(struct vr_data *vd)
+{
+int penalty = (vd->rev_penalty) ? : INT_MAX;
+struct request *next = vd->next_rq;
+struct request *prev = vd->prev_rq;
+sector_t next_pen, prev_pen;
+
+BUG_ON(prev && prev == next);
+
+if (!prev)
+return next;
+else if (!next)
+return prev;
+
+/* At this point both prev and next are defined and distinct */
+
+next_pen = blk_rq_pos(next) - vd->last_sector;
+prev_pen = vd->last_sector - blk_rq_pos(prev);
+
+if (vd->head_dir == FORWARD)
+next_pen = do_div(next_pen, penalty);
+else
+prev_pen = do_div(prev_pen, penalty);
+
+if (next_pen <= prev_pen)
+return next;
+
+return prev;
+}
+
+static int
+vr_dispatch_requests(struct request_queue *q, int force)
+{
+struct vr_data *vd = vr_get_data(q);
+struct request *rq = NULL;
+
+/* Check for and issue expired requests */
+if (vd->nbatched > vd->fifo_batch) {
+vd->nbatched = 0;
+rq = vr_check_fifo(vd);
+}
+
+if (!rq) {
+rq = vr_choose_request(vd);
+if (!rq)
+return 0;
+}
+
+vr_move_request(vd, rq);
+
+return 1;
+}
+
+static int
+vr_queue_empty(struct request_queue *q)
+{
+struct vr_data *vd = vr_get_data(q);
+return RB_EMPTY_ROOT(&vd->sort_list);
+}
+
+static void
+vr_exit_queue(struct elevator_queue *e)
+{
+struct vr_data *vd = e->elevator_data;
+BUG_ON(!RB_EMPTY_ROOT(&vd->sort_list));
+kfree(vd);
+}
+
+/*
+* initialize elevator private data (vr_data).
+*/
+static void *vr_init_queue(struct request_queue *q)
+{
+struct vr_data *vd;
+
+vd = kmalloc_node(sizeof(*vd), GFP_KERNEL | __GFP_ZERO, q->node);
+if (!vd)
+return NULL;
+
+INIT_LIST_HEAD(&vd->fifo_list[SYNC]);
+INIT_LIST_HEAD(&vd->fifo_list[ASYNC]);
+vd->sort_list = RB_ROOT;
+vd->fifo_expire[SYNC] = sync_expire;
+vd->fifo_expire[ASYNC] = async_expire;
+vd->fifo_batch = fifo_batch;
+vd->rev_penalty = rev_penalty;
+return vd;
+}
+
+/*
+* sysfs parts below
+*/
+
+static ssize_t
+vr_var_show(int var, char *page)
+{
+return sprintf(page, "%d\n", var);
+}
+
+static ssize_t
+vr_var_store(int *var, const char *page, size_t count)
+{
+*var = simple_strtol(page, NULL, 10);
+return count;
+}
+
+#define SHOW_FUNCTION(__FUNC, __VAR, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, char *page) \
+{ \
+struct vr_data *vd = e->elevator_data; \
+int __data = __VAR; \
+if (__CONV) \
+__data = jiffies_to_msecs(__data); \
+return vr_var_show(__data, (page)); \
+}
+SHOW_FUNCTION(vr_sync_expire_show, vd->fifo_expire[SYNC], 1);
+SHOW_FUNCTION(vr_async_expire_show, vd->fifo_expire[ASYNC], 1);
+SHOW_FUNCTION(vr_fifo_batch_show, vd->fifo_batch, 0);
+SHOW_FUNCTION(vr_rev_penalty_show, vd->rev_penalty, 0);
+#undef SHOW_FUNCTION
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count) \
+{ \
+struct vr_data *vd = e->elevator_data; \
+int __data; \
+int ret = vr_var_store(&__data, (page), count); \
+if (__data < (MIN)) \
+__data = (MIN); \
+else if (__data > (MAX)) \
+__data = (MAX); \
+if (__CONV) \
+*(__PTR) = msecs_to_jiffies(__data); \
+else \
+*(__PTR) = __data; \
+return ret; \
+}
+STORE_FUNCTION(vr_sync_expire_store, &vd->fifo_expire[SYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(vr_async_expire_store, &vd->fifo_expire[ASYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(vr_fifo_batch_store, &vd->fifo_batch, 0, INT_MAX, 0);
+STORE_FUNCTION(vr_rev_penalty_store, &vd->rev_penalty, 0, INT_MAX, 0);
+#undef STORE_FUNCTION
+
+#define DD_ATTR(name) \
+__ATTR(name, S_IRUGO|S_IWUSR, vr_##name##_show, \
+vr_##name##_store)
+
+static struct elv_fs_entry vr_attrs[] = {
+DD_ATTR(sync_expire),
+DD_ATTR(async_expire),
+DD_ATTR(fifo_batch),
+DD_ATTR(rev_penalty),
+__ATTR_NULL
+};
+
+static struct elevator_type iosched_vr = {
+.ops = {
+.elevator_merge_fn = vr_merge,
+.elevator_merged_fn = vr_merged_request,
+.elevator_merge_req_fn = vr_merged_requests,
+.elevator_dispatch_fn = vr_dispatch_requests,
+.elevator_add_req_fn = vr_add_request,
+.elevator_queue_empty_fn = vr_queue_empty,
+.elevator_former_req_fn = elv_rb_former_request,
+.elevator_latter_req_fn = elv_rb_latter_request,
+.elevator_init_fn = vr_init_queue,
+.elevator_exit_fn = vr_exit_queue,
+},
+
+.elevator_attrs = vr_attrs,
+.elevator_name = "vr",
+.elevator_owner = THIS_MODULE,
+};
+
+static int __init vr_init(void)
+{
+elv_register(&iosched_vr);
+
+return 0;
+}
+
+static void __exit vr_exit(void)
+{
+elv_unregister(&iosched_vr);
+}
+
+module_init(vr_init);
+module_exit(vr_exit);
+
+MODULE_AUTHOR("Aaron Carroll");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("V(R) IO scheduler");
diff --git a/Kernel/drivers/cpufreq/cpufreq_intellidemand.c b/Kernel/drivers/cpufreq/cpufreq_intellidemand.c
new file mode 100644
index 0000000..63fc3a1
--- /dev/null
+++ b/Kernel/drivers/cpufreq/cpufreq_intellidemand.c
@@ -0,0 +1,1373 @@
+/*
+ *  drivers/cpufreq/cpufreq_intellidemand.c
+ *
+ *  Copyright (C)  2001 Russell King
+ *            (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *                      Jun Nakajima <jun.nakajima@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/jiffies.h>
+#include <linux/kernel_stat.h>
+#include <linux/mutex.h>
+#include <linux/hrtimer.h>
+#include <linux/tick.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/earlysuspend.h>
+
+#define _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+
+/*
+ * dbs is used in this file as a shortform for demandbased switching
+ * It helps to keep variable names smaller, simpler
+ */
+
+#define DEF_FREQUENCY_DOWN_DIFFERENTIAL		(10)
+#define DEF_FREQUENCY_UP_THRESHOLD		(95)
+#define DEF_SAMPLING_DOWN_FACTOR		(25)
+#define MAX_SAMPLING_DOWN_FACTOR		(100000)
+#define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(3)
+#define MICRO_FREQUENCY_UP_THRESHOLD		(95)
+#define MICRO_FREQUENCY_MIN_SAMPLE_RATE		(10000)
+#define MIN_FREQUENCY_UP_THRESHOLD		(11)
+#define MAX_FREQUENCY_UP_THRESHOLD		(100)
+#define MIN_FREQUENCY_DOWN_DIFFERENTIAL		(1)
+
+/*
+ * The polling frequency of this governor depends on the capability of
+ * the processor. Default polling frequency is 1000 times the transition
+ * latency of the processor. The governor will work on any processor with
+ * transition latency <= 10mS, using appropriate sampling
+ * rate.
+ * For CPUs with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
+ * this governor will not work.
+ * All times here are in uS.
+ */
+#define MIN_SAMPLING_RATE_RATIO			(2)
+
+static unsigned int min_sampling_rate;
+
+#define LATENCY_MULTIPLIER			(1000)
+#define MIN_LATENCY_MULTIPLIER			(100)
+#define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
+
+static void do_dbs_timer(struct work_struct *work);
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				unsigned int event);
+
+#ifdef _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend cpufreq_gov_early_suspend;
+static unsigned int cpufreq_gov_lcd_status;
+#endif
+#endif
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND
+static
+#endif
+struct cpufreq_governor cpufreq_gov_intellidemand = {
+       .name                   = "intellidemand",
+       .governor               = cpufreq_governor_dbs,
+       .max_transition_latency = TRANSITION_LATENCY_LIMIT,
+       .owner                  = THIS_MODULE,
+};
+
+/* Sampling types */
+enum {DBS_NORMAL_SAMPLE, DBS_SUB_SAMPLE};
+
+struct cpu_dbs_info_s {
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_iowait;
+	cputime64_t prev_cpu_wall;
+	cputime64_t prev_cpu_nice;
+	struct cpufreq_policy *cur_policy;
+	struct delayed_work work;
+	struct cpufreq_frequency_table *freq_table;
+	unsigned int freq_lo;
+	unsigned int freq_lo_jiffies;
+	unsigned int freq_hi_jiffies;
+	unsigned int rate_mult;
+	int cpu;
+	unsigned int sample_type:1;
+	/*
+	 * percpu mutex that serializes governor limit change with
+	 * do_dbs_timer invocation. We do not want do_dbs_timer to run
+	 * when user is changing the governor or limits.
+	 */
+	struct mutex timer_mutex;
+};
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, od_cpu_dbs_info);
+
+static unsigned int dbs_enable;	/* number of CPUs using this policy */
+
+/*
+ * dbs_mutex protects data in dbs_tuners_ins from concurrent changes on
+ * different CPUs. It protects dbs_enable in governor start/stop.
+ */
+static DEFINE_MUTEX(dbs_mutex);
+
+static struct workqueue_struct	*kintellidemand_wq;
+
+static struct dbs_tuners {
+	unsigned int sampling_rate;
+	unsigned int up_threshold;
+	unsigned int down_differential;
+	unsigned int ignore_nice;
+	unsigned int sampling_down_factor;
+	unsigned int powersave_bias;
+	unsigned int io_is_busy;
+} dbs_tuners_ins = {
+	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
+	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
+	.down_differential = DEF_FREQUENCY_DOWN_DIFFERENTIAL,
+	.ignore_nice = 0,
+	.powersave_bias = 0,
+};
+
+static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
+							cputime64_t *wall)
+{
+	cputime64_t idle_time;
+	cputime64_t cur_wall_time;
+	cputime64_t busy_time;
+
+	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+	busy_time = cputime64_add(kstat_cpu(cpu).cpustat.user,
+			kstat_cpu(cpu).cpustat.system);
+
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.irq);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.softirq);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.steal);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.nice);
+
+	idle_time = cputime64_sub(cur_wall_time, busy_time);
+	if (wall)
+		*wall = (cputime64_t)jiffies_to_usecs(cur_wall_time);
+
+	return (cputime64_t)jiffies_to_usecs(idle_time);
+}
+
+static inline cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall)
+{
+	u64 idle_time = get_cpu_idle_time_us(cpu, wall);
+
+	if (idle_time == -1ULL)
+		return get_cpu_idle_time_jiffy(cpu, wall);
+
+	return idle_time;
+}
+
+static inline cputime64_t get_cpu_iowait_time(unsigned int cpu, cputime64_t *wall)
+{
+	u64 iowait_time = get_cpu_iowait_time_us(cpu, wall);
+
+	if (iowait_time == -1ULL)
+		return 0;
+
+	return iowait_time;
+}
+
+/*
+ * Find right freq to be set now with powersave_bias on.
+ * Returns the freq_hi to be used right now and will set freq_hi_jiffies,
+ * freq_lo, and freq_lo_jiffies in percpu area for averaging freqs.
+ */
+static unsigned int powersave_bias_target(struct cpufreq_policy *policy,
+					  unsigned int freq_next,
+					  unsigned int relation)
+{
+	unsigned int freq_req, freq_reduc, freq_avg;
+	unsigned int freq_hi, freq_lo;
+	unsigned int index = 0;
+	unsigned int jiffies_total, jiffies_hi, jiffies_lo;
+	struct cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info,
+						   policy->cpu);
+
+	if (!dbs_info->freq_table) {
+		dbs_info->freq_lo = 0;
+		dbs_info->freq_lo_jiffies = 0;
+		return freq_next;
+	}
+
+	cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_next,
+			relation, &index);
+	freq_req = dbs_info->freq_table[index].frequency;
+	freq_reduc = freq_req * dbs_tuners_ins.powersave_bias / 1000;
+	freq_avg = freq_req - freq_reduc;
+
+	/* Find freq bounds for freq_avg in freq_table */
+	index = 0;
+	cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,
+			CPUFREQ_RELATION_H, &index);
+	freq_lo = dbs_info->freq_table[index].frequency;
+	index = 0;
+	cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,
+			CPUFREQ_RELATION_L, &index);
+	freq_hi = dbs_info->freq_table[index].frequency;
+
+	/* Find out how long we have to be in hi and lo freqs */
+	if (freq_hi == freq_lo) {
+		dbs_info->freq_lo = 0;
+		dbs_info->freq_lo_jiffies = 0;
+		return freq_lo;
+	}
+	jiffies_total = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+	jiffies_hi = (freq_avg - freq_lo) * jiffies_total;
+	jiffies_hi += ((freq_hi - freq_lo) / 2);
+	jiffies_hi /= (freq_hi - freq_lo);
+	jiffies_lo = jiffies_total - jiffies_hi;
+	dbs_info->freq_lo = freq_lo;
+	dbs_info->freq_lo_jiffies = jiffies_lo;
+	dbs_info->freq_hi_jiffies = jiffies_hi;
+	return freq_hi;
+}
+
+static void intellidemand_powersave_bias_init_cpu(int cpu)
+{
+	struct cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info, cpu);
+	dbs_info->freq_table = cpufreq_frequency_get_table(cpu);
+	dbs_info->freq_lo = 0;
+}
+
+static void intellidemand_powersave_bias_init(void)
+{
+	int i;
+	for_each_online_cpu(i) {
+		intellidemand_powersave_bias_init_cpu(i);
+	}
+}
+
+/************************** sysfs interface ************************/
+
+static ssize_t show_sampling_rate_max(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	printk_once(KERN_INFO "CPUFREQ: intellidemand sampling_rate_max "
+	       "sysfs file is deprecated - used by: %s\n", current->comm);
+	return sprintf(buf, "%u\n", -1U);
+}
+
+static ssize_t show_sampling_rate_min(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", min_sampling_rate);
+}
+
+define_one_global_ro(sampling_rate_max);
+define_one_global_ro(sampling_rate_min);
+
+/* cpufreq_intellidemand Governor Tunables */
+#define show_one(file_name, object)					\
+static ssize_t show_##file_name						\
+(struct kobject *kobj, struct attribute *attr, char *buf)              \
+{									\
+	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
+}
+show_one(sampling_rate, sampling_rate);
+show_one(io_is_busy, io_is_busy);
+show_one(up_threshold, up_threshold);
+show_one(down_differential, down_differential);
+show_one(sampling_down_factor, sampling_down_factor);
+show_one(ignore_nice_load, ignore_nice);
+show_one(powersave_bias, powersave_bias);
+
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+void set_lmf_browser_state(bool onOff);
+void set_lmf_temp_state(bool onOff);
+void set_lmf_active_load(unsigned long freq);
+void set_lmf_inactive_load(unsigned long freq);
+bool get_lmf_browser_state(void);
+bool get_lmf_temp_state(void);
+unsigned long get_lmf_active_load(void);
+unsigned long get_lmf_inactive_load(void);
+
+static ssize_t show_lmf_temp(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", get_lmf_temp_state());
+}
+
+static ssize_t show_lmf_browser(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", get_lmf_browser_state());
+}
+
+static ssize_t show_lmf_active_load(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%ld\n", get_lmf_active_load());
+}
+
+static ssize_t show_lmf_inactive_load(struct kobject *kobj,
+				      struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%ld\n", get_lmf_inactive_load());
+}
+#endif
+
+/*** delete after deprecation time ***/
+
+#define DEPRECATION_MSG(file_name)					\
+	printk_once(KERN_INFO "CPUFREQ: Per core ondemand sysfs "	\
+		    "interface is deprecated - " #file_name "\n");
+
+#define show_one_old(file_name)						\
+static ssize_t show_##file_name##_old					\
+(struct cpufreq_policy *unused, char *buf)				\
+{									\
+	printk_once(KERN_INFO "CPUFREQ: Per core ondemand sysfs "	\
+		    "interface is deprecated - " #file_name "\n");	\
+	return show_##file_name(NULL, NULL, buf);			\
+}
+show_one_old(sampling_rate);
+show_one_old(up_threshold);
+show_one_old(ignore_nice_load);
+show_one_old(powersave_bias);
+show_one_old(sampling_rate_min);
+show_one_old(sampling_rate_max);
+
+cpufreq_freq_attr_ro_old(sampling_rate_min);
+cpufreq_freq_attr_ro_old(sampling_rate_max);
+
+/*** delete after deprecation time ***/
+
+static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.sampling_rate = max(input, min_sampling_rate);
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_io_is_busy(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.io_is_busy = !!input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_up_threshold(struct kobject *a, struct attribute *b,
+				  const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||
+			input < MIN_FREQUENCY_UP_THRESHOLD) {
+		return -EINVAL;
+	}
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.up_threshold = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_down_differential(struct kobject *a, struct attribute *b,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input >= dbs_tuners_ins.up_threshold ||
+			input < MIN_FREQUENCY_DOWN_DIFFERENTIAL) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.down_differential = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_sampling_down_factor(struct kobject *a,
+			struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input, j;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)
+		return -EINVAL;
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.sampling_down_factor = input;
+
+	/* Reset down sampling multiplier in case it was active */
+	for_each_online_cpu(j) {
+		struct cpu_dbs_info_s *dbs_info;
+		dbs_info = &per_cpu(od_cpu_dbs_info, j);
+		dbs_info->rate_mult = 1;
+	}
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_ignore_nice_load(struct kobject *a, struct attribute *b,
+				      const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	unsigned int j;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+
+	mutex_lock(&dbs_mutex);
+	if (input == dbs_tuners_ins.ignore_nice) { /* nothing to do */
+		mutex_unlock(&dbs_mutex);
+		return count;
+	}
+	dbs_tuners_ins.ignore_nice = input;
+
+	/* we need to re-evaluate prev_cpu_idle */
+	for_each_online_cpu(j) {
+		struct cpu_dbs_info_s *dbs_info;
+		dbs_info = &per_cpu(od_cpu_dbs_info, j);
+		dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+						&dbs_info->prev_cpu_wall);
+		if (dbs_tuners_ins.ignore_nice)
+			dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+
+	}
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_powersave_bias(struct kobject *a, struct attribute *b,
+				    const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 1000)
+		input = 1000;
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.powersave_bias = input;
+	intellidemand_powersave_bias_init();
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+static ssize_t store_lmf_temp(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	set_lmf_temp_state(input);
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_lmf_browser(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	set_lmf_browser_state(input);
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_lmf_active_load(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned long input;
+	int ret;
+
+	ret = sscanf(buf, "%ld", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	set_lmf_active_load(input);
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_lmf_inactive_load(struct kobject *a, struct attribute *b,
+				   const char *buf, size_t count)
+{
+	unsigned long input;
+	int ret;
+
+	ret = sscanf(buf, "%ld", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	set_lmf_inactive_load(input);
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+#endif
+
+define_one_global_rw(sampling_rate);
+define_one_global_rw(io_is_busy);
+define_one_global_rw(up_threshold);
+define_one_global_rw(down_differential);
+define_one_global_rw(sampling_down_factor);
+define_one_global_rw(ignore_nice_load);
+define_one_global_rw(powersave_bias);
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+define_one_global_rw(lmf_temp);
+define_one_global_rw(lmf_browser);
+define_one_global_rw(lmf_active_load);
+define_one_global_rw(lmf_inactive_load);
+#endif
+static struct attribute *dbs_attributes[] = {
+	&sampling_rate_max.attr,
+	&sampling_rate_min.attr,
+	&sampling_rate.attr,
+	&up_threshold.attr,
+	&down_differential.attr,
+	&sampling_down_factor.attr,
+	&ignore_nice_load.attr,
+	&powersave_bias.attr,
+	&io_is_busy.attr,
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+	&lmf_temp.attr,
+	&lmf_browser.attr,
+	&lmf_active_load.attr,
+	&lmf_inactive_load.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+	.attrs = dbs_attributes,
+	.name = "intellidemand",
+};
+
+/*** delete after deprecation time ***/
+
+#define write_one_old(file_name)					\
+static ssize_t store_##file_name##_old					\
+(struct cpufreq_policy *unused, const char *buf, size_t count)		\
+{									\
+       printk_once(KERN_INFO "CPUFREQ: Per core ondemand sysfs "	\
+		   "interface is deprecated - " #file_name "\n");	\
+       return store_##file_name(NULL, NULL, buf, count);		\
+}
+write_one_old(sampling_rate);
+write_one_old(up_threshold);
+write_one_old(ignore_nice_load);
+write_one_old(powersave_bias);
+
+cpufreq_freq_attr_rw_old(sampling_rate);
+cpufreq_freq_attr_rw_old(up_threshold);
+cpufreq_freq_attr_rw_old(ignore_nice_load);
+cpufreq_freq_attr_rw_old(powersave_bias);
+
+static struct attribute *dbs_attributes_old[] = {
+       &sampling_rate_max_old.attr,
+       &sampling_rate_min_old.attr,
+       &sampling_rate_old.attr,
+       &up_threshold_old.attr,
+       &ignore_nice_load_old.attr,
+       &powersave_bias_old.attr,
+       NULL
+};
+
+static struct attribute_group dbs_attr_group_old = {
+       .attrs = dbs_attributes_old,
+       .name = "intellidemand",
+};
+
+/*** delete after deprecation time ***/
+
+/************************** sysfs end ************************/
+
+static void dbs_freq_increase(struct cpufreq_policy *p, unsigned int freq)
+{
+	if (dbs_tuners_ins.powersave_bias)
+		freq = powersave_bias_target(p, freq, CPUFREQ_RELATION_H);
+	else if (p->cur == p->max)
+		return;
+
+	__cpufreq_driver_target(p, freq, dbs_tuners_ins.powersave_bias ?
+			CPUFREQ_RELATION_L : CPUFREQ_RELATION_H);
+}
+
+static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
+{
+	unsigned int max_load_freq;
+
+	struct cpufreq_policy *policy;
+	unsigned int j;
+
+	this_dbs_info->freq_lo = 0;
+	policy = this_dbs_info->cur_policy;
+
+	/*
+	 * Every sampling_rate, we check, if current idle time is less
+	 * than 20% (default), then we try to increase frequency
+	 * Every sampling_rate, we look for a the lowest
+	 * frequency which can sustain the load while keeping idle time over
+	 * 30%. If such a frequency exist, we try to decrease to this frequency.
+	 *
+	 * Any frequency increase takes it to the maximum frequency.
+	 * Frequency reduction happens at minimum steps of
+	 * 5% (default) of current frequency
+	 */
+
+	/* Get Absolute Load - in terms of freq */
+	max_load_freq = 0;
+
+	for_each_cpu(j, policy->cpus) {
+		struct cpu_dbs_info_s *j_dbs_info;
+		cputime64_t cur_wall_time, cur_idle_time, cur_iowait_time;
+		unsigned int idle_time, wall_time, iowait_time;
+		unsigned int load, load_freq;
+		int freq_avg;
+
+		j_dbs_info = &per_cpu(od_cpu_dbs_info, j);
+
+		cur_idle_time = get_cpu_idle_time(j, &cur_wall_time);
+		cur_iowait_time = get_cpu_iowait_time(j, &cur_wall_time);
+
+		wall_time = (unsigned int) cputime64_sub(cur_wall_time,
+				j_dbs_info->prev_cpu_wall);
+		j_dbs_info->prev_cpu_wall = cur_wall_time;
+
+		idle_time = (unsigned int) cputime64_sub(cur_idle_time,
+				j_dbs_info->prev_cpu_idle);
+		j_dbs_info->prev_cpu_idle = cur_idle_time;
+
+		iowait_time = (unsigned int) cputime64_sub(cur_iowait_time,
+				j_dbs_info->prev_cpu_iowait);
+		j_dbs_info->prev_cpu_iowait = cur_iowait_time;
+
+		if (dbs_tuners_ins.ignore_nice) {
+			cputime64_t cur_nice;
+			unsigned long cur_nice_jiffies;
+
+			cur_nice = cputime64_sub(kstat_cpu(j).cpustat.nice,
+					 j_dbs_info->prev_cpu_nice);
+			/*
+			 * Assumption: nice time between sampling periods will
+			 * be less than 2^32 jiffies for 32 bit sys
+			 */
+			cur_nice_jiffies = (unsigned long)
+					cputime64_to_jiffies64(cur_nice);
+
+			j_dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+			idle_time += jiffies_to_usecs(cur_nice_jiffies);
+		}
+
+		/*
+		 * For the purpose of ondemand, waiting for disk IO is an
+		 * indication that you're performance critical, and not that
+		 * the system is actually idle. So subtract the iowait time
+		 * from the cpu idle time.
+		 */
+
+		if (dbs_tuners_ins.io_is_busy && idle_time >= iowait_time)
+			idle_time -= iowait_time;
+
+		if (unlikely(!wall_time || wall_time < idle_time))
+			continue;
+
+		load = 100 * (wall_time - idle_time) / wall_time;
+
+		freq_avg = __cpufreq_driver_getavg(policy, j);
+		if (freq_avg <= 0)
+			freq_avg = policy->cur;
+
+		load_freq = load * freq_avg;
+		if (load_freq > max_load_freq)
+			max_load_freq = load_freq;
+	}
+
+	/* Check for frequency increase */
+	if (max_load_freq > dbs_tuners_ins.up_threshold * policy->cur) {
+
+/* In case of increase to max freq., freq. scales by 2 step for reducing the current consumption*/
+#ifdef _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+		if(!cpufreq_gov_lcd_status) {
+			if (policy->cur < policy->max) {
+				if (policy->cur < 500000) dbs_freq_increase(policy, 800000);
+				else if (policy->cur < 800000) dbs_freq_increase(policy, 1000000);
+				else {
+					this_dbs_info->rate_mult = dbs_tuners_ins.sampling_down_factor;
+					dbs_freq_increase(policy, policy->max);
+				}
+			}
+			return;
+		} else
+#endif
+		/* If switching to max speed, apply sampling_down_factor */
+		if (policy->cur < policy->max)
+			this_dbs_info->rate_mult =
+				dbs_tuners_ins.sampling_down_factor;
+		dbs_freq_increase(policy, policy->max);
+		return;
+	}
+
+	/* Check for frequency decrease */
+	/* if we cannot reduce the frequency anymore, break out early */
+	if (policy->cur == policy->min)
+		return;
+
+	/*
+	 * The optimal frequency is the frequency that is the lowest that
+	 * can support the current CPU usage without triggering the up
+	 * policy. To be safe, we focus 10 points under the threshold.
+	 */
+	if (max_load_freq <
+	    (dbs_tuners_ins.up_threshold - dbs_tuners_ins.down_differential) *
+	     policy->cur) {
+		unsigned int freq_next;
+		freq_next = max_load_freq /
+				(dbs_tuners_ins.up_threshold -
+				 dbs_tuners_ins.down_differential);
+
+		/* No longer fully busy, reset rate_mult */
+		this_dbs_info->rate_mult = 1;
+
+		if (freq_next < policy->min)
+			freq_next = policy->min;
+
+		if (!dbs_tuners_ins.powersave_bias) {
+			__cpufreq_driver_target(policy, freq_next,
+					CPUFREQ_RELATION_L);
+		} else {
+			int freq = powersave_bias_target(policy, freq_next,
+					CPUFREQ_RELATION_L);
+			__cpufreq_driver_target(policy, freq,
+				CPUFREQ_RELATION_L);
+		}
+	}
+}
+
+#ifdef CONFIG_DETECT_BROWSER_STATE
+extern bool yamato_busy;
+#endif
+
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+
+#include "../../kernel/power/power.h"
+
+enum {	
+	SET_MIN = 0,	
+	SET_MAX
+};
+
+enum {	
+	BOOT_CPU = 0,	
+	NON_BOOT_CPU
+};
+
+#define SAMPLE_DURATION_MSEC	(10*1000) // 10 secs >= 10000 msec
+#define ACTIVE_DURATION_MSEC	(10*60*1000) // 10 mins
+#define INACTIVE_DURATION_MSEC	(2*60*1000) // 2 mins
+#define MAX_ACTIVE_FREQ_LIMIT	65 // %
+#define MAX_INACTIVE_FREQ_LIMIT	45 // %
+#define ACTIVE_MAX_FREQ			1600000
+#define INACTIVE_MAX_FREQ		800000
+
+#define NUM_ACTIVE_LOAD_ARRAY	(ACTIVE_DURATION_MSEC/SAMPLE_DURATION_MSEC)
+#define NUM_INACTIVE_LOAD_ARRAY	(INACTIVE_DURATION_MSEC/SAMPLE_DURATION_MSEC)
+
+static bool lmf_browser_state = false;
+static bool lmf_temp_state = true; // temp is not used now
+
+static unsigned long lmf_active_load_limit = MAX_ACTIVE_FREQ_LIMIT;
+static unsigned long lmf_inactive_load_limit = MAX_INACTIVE_FREQ_LIMIT;
+
+static unsigned long jiffies_old = 0;
+static unsigned long time_int = 0;
+static unsigned long time_int1 = 0;
+static unsigned long load_state_total0  = 0;
+static unsigned long load_state_total1  = 0;
+static unsigned long load_limit_index = 0;	
+static unsigned long load_limit_total[NUM_ACTIVE_LOAD_ARRAY];
+static unsigned long msecs_limit_total = 0;
+static bool active_state = true;
+static bool lmf_old_state = false;
+
+extern int cpufreq_set_limits(int cpu, unsigned int limit, unsigned int value);
+extern int cpufreq_set_limits_off(int cpu, unsigned int limit, unsigned int value);
+extern suspend_state_t get_suspend_state(void);
+
+void set_lmf_browser_state(bool onOff)
+{
+	if (onOff)
+		lmf_browser_state = true;
+	else
+		lmf_browser_state = false;
+}
+
+void set_lmf_temp_state(bool onOff)
+{
+	if (onOff)
+		lmf_temp_state = true;
+	else
+		lmf_temp_state = false;
+}
+
+void set_lmf_active_load(unsigned long freq)
+{
+	lmf_active_load_limit = freq;
+}
+
+void set_lmf_inactive_load(unsigned long freq)
+{
+	lmf_inactive_load_limit = freq;
+}
+
+bool get_lmf_browser_state(void)
+{
+#ifdef CONFIG_DETECT_BROWSER_STATE
+	return yamato_busy;
+#else
+	return lmf_browser_state;
+#endif
+}
+
+bool get_lmf_temp_state(void)
+{
+	return lmf_temp_state;
+}
+
+unsigned long get_lmf_active_load(void)
+{
+	return lmf_active_load_limit;
+}
+
+unsigned long get_lmf_inactive_load(void)
+{
+	return lmf_inactive_load_limit;
+}
+#endif
+
+static void do_dbs_timer(struct work_struct *work)
+{
+	struct cpu_dbs_info_s *dbs_info =
+		container_of(work, struct cpu_dbs_info_s, work.work);
+	unsigned int cpu = dbs_info->cpu;
+	int sample_type = dbs_info->sample_type;
+
+	/* We want all CPUs to do sampling nearly on same jiffy */
+	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate
+		* dbs_info->rate_mult);
+
+	if (num_online_cpus() > 1)
+		delay -= jiffies % delay;
+
+#ifdef CONFIG_SEC_LIMIT_MAX_FREQ // limit max freq
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#ifdef _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+#ifdef CONFIG_DETECT_BROWSER_STATE
+	if (!yamato_busy || !lmf_temp_state || !cpufreq_gov_lcd_status)
+#else
+	if (!lmf_browser_state || !lmf_temp_state || !cpufreq_gov_lcd_status)
+#endif
+#else
+	if (!lmf_browser_state || !lmf_temp_state || !(get_suspend_state()==PM_SUSPEND_ON))
+#endif
+#else
+	if (!lmf_browser_state || !lmf_temp_state)
+#endif
+	{
+		if (cpu == BOOT_CPU)
+		{
+			if (lmf_old_state == true)
+			{
+				printk("LMF: disabled\n");
+				lmf_old_state = false;
+			}
+
+			if (!active_state)
+			{
+				/* set freq to 1.5GHz */
+				printk("LMF: CPU0 set max freq to 1.5GHz\n");
+				cpufreq_set_limits(BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+				
+				printk("LMF: CPU1 set max freq to 1.5GHz\n");
+				if (cpu_online(NON_BOOT_CPU))
+					cpufreq_set_limits(NON_BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+				else
+					cpufreq_set_limits_off(NON_BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+			}
+			
+			jiffies_old = 0;
+			time_int = 0;
+			time_int1 = 0;
+			load_state_total0 = 0;
+			load_state_total1 = 0;
+			msecs_limit_total = 0;
+			load_limit_index = 0;
+			active_state = true;
+		}
+	}
+	else // lmf_browser_state && lmf_temp_state -> TRUE
+	{
+		struct cpufreq_policy *policy;
+		unsigned long load_state_cpu = 0;
+		unsigned int delay_msec = 0;
+		unsigned long load_total  = 0;
+		unsigned long jiffies_cur = jiffies;
+		
+		if (cpu == NON_BOOT_CPU)
+		{
+			delay_msec = (dbs_tuners_ins.sampling_rate * dbs_info->rate_mult) / 1000;
+			policy = dbs_info->cur_policy;
+			load_state_cpu = ((policy->cur) * delay_msec)/10000;
+
+			time_int1 += delay_msec;
+			load_state_total1 += load_state_cpu;
+		}
+		else
+		{
+			if (lmf_old_state == false)
+			{
+				printk("LMF: enabled\n");
+				lmf_old_state = true;
+			}
+
+			if (jiffies_old == 0) 
+			{
+				jiffies_old = jiffies_cur;
+			}
+			else
+			{
+				delay_msec = jiffies_to_msecs(jiffies_cur - jiffies_old);
+				jiffies_old = jiffies_cur;
+				policy = dbs_info->cur_policy;
+				load_state_cpu = ((policy->cur) * delay_msec)/10000;
+				
+				time_int += delay_msec;
+				load_state_total0 += load_state_cpu;			
+				
+				/* average */
+				if (time_int >= SAMPLE_DURATION_MSEC)
+				{
+					int i = 0;
+					unsigned long ave_max = 0;
+					unsigned long average = 0;
+					unsigned long average_dec = 0;
+					unsigned long total_load = 0;
+
+					load_total = load_state_total0 + load_state_total1;
+					ave_max = (time_int / 10) * ((ACTIVE_MAX_FREQ/1000) * 2);
+					average = (load_total * 100) / ave_max;
+					average_dec = (load_total  * 100) % ave_max;
+
+					msecs_limit_total += time_int;
+					load_limit_total[load_limit_index++] = average;
+
+					//printk("LMF: average = %ld.%ld, (%ld:%ld) (%ld:%ld) (%ld:%ld)\n", 
+					//	average, average_dec, time_int, time_int1, load_state_total0, load_state_total1, load_limit_index-1, msecs_limit_total);
+
+					time_int = 0;
+					time_int1 = 0;
+					load_state_total0 = 0;
+					load_state_total1 = 0;
+
+					/* active */
+					if (active_state)
+					{
+						if (load_limit_index >= NUM_ACTIVE_LOAD_ARRAY)
+						{
+							load_limit_index = 0;
+						}
+						
+						if (msecs_limit_total > ACTIVE_DURATION_MSEC)
+						{
+							for (i=0; i<NUM_ACTIVE_LOAD_ARRAY; i++)
+							{
+								total_load += load_limit_total[i];
+							}
+
+							average = total_load / NUM_ACTIVE_LOAD_ARRAY;
+							average_dec = total_load % NUM_ACTIVE_LOAD_ARRAY;
+							//printk("LMF:ACTIVE: total_avg = %ld.%ld\n", average, average_dec);
+
+							if (average > lmf_active_load_limit)
+							{
+								msecs_limit_total = 0;
+								load_limit_index = 0;
+								active_state = false;
+
+								/* set freq to 1.0GHz */
+								printk("LMF: CPU0 set max freq to 1.0GHz\n");
+								cpufreq_set_limits(BOOT_CPU, SET_MAX, INACTIVE_MAX_FREQ);
+								
+								printk("LMF: CPU1 set max freq to 1.0GHz\n");
+								if (cpu_online(NON_BOOT_CPU))
+									cpufreq_set_limits(NON_BOOT_CPU, SET_MAX, INACTIVE_MAX_FREQ);
+								else
+									cpufreq_set_limits_off(NON_BOOT_CPU, SET_MAX, INACTIVE_MAX_FREQ);
+							}
+							else
+							{
+								msecs_limit_total = ACTIVE_DURATION_MSEC; // to prevent overflow
+							}
+						}
+					}
+					else /* inactive */
+					{
+						if (load_limit_index >= NUM_INACTIVE_LOAD_ARRAY)
+						{
+							load_limit_index = 0;
+						}
+						
+						if (msecs_limit_total > INACTIVE_DURATION_MSEC)
+						{
+							for (i=0; i<NUM_INACTIVE_LOAD_ARRAY; i++)
+							{
+								total_load += load_limit_total[i];
+							}
+
+							average = total_load / NUM_INACTIVE_LOAD_ARRAY;
+							average_dec = total_load % NUM_INACTIVE_LOAD_ARRAY;
+							//printk("LMF:INACTIVE: total_avg = %ld.%ld\n", average, average_dec);
+
+							if (average < lmf_inactive_load_limit)
+							{
+								msecs_limit_total = 0;
+								load_limit_index = 0;
+								active_state = true;
+
+								/* set freq to 1.5GHz */
+								printk("LMF: CPU0 set max freq to 1.5GHz\n");
+								cpufreq_set_limits(BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+								
+								printk("LMF: CPU1 set max freq to 1.5GHz\n");
+								if (cpu_online(NON_BOOT_CPU))
+									cpufreq_set_limits(NON_BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+								else
+									cpufreq_set_limits_off(NON_BOOT_CPU, SET_MAX, ACTIVE_MAX_FREQ);
+							}
+							else
+							{
+								msecs_limit_total = INACTIVE_DURATION_MSEC; // to prevent overflow
+							}
+						}
+					}
+				}
+			}
+		}	
+	}
+#endif
+
+	mutex_lock(&dbs_info->timer_mutex);
+
+	/* Common NORMAL_SAMPLE setup */
+	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
+	if (!dbs_tuners_ins.powersave_bias ||
+	    sample_type == DBS_NORMAL_SAMPLE) {
+		dbs_check_cpu(dbs_info);
+		if (dbs_info->freq_lo) {
+			/* Setup timer for SUB_SAMPLE */
+			dbs_info->sample_type = DBS_SUB_SAMPLE;
+			delay = dbs_info->freq_hi_jiffies;
+		}
+	} else {
+		__cpufreq_driver_target(dbs_info->cur_policy,
+			dbs_info->freq_lo, CPUFREQ_RELATION_H);
+	}
+	queue_delayed_work_on(cpu, kintellidemand_wq, &dbs_info->work, delay);
+	mutex_unlock(&dbs_info->timer_mutex);
+}
+
+static inline void dbs_timer_init(struct cpu_dbs_info_s *dbs_info)
+{
+	/* We want all CPUs to do sampling nearly on same jiffy */
+	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+
+	if (num_online_cpus() > 1)
+		delay -= jiffies % delay;
+
+	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
+	INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
+	queue_delayed_work_on(dbs_info->cpu, kintellidemand_wq, &dbs_info->work,
+		delay);
+}
+
+static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
+{
+	cancel_delayed_work_sync(&dbs_info->work);
+}
+
+/*
+ * Not all CPUs want IO time to be accounted as busy; this dependson how
+ * efficient idling at a higher frequency/voltage is.
+ * Pavel Machek says this is not so for various generations of AMD and old
+ * Intel systems.
+ * Mike Chan (androidlcom) calis this is also not true for ARM.
+ * Because of this, whitelist specific known (series) of CPUs by default, and
+ * leave all others up to the user.
+ */
+static int should_io_be_busy(void)
+{
+#if defined(CONFIG_X86)
+	/*
+	 * For Intel, Core 2 (model 15) andl later have an efficient idle.
+	 */
+	if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&
+	    boot_cpu_data.x86 == 6 &&
+	    boot_cpu_data.x86_model >= 15)
+		return 1;
+#endif
+#if defined(CONFIG_ARM)
+	return 1;
+#endif
+	return 0;
+}
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				   unsigned int event)
+{
+	unsigned int cpu = policy->cpu;
+	struct cpu_dbs_info_s *this_dbs_info;
+	unsigned int j;
+	int rc;
+
+	this_dbs_info = &per_cpu(od_cpu_dbs_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!policy->cur))
+			return -EINVAL;
+
+		mutex_lock(&dbs_mutex);
+
+		rc = sysfs_create_group(&policy->kobj, &dbs_attr_group_old);
+		if (rc) {
+			mutex_unlock(&dbs_mutex);
+			return rc;
+		}
+
+		dbs_enable++;
+		for_each_cpu(j, policy->cpus) {
+			struct cpu_dbs_info_s *j_dbs_info;
+			j_dbs_info = &per_cpu(od_cpu_dbs_info, j);
+			j_dbs_info->cur_policy = policy;
+
+			j_dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+						&j_dbs_info->prev_cpu_wall);
+			if (dbs_tuners_ins.ignore_nice) {
+				j_dbs_info->prev_cpu_nice =
+						kstat_cpu(j).cpustat.nice;
+			}
+		}
+		this_dbs_info->cpu = cpu;
+		this_dbs_info->rate_mult = 1;
+		intellidemand_powersave_bias_init_cpu(cpu);
+		/*
+		 * Start the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 1) {
+			unsigned int latency;
+
+			rc = sysfs_create_group(cpufreq_global_kobject,
+						&dbs_attr_group);
+			if (rc) {
+				mutex_unlock(&dbs_mutex);
+				return rc;
+			}
+
+			/* policy latency is in nS. Convert it to uS first */
+			latency = policy->cpuinfo.transition_latency / 1000;
+			if (latency == 0)
+				latency = 1;
+			/* Bring kernel and HW constraints together */
+			min_sampling_rate = max(min_sampling_rate,
+					MIN_LATENCY_MULTIPLIER * latency);
+			//HTC: use QCT setting in /system/etc/init.post_boot.rc
+			if (!dbs_tuners_ins.sampling_rate)
+				dbs_tuners_ins.sampling_rate =
+					max(min_sampling_rate,
+					    latency * LATENCY_MULTIPLIER);
+			dbs_tuners_ins.io_is_busy = should_io_be_busy();
+		}
+		mutex_unlock(&dbs_mutex);
+
+		mutex_init(&this_dbs_info->timer_mutex);
+		dbs_timer_init(this_dbs_info);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		dbs_timer_exit(this_dbs_info);
+
+		mutex_lock(&dbs_mutex);
+		sysfs_remove_group(&policy->kobj, &dbs_attr_group_old);
+		mutex_destroy(&this_dbs_info->timer_mutex);
+		dbs_enable--;
+		mutex_unlock(&dbs_mutex);
+		if (!dbs_enable)
+			sysfs_remove_group(cpufreq_global_kobject,
+					   &dbs_attr_group);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		mutex_lock(&this_dbs_info->timer_mutex);
+		if (policy->max < this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(this_dbs_info->cur_policy,
+				policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(this_dbs_info->cur_policy,
+				policy->min, CPUFREQ_RELATION_L);
+		mutex_unlock(&this_dbs_info->timer_mutex);
+		break;
+	}
+	return 0;
+}
+
+#ifdef _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cpufreq_gov_suspend(struct early_suspend *h)
+{
+	cpufreq_gov_lcd_status = 0;
+
+	pr_info("%s : cpufreq_gov_lcd_status %d\n", __func__, cpufreq_gov_lcd_status);
+}
+
+static void cpufreq_gov_resume(struct early_suspend *h)
+{
+	cpufreq_gov_lcd_status = 1;
+
+	pr_info("%s : cpufreq_gov_lcd_status %d\n", __func__, cpufreq_gov_lcd_status);
+}
+#endif
+#endif
+
+static int __init cpufreq_gov_dbs_init(void)
+{
+	int err;
+	cputime64_t wall;
+	u64 idle_time;
+	int cpu = get_cpu();
+
+	idle_time = get_cpu_idle_time_us(cpu, &wall);
+	put_cpu();
+	if (idle_time != -1ULL) {
+		/* Idle micro accounting is supported. Use finer thresholds */
+		dbs_tuners_ins.up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;
+		dbs_tuners_ins.down_differential =
+					MICRO_FREQUENCY_DOWN_DIFFERENTIAL;
+		/*
+		 * In no_hz/micro accounting case we set the minimum frequency
+		 * not depending on HZ, but fixed (very low). The deferred
+		 * timer might skip some samples if idle/sleeping as needed.
+		*/
+		min_sampling_rate = MICRO_FREQUENCY_MIN_SAMPLE_RATE;
+	} else {
+		/* For correct statistics, we need 10 ticks for each measure */
+		min_sampling_rate =
+			MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(10);
+	}
+
+	kintellidemand_wq = create_workqueue("kintellidemand");
+	if (!kintellidemand_wq) {
+		printk(KERN_ERR "Creation of kintellidemand failed\n");
+		return -EFAULT;
+	}
+	err = cpufreq_register_governor(&cpufreq_gov_intellidemand);
+	if (err)
+		destroy_workqueue(kintellidemand_wq);
+
+#ifdef _LIMIT_LCD_OFF_CPU_MAX_FREQ_
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	cpufreq_gov_lcd_status = 1;
+
+	cpufreq_gov_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+
+	cpufreq_gov_early_suspend.suspend = cpufreq_gov_suspend;
+	cpufreq_gov_early_suspend.resume = cpufreq_gov_resume;
+	register_early_suspend(&cpufreq_gov_early_suspend);
+#endif
+#endif
+
+	return err;
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_intellidemand);
+	destroy_workqueue(kintellidemand_wq);
+}
+
+
+MODULE_AUTHOR("Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>");
+MODULE_AUTHOR("Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>");
+MODULE_DESCRIPTION("'cpufreq_intellidemand' - A dynamic cpufreq governor for "
+	"Low Latency Frequency Transition capable processors");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif
+module_exit(cpufreq_gov_dbs_exit);
diff --git a/Kernel/drivers/cpufreq/cpufreq_lagfree.c b/Kernel/drivers/cpufreq/cpufreq_lagfree.c
new file mode 100644
index 0000000..cf22027
--- /dev/null
+++ b/Kernel/drivers/cpufreq/cpufreq_lagfree.c
@@ -0,0 +1,662 @@
+/*
+ *  drivers/cpufreq/cpufreq_lagfree.c
+ *
+ *  Copyright (C)  2001 Russell King
+ *            (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *                      Jun Nakajima <jun.nakajima@intel.com>
+ *            (C)  2004 Alexander Clouter <alex-kernel@digriz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/cpufreq.h>
+#include <linux/sysctl.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/cpu.h>
+#include <linux/kmod.h>
+#include <linux/workqueue.h>
+#include <linux/jiffies.h>
+#include <linux/kernel_stat.h>
+#include <linux/percpu.h>
+#include <linux/mutex.h>
+#include <linux/earlysuspend.h>
+/*
+ * dbs is used in this file as a shortform for demandbased switching
+ * It helps to keep variable names smaller, simpler
+ */
+
+#define DEF_FREQUENCY_UP_THRESHOLD				(50)
+#define DEF_FREQUENCY_DOWN_THRESHOLD				(15)
+#define FREQ_STEP_DOWN 						(200000)
+#define FREQ_SLEEP_MAX 						(500000)
+#define FREQ_AWAKE_MIN 						(500000)
+#define FREQ_STEP_UP_SLEEP_PERCENT				(20)
+
+/*
+ * The polling frequency of this governor depends on the capability of
+ * the processor. Default polling frequency is 1000 times the transition
+ * latency of the processor. The governor will work on any processor with
+ * transition latency <= 10mS, using appropriate sampling
+ * rate.
+ * For CPUs with transition latency > 10mS (mostly drivers
+ * with CPUFREQ_ETERNAL), this governor will not work.
+ * All times here are in uS.
+ */
+static unsigned int def_sampling_rate;
+unsigned int suspended = 0;
+#define MIN_SAMPLING_RATE_RATIO			(2)
+/* for correct statistics, we need at least 10 ticks between each measure */
+#define MIN_STAT_SAMPLING_RATE			\
+	(MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(10))
+#define MIN_SAMPLING_RATE			\
+			(def_sampling_rate / MIN_SAMPLING_RATE_RATIO)
+#define MAX_SAMPLING_RATE			(500 * def_sampling_rate)
+#define DEF_SAMPLING_DOWN_FACTOR		(4)
+#define MAX_SAMPLING_DOWN_FACTOR		(10)
+#define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
+
+static void do_dbs_timer(struct work_struct *work);
+
+struct cpu_dbs_info_s {
+	struct cpufreq_policy *cur_policy;
+	unsigned int prev_cpu_idle_up;
+	unsigned int prev_cpu_idle_down;
+	unsigned int enable;
+	unsigned int down_skip;
+	unsigned int requested_freq;
+};
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, cpu_dbs_info);
+
+static unsigned int dbs_enable;	/* number of CPUs using this policy */
+
+/*
+ * DEADLOCK ALERT! There is a ordering requirement between cpu_hotplug
+ * lock and dbs_mutex. cpu_hotplug lock should always be held before
+ * dbs_mutex. If any function that can potentially take cpu_hotplug lock
+ * (like __cpufreq_driver_target()) is being called with dbs_mutex taken, then
+ * cpu_hotplug lock should be taken before that. Note that cpu_hotplug lock
+ * is recursive for the same process. -Venki
+ */
+static DEFINE_MUTEX (dbs_mutex);
+static DECLARE_DELAYED_WORK(dbs_work, do_dbs_timer);
+
+struct dbs_tuners {
+	unsigned int sampling_rate;
+	unsigned int sampling_down_factor;
+	unsigned int up_threshold;
+	unsigned int down_threshold;
+	unsigned int ignore_nice;
+	//unsigned int freq_step;
+};
+
+static struct dbs_tuners dbs_tuners_ins = {
+	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
+	.down_threshold = DEF_FREQUENCY_DOWN_THRESHOLD,
+	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
+	.ignore_nice = 1,
+	//.freq_step = 5,
+};
+
+static inline unsigned int get_cpu_idle_time(unsigned int cpu)
+{
+	unsigned int add_nice = 0, ret;
+
+	if (dbs_tuners_ins.ignore_nice)
+		add_nice = kstat_cpu(cpu).cpustat.nice;
+
+	ret = kstat_cpu(cpu).cpustat.idle +
+		kstat_cpu(cpu).cpustat.iowait +
+		add_nice;
+
+	return ret;
+}
+
+/* keep track of frequency transitions */
+static int
+dbs_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+		     void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cpu_dbs_info,
+							freq->cpu);
+
+	if (!this_dbs_info->enable)
+		return 0;
+
+	this_dbs_info->requested_freq = freq->new;
+
+	return 0;
+}
+
+static struct notifier_block dbs_cpufreq_notifier_block = {
+	.notifier_call = dbs_cpufreq_notifier
+};
+
+/************************** sysfs interface ************************/
+static ssize_t show_sampling_rate_max(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", MAX_SAMPLING_RATE);
+}
+
+static ssize_t show_sampling_rate_min(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", MIN_SAMPLING_RATE);
+}
+
+#define define_one_ro(_name)				\
+static struct freq_attr _name =				\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+define_one_ro(sampling_rate_max);
+define_one_ro(sampling_rate_min);
+
+/* cpufreq_lagfree Governor Tunables */
+#define show_one(file_name, object)					\
+static ssize_t show_##file_name						\
+(struct cpufreq_policy *unused, char *buf)				\
+{									\
+	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
+}
+show_one(sampling_rate, sampling_rate);
+show_one(sampling_down_factor, sampling_down_factor);
+show_one(up_threshold, up_threshold);
+show_one(down_threshold, down_threshold);
+show_one(ignore_nice_load, ignore_nice);
+//show_one(freq_step, freq_step);
+
+static ssize_t store_sampling_down_factor(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	if (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.sampling_down_factor = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_sampling_rate(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > MAX_SAMPLING_RATE || input < MIN_SAMPLING_RATE) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.sampling_rate = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_up_threshold(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > 100 || input <= dbs_tuners_ins.down_threshold) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.up_threshold = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_down_threshold(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > 100 || input >= dbs_tuners_ins.up_threshold) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.down_threshold = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_ignore_nice_load(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	unsigned int j;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+
+	mutex_lock(&dbs_mutex);
+	if (input == dbs_tuners_ins.ignore_nice) { /* nothing to do */
+		mutex_unlock(&dbs_mutex);
+		return count;
+	}
+	dbs_tuners_ins.ignore_nice = input;
+
+	/* we need to re-evaluate prev_cpu_idle_up and prev_cpu_idle_down */
+	for_each_online_cpu(j) {
+		struct cpu_dbs_info_s *j_dbs_info;
+		j_dbs_info = &per_cpu(cpu_dbs_info, j);
+		j_dbs_info->prev_cpu_idle_up = get_cpu_idle_time(j);
+		j_dbs_info->prev_cpu_idle_down = j_dbs_info->prev_cpu_idle_up;
+	}
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+/*static ssize_t store_freq_step(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 100)
+		input = 100;
+
+	/ * no need to test here if freq_step is zero as the user might actually
+	 * want this, they would be crazy though :) * /
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.freq_step = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}*/
+
+#define define_one_rw(_name) \
+static struct freq_attr _name = \
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+define_one_rw(sampling_rate);
+define_one_rw(sampling_down_factor);
+define_one_rw(up_threshold);
+define_one_rw(down_threshold);
+define_one_rw(ignore_nice_load);
+//define_one_rw(freq_step);
+
+static struct attribute * dbs_attributes[] = {
+	&sampling_rate_max.attr,
+	&sampling_rate_min.attr,
+	&sampling_rate.attr,
+	&sampling_down_factor.attr,
+	&up_threshold.attr,
+	&down_threshold.attr,
+	&ignore_nice_load.attr,
+	//&freq_step.attr,
+	NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+	.attrs = dbs_attributes,
+	.name = "lagfree",
+};
+
+/************************** sysfs end ************************/
+
+static void dbs_check_cpu(int cpu)
+{
+	unsigned int idle_ticks, up_idle_ticks, down_idle_ticks;
+	unsigned int tmp_idle_ticks, total_idle_ticks;
+	unsigned int freq_target;
+	unsigned int freq_down_sampling_rate;
+	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+	struct cpufreq_policy *policy;
+
+	if (!this_dbs_info->enable)
+		return;
+
+	policy = this_dbs_info->cur_policy;
+
+	/*
+	 * The default safe range is 20% to 80%
+	 * Every sampling_rate, we check
+	 *	- If current idle time is less than 20%, then we try to
+	 *	  increase frequency
+	 * Every sampling_rate*sampling_down_factor, we check
+	 *	- If current idle time is more than 80%, then we try to
+	 *	  decrease frequency
+	 *
+	 * Any frequency increase takes it to the maximum frequency.
+	 * Frequency reduction happens at minimum steps of
+	 * 5% (default) of max_frequency
+	 */
+
+	/* Check for frequency increase */
+	idle_ticks = UINT_MAX;
+
+	/* Check for frequency increase */
+	total_idle_ticks = get_cpu_idle_time(cpu);
+	tmp_idle_ticks = total_idle_ticks -
+		this_dbs_info->prev_cpu_idle_up;
+	this_dbs_info->prev_cpu_idle_up = total_idle_ticks;
+
+	if (tmp_idle_ticks < idle_ticks)
+		idle_ticks = tmp_idle_ticks;
+
+	/* Scale idle ticks by 100 and compare with up and down ticks */
+	idle_ticks *= 100;
+	up_idle_ticks = (100 - dbs_tuners_ins.up_threshold) *
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+
+	if (idle_ticks < up_idle_ticks) {
+		this_dbs_info->down_skip = 0;
+		this_dbs_info->prev_cpu_idle_down =
+			this_dbs_info->prev_cpu_idle_up;
+
+		/* if we are already at full speed then break out early */
+		if (this_dbs_info->requested_freq == policy->max && !suspended)
+			return;
+
+		//freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
+		if (suspended)
+			freq_target = (FREQ_STEP_UP_SLEEP_PERCENT * policy->max) / 100;
+		else
+			freq_target = policy->max;
+
+		/* max freq cannot be less than 100. But who knows.... */
+		if (unlikely(freq_target == 0))
+			freq_target = 5;
+
+		this_dbs_info->requested_freq += freq_target;
+		if (this_dbs_info->requested_freq > policy->max)
+			this_dbs_info->requested_freq = policy->max;
+		
+		//Screen off mode
+		if (suspended && this_dbs_info->requested_freq > FREQ_SLEEP_MAX)
+		    this_dbs_info->requested_freq = FREQ_SLEEP_MAX;
+		    
+		//Screen off mode
+		if (!suspended && this_dbs_info->requested_freq < FREQ_AWAKE_MIN)
+		    this_dbs_info->requested_freq = FREQ_AWAKE_MIN;
+
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+			CPUFREQ_RELATION_H);
+		return;
+	}
+
+	/* Check for frequency decrease */
+	this_dbs_info->down_skip++;
+	if (this_dbs_info->down_skip < dbs_tuners_ins.sampling_down_factor)
+		return;
+
+	/* Check for frequency decrease */
+	total_idle_ticks = this_dbs_info->prev_cpu_idle_up;
+	tmp_idle_ticks = total_idle_ticks -
+		this_dbs_info->prev_cpu_idle_down;
+	this_dbs_info->prev_cpu_idle_down = total_idle_ticks;
+
+	if (tmp_idle_ticks < idle_ticks)
+		idle_ticks = tmp_idle_ticks;
+
+	/* Scale idle ticks by 100 and compare with up and down ticks */
+	idle_ticks *= 100;
+	this_dbs_info->down_skip = 0;
+
+	freq_down_sampling_rate = dbs_tuners_ins.sampling_rate *
+		dbs_tuners_ins.sampling_down_factor;
+	down_idle_ticks = (100 - dbs_tuners_ins.down_threshold) *
+		usecs_to_jiffies(freq_down_sampling_rate);
+
+	if (idle_ticks > down_idle_ticks) {
+		/*
+		 * if we are already at the lowest speed then break out early
+		 * or if we 'cannot' reduce the speed as the user might want
+		 * freq_target to be zero
+		 */
+		if (this_dbs_info->requested_freq == policy->min && suspended
+				/*|| dbs_tuners_ins.freq_step == 0*/)
+			return;
+
+		//freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
+		freq_target = FREQ_STEP_DOWN; //policy->max;
+
+		/* max freq cannot be less than 100. But who knows.... */
+		if (unlikely(freq_target == 0))
+			freq_target = 5;
+
+		// prevent going under 0
+		if(freq_target > this_dbs_info->requested_freq)
+			this_dbs_info->requested_freq = policy->min;
+		else
+			this_dbs_info->requested_freq -= freq_target;
+		
+		if (this_dbs_info->requested_freq < policy->min)
+			this_dbs_info->requested_freq = policy->min;
+			
+		//Screen on mode
+		if (!suspended && this_dbs_info->requested_freq < FREQ_AWAKE_MIN)
+		    this_dbs_info->requested_freq = FREQ_AWAKE_MIN;
+		
+		//Screen off mode
+		if (suspended && this_dbs_info->requested_freq > FREQ_SLEEP_MAX)
+		    this_dbs_info->requested_freq = FREQ_SLEEP_MAX;
+
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+				CPUFREQ_RELATION_H);
+		return;
+	}
+}
+
+static void do_dbs_timer(struct work_struct *work)
+{
+	int i;
+	mutex_lock(&dbs_mutex);
+	for_each_online_cpu(i)
+		dbs_check_cpu(i);
+	schedule_delayed_work(&dbs_work,
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate));
+	mutex_unlock(&dbs_mutex);
+}
+
+static inline void dbs_timer_init(void)
+{
+	init_timer_deferrable(&dbs_work.timer);
+	schedule_delayed_work(&dbs_work,
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate));
+	return;
+}
+
+static inline void dbs_timer_exit(void)
+{
+	cancel_delayed_work(&dbs_work);
+	return;
+}
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				   unsigned int event)
+{
+	unsigned int cpu = policy->cpu;
+	struct cpu_dbs_info_s *this_dbs_info;
+	unsigned int j;
+	int rc;
+
+	this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!policy->cur))
+			return -EINVAL;
+
+		if (this_dbs_info->enable) /* Already enabled */
+			break;
+
+		mutex_lock(&dbs_mutex);
+
+		rc = sysfs_create_group(&policy->kobj, &dbs_attr_group);
+		if (rc) {
+			mutex_unlock(&dbs_mutex);
+			return rc;
+		}
+
+		for_each_cpu(j, policy->cpus) {
+			struct cpu_dbs_info_s *j_dbs_info;
+			j_dbs_info = &per_cpu(cpu_dbs_info, j);
+			j_dbs_info->cur_policy = policy;
+
+			j_dbs_info->prev_cpu_idle_up = get_cpu_idle_time(cpu);
+			j_dbs_info->prev_cpu_idle_down
+				= j_dbs_info->prev_cpu_idle_up;
+		}
+		this_dbs_info->enable = 1;
+		this_dbs_info->down_skip = 0;
+		this_dbs_info->requested_freq = policy->cur;
+
+		dbs_enable++;
+		/*
+		 * Start the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 1) {
+			unsigned int latency;
+			/* policy latency is in nS. Convert it to uS first */
+			latency = policy->cpuinfo.transition_latency / 1000;
+			if (latency == 0)
+				latency = 1;
+
+			def_sampling_rate = 10 * latency *
+				1000;
+
+			if (def_sampling_rate < MIN_STAT_SAMPLING_RATE)
+				def_sampling_rate = MIN_STAT_SAMPLING_RATE;
+
+			dbs_tuners_ins.sampling_rate = def_sampling_rate;
+
+			dbs_timer_init();
+			cpufreq_register_notifier(
+					&dbs_cpufreq_notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+		mutex_unlock(&dbs_mutex);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		mutex_lock(&dbs_mutex);
+		this_dbs_info->enable = 0;
+		sysfs_remove_group(&policy->kobj, &dbs_attr_group);
+		dbs_enable--;
+		/*
+		 * Stop the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 0) {
+			dbs_timer_exit();
+			cpufreq_unregister_notifier(
+					&dbs_cpufreq_notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+		mutex_unlock(&dbs_mutex);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		mutex_lock(&dbs_mutex);
+		if (policy->max < this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->min, CPUFREQ_RELATION_L);
+		mutex_unlock(&dbs_mutex);
+		break;
+	}
+	return 0;
+}
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE
+static
+#endif
+struct cpufreq_governor cpufreq_gov_lagfree = {
+	.name			= "lagfree",
+	.governor		= cpufreq_governor_dbs,
+	.max_transition_latency	= TRANSITION_LATENCY_LIMIT,
+	.owner			= THIS_MODULE,
+};
+
+static void lagfree_early_suspend(struct early_suspend *handler) {
+	suspended = 1;
+}
+
+static void lagfree_late_resume(struct early_suspend *handler) {
+	suspended = 0;
+}
+
+static struct early_suspend lagfree_power_suspend = {
+	.suspend = lagfree_early_suspend,
+	.resume = lagfree_late_resume,
+	.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 1,
+};
+
+static int __init cpufreq_gov_dbs_init(void)
+{
+	register_early_suspend(&lagfree_power_suspend);
+	return cpufreq_register_governor(&cpufreq_gov_lagfree);
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+	/* Make sure that the scheduled work is indeed not running */
+	flush_scheduled_work();
+
+	unregister_early_suspend(&lagfree_power_suspend);
+	cpufreq_unregister_governor(&cpufreq_gov_lagfree);
+}
+
+
+MODULE_AUTHOR ("Emilio Lpez <turl@tuxfamily.org>");
+MODULE_DESCRIPTION ("'cpufreq_lagfree' - A dynamic cpufreq governor for "
+		"Low Latency Frequency Transition capable processors "
+		"optimised for use in a battery environment"
+		"Based on conservative by Alexander Clouter");
+MODULE_LICENSE ("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif
+module_exit(cpufreq_gov_dbs_exit);
diff --git a/Kernel/drivers/cpufreq/cpufreq_savagedzen.c b/Kernel/drivers/cpufreq/cpufreq_savagedzen.c
new file mode 100644
index 0000000..594a03c
--- /dev/null
+++ b/Kernel/drivers/cpufreq/cpufreq_savagedzen.c
@@ -0,0 +1,751 @@
+/*
+ * drivers/cpufreq/cpufreq_savagedzen.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Joshua Seidel
+
+ * Based on the smartass governor by Erasmux
+ *
+ * Based on the interactive governor By Mike Chan (mike@android.com)
+ * which was adaptated to 2.6.29 kernel by Nadlabak (pavel@doshaska.net)
+ *
+ * requires to add
+ * EXPORT_SYMBOL_GPL(nr_running);
+ * at the end of kernel/sched.c
+ *
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <asm/cputime.h>
+#include <linux/earlysuspend.h>
+
+static void (*pm_idle_old)(void);
+static atomic_t active_count = ATOMIC_INIT(0);
+
+struct savagedzen_info_s {
+        struct cpufreq_policy *cur_policy;
+        struct timer_list timer;
+        u64 time_in_idle;
+        u64 idle_exit_time;
+        u64 freq_change_time;
+        u64 freq_change_time_in_idle;
+        int cur_cpu_load;
+        unsigned int force_ramp_up;
+        unsigned int enable;
+        int max_speed;
+        int min_speed;
+};
+static DEFINE_PER_CPU(struct savagedzen_info_s, savagedzen_info);
+
+/* Workqueues handle frequency scaling */
+static struct workqueue_struct *up_wq;
+static struct workqueue_struct *down_wq;
+static struct work_struct freq_scale_work;
+
+static cpumask_t work_cpumask;
+static unsigned int suspended;
+
+enum {
+        SAVAGEDZEN_DEBUG_JUMPS=1,
+        SAVAGEDZEN_DEBUG_LOAD=2
+};
+
+/*
+ * Combination of the above debug flags.
+ */
+static unsigned long debug_mask;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp up.
+ */
+#define DEFAULT_UP_RATE_US 12000;
+static unsigned long up_rate_us;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp down.
+ */
+#define DEFAULT_DOWN_RATE_US 24000;
+static unsigned long down_rate_us;
+
+/*
+ * When ramping up frequency with no idle cycles jump to at least this frequency.
+ * Zero disables. Set a very high value to jump to policy max freqeuncy.
+ */
+#define DEFAULT_UP_MIN_FREQ 0
+static unsigned int up_min_freq;
+
+/*
+ * When sleep_max_freq>0 the frequency when suspended will be capped
+ * by this frequency. Also will wake up at max frequency of policy
+ * to minimize wakeup issues.
+ * Set sleep_max_freq=0 to disable this behavior.
+ */
+#define DEFAULT_SLEEP_MAX_FREQ 500000
+static unsigned int sleep_max_freq;
+
+/*
+ * The frequency to set when waking up from sleep.
+ * When sleep_max_freq=0 this will have no effect.
+ */
+#define DEFAULT_SLEEP_WAKEUP_FREQ 800000
+static unsigned int sleep_wakeup_freq;
+
+/*
+ * When awake_min_freq>0 the frequency when not suspended will not
+ * go below this frequency.
+ * Set awake_min_freq=0 to disable this behavior.
+ */
+#define DEFAULT_AWAKE_MIN_FREQ 200000
+static unsigned int awake_min_freq;
+
+/*
+ * Sampling rate, I highly recommend to leave it at 2.
+ */
+#define DEFAULT_SAMPLE_RATE_JIFFIES 2
+static unsigned int sample_rate_jiffies;
+
+/*
+ * Freqeuncy delta when ramping up.
+ * zero disables and causes to always jump straight to max frequency.
+ */
+#define DEFAULT_RAMP_UP_STEP 600000
+static unsigned int ramp_up_step;
+
+/*
+ * Freqeuncy delta when ramping down.
+ * zero disables and will calculate ramp down according to load heuristic.
+ */
+#define DEFAULT_RAMP_DOWN_STEP 0
+static unsigned int ramp_down_step;
+
+/*
+ * CPU freq will be increased if measured load > max_cpu_load;
+ */
+#define DEFAULT_MAX_CPU_LOAD 65
+static unsigned long max_cpu_load;
+
+/*
+ * CPU freq will be decreased if measured load < min_cpu_load;
+ */
+#define DEFAULT_MIN_CPU_LOAD 50
+static unsigned long min_cpu_load;
+
+
+static int cpufreq_governor_savagedzen(struct cpufreq_policy *policy,
+                unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_SAVAGEDZEN
+static
+#endif
+struct cpufreq_governor cpufreq_gov_savagedzen = {
+        .name = "SavagedZen",
+        .governor = cpufreq_governor_savagedzen,
+        .max_transition_latency = 9000000,
+        .owner = THIS_MODULE,
+};
+
+static void savagedzen_update_min_max(struct savagedzen_info_s *this_savagedzen, struct cpufreq_policy *policy, int suspend) {
+        if (suspend) {
+                this_savagedzen->min_speed = policy->min;
+                this_savagedzen->max_speed = // sleep_max_freq; but make sure it obeys the policy min/max
+                        policy->max > sleep_max_freq ? (sleep_max_freq > policy->min ? sleep_max_freq : policy->min) : policy->max;
+        } else {
+                this_savagedzen->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
+                        policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
+                this_savagedzen->max_speed = policy->max;
+        }
+}
+
+inline static unsigned int validate_freq(struct savagedzen_info_s *this_savagedzen, int freq) {
+        if (freq > this_savagedzen->max_speed)
+                return this_savagedzen->max_speed;
+        if (freq < this_savagedzen->min_speed)
+                return this_savagedzen->min_speed;
+        return freq;
+}
+
+static void reset_timer(unsigned long cpu, struct savagedzen_info_s *this_savagedzen) {
+  this_savagedzen->time_in_idle = get_cpu_idle_time_us(cpu, &this_savagedzen->idle_exit_time);
+  mod_timer(&this_savagedzen->timer, jiffies + sample_rate_jiffies);
+}
+
+static void cpufreq_savagedzen_timer(unsigned long data)
+{
+        u64 delta_idle;
+        u64 delta_time;
+        int cpu_load;
+        u64 update_time;
+        u64 now_idle;
+        struct savagedzen_info_s *this_savagedzen = &per_cpu(savagedzen_info, data);
+        struct cpufreq_policy *policy = this_savagedzen->cur_policy;
+
+        now_idle = get_cpu_idle_time_us(data, &update_time);
+
+        if (this_savagedzen->idle_exit_time == 0 || update_time == this_savagedzen->idle_exit_time)
+                return;
+
+        delta_idle = cputime64_sub(now_idle, this_savagedzen->time_in_idle);
+        delta_time = cputime64_sub(update_time, this_savagedzen->idle_exit_time);
+        //printk(KERN_INFO "savagedzenT: t=%llu i=%llu\n",cputime64_sub(update_time,this_savagedzen->idle_exit_time),delta_idle);
+
+        // If timer ran less than 1ms after short-term sample started, retry.
+        if (delta_time < 1000) {
+                if (!timer_pending(&this_savagedzen->timer))
+                        reset_timer(data,this_savagedzen);
+                return;
+        }
+
+        if (delta_idle > delta_time)
+                cpu_load = 0;
+        else
+                cpu_load = 100 * (unsigned int)(delta_time - delta_idle) / (unsigned int)delta_time;
+
+        if (debug_mask & SAVAGEDZEN_DEBUG_LOAD)
+                printk(KERN_INFO "savagedzenT @ %d: load %d (delta_time %llu)\n",policy->cur,cpu_load,delta_time);
+
+        this_savagedzen->cur_cpu_load = cpu_load;
+
+        // Scale up if load is above max or if there where no idle cycles since coming out of idle.
+        if (cpu_load > max_cpu_load || delta_idle == 0) {
+                if (policy->cur == policy->max)
+                        return;
+
+                if (nr_running() < 1)
+                        return;
+
+                if (cputime64_sub(update_time, this_savagedzen->freq_change_time) < up_rate_us)
+                        return;
+
+
+                this_savagedzen->force_ramp_up = 1;
+                cpumask_set_cpu(data, &work_cpumask);
+                queue_work(up_wq, &freq_scale_work);
+                return;
+        }
+
+        /*
+         * There is a window where if the cpu utlization can go from low to high
+         * between the timer expiring, delta_idle will be > 0 and the cpu will
+         * be 100% busy, preventing idle from running, and this timer from
+         * firing. So setup another timer to fire to check cpu utlization.
+         * Do not setup the timer if there is no scheduled work or if at max speed.
+         */
+        if (policy->cur < this_savagedzen->max_speed && !timer_pending(&this_savagedzen->timer) && nr_running() > 0)
+                reset_timer(data,this_savagedzen);
+
+        if (policy->cur == policy->min)
+                return;
+
+        /*
+         * Do not scale down unless we have been at this frequency for the
+         * minimum sample time.
+         */
+        if (cputime64_sub(update_time, this_savagedzen->freq_change_time) < down_rate_us)
+                return;
+
+        cpumask_set_cpu(data, &work_cpumask);
+        queue_work(down_wq, &freq_scale_work);
+}
+
+static void cpufreq_idle(void)
+{
+        struct savagedzen_info_s *this_savagedzen = &per_cpu(savagedzen_info, smp_processor_id());
+        struct cpufreq_policy *policy = this_savagedzen->cur_policy;
+
+        if (!this_savagedzen->enable) {
+                pm_idle_old();
+                return;
+        }
+
+        if (policy->cur == this_savagedzen->min_speed && timer_pending(&this_savagedzen->timer))
+                del_timer(&this_savagedzen->timer);
+
+        pm_idle_old();
+
+        if (!timer_pending(&this_savagedzen->timer))
+                reset_timer(smp_processor_id(), this_savagedzen);
+}
+
+/* We use the same work function to sale up and down */
+static void cpufreq_savagedzen_freq_change_time_work(struct work_struct *work)
+{
+        unsigned int cpu;
+        int new_freq;
+        unsigned int force_ramp_up;
+        int cpu_load;
+        struct savagedzen_info_s *this_savagedzen;
+        struct cpufreq_policy *policy;
+        unsigned int relation = CPUFREQ_RELATION_L;
+        cpumask_t tmp_mask = work_cpumask;
+        for_each_cpu(cpu, &tmp_mask) {
+                this_savagedzen = &per_cpu(savagedzen_info, cpu);
+                policy = this_savagedzen->cur_policy;
+                cpu_load = this_savagedzen->cur_cpu_load;
+                force_ramp_up = this_savagedzen->force_ramp_up && nr_running() > 1;
+                this_savagedzen->force_ramp_up = 0;
+
+                if (force_ramp_up || cpu_load > max_cpu_load) {
+                        if (force_ramp_up && up_min_freq) {
+                                new_freq = up_min_freq;
+                                relation = CPUFREQ_RELATION_L;
+                        } else if (ramp_up_step) {
+                                new_freq = policy->cur + ramp_up_step;
+                                relation = CPUFREQ_RELATION_H;
+                        } else {
+                                new_freq = this_savagedzen->max_speed;
+                                relation = CPUFREQ_RELATION_H;
+                        }
+                }
+                else if (cpu_load < min_cpu_load) {
+                        if (ramp_down_step)
+                                new_freq = policy->cur - ramp_down_step;
+                        else {
+                                cpu_load += 100 - max_cpu_load; // dummy load.
+                                new_freq = policy->cur * cpu_load / 100;
+                        }
+                        relation = CPUFREQ_RELATION_L;
+                }
+                else new_freq = policy->cur;
+
+                new_freq = validate_freq(this_savagedzen,new_freq);
+
+                if (new_freq != policy->cur) {
+                        if (debug_mask & SAVAGEDZEN_DEBUG_JUMPS)
+                                printk(KERN_INFO "savagedzenQ: jumping from %d to %d\n",policy->cur,new_freq);
+
+                        __cpufreq_driver_target(policy, new_freq, relation);
+
+                        this_savagedzen->freq_change_time_in_idle =
+                                get_cpu_idle_time_us(cpu,&this_savagedzen->freq_change_time);
+                }
+
+                cpumask_clear_cpu(cpu, &work_cpumask);
+        }
+}
+
+static ssize_t show_debug_mask(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%lu\n", debug_mask);
+}
+
+static ssize_t store_debug_mask(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0)
+          debug_mask = input;
+        return res;
+}
+
+static struct freq_attr debug_mask_attr = __ATTR(debug_mask, 0644,
+                show_debug_mask, store_debug_mask);
+
+static ssize_t show_up_rate_us(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%lu\n", up_rate_us);
+}
+
+static ssize_t store_up_rate_us(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0 && input <= 100000000)
+          up_rate_us = input;
+        return res;
+}
+
+static struct freq_attr up_rate_us_attr = __ATTR(up_rate_us, 0644,
+                show_up_rate_us, store_up_rate_us);
+
+static ssize_t show_down_rate_us(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%lu\n", down_rate_us);
+}
+
+static ssize_t store_down_rate_us(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0 && input <= 100000000)
+          down_rate_us = input;
+        return res;
+}
+
+static struct freq_attr down_rate_us_attr = __ATTR(down_rate_us, 0644,
+                show_down_rate_us, store_down_rate_us);
+
+static ssize_t show_up_min_freq(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", up_min_freq);
+}
+
+static ssize_t store_up_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          up_min_freq = input;
+        return res;
+}
+
+static struct freq_attr up_min_freq_attr = __ATTR(up_min_freq, 0644,
+                show_up_min_freq, store_up_min_freq);
+
+static ssize_t show_sleep_max_freq(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", sleep_max_freq);
+}
+
+static ssize_t store_sleep_max_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          sleep_max_freq = input;
+        return res;
+}
+
+static struct freq_attr sleep_max_freq_attr = __ATTR(sleep_max_freq, 0644,
+                show_sleep_max_freq, store_sleep_max_freq);
+
+static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", sleep_wakeup_freq);
+}
+
+static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          sleep_wakeup_freq = input;
+        return res;
+}
+
+static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
+                show_sleep_wakeup_freq, store_sleep_wakeup_freq);
+
+static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", awake_min_freq);
+}
+
+static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          awake_min_freq = input;
+        return res;
+}
+
+static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
+                show_awake_min_freq, store_awake_min_freq);
+
+static ssize_t show_sample_rate_jiffies(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", sample_rate_jiffies);
+}
+
+static ssize_t store_sample_rate_jiffies(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input > 0 && input <= 1000)
+          sample_rate_jiffies = input;
+        return res;
+}
+
+static struct freq_attr sample_rate_jiffies_attr = __ATTR(sample_rate_jiffies, 0644,
+                show_sample_rate_jiffies, store_sample_rate_jiffies);
+
+static ssize_t show_ramp_up_step(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", ramp_up_step);
+}
+
+static ssize_t store_ramp_up_step(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          ramp_up_step = input;
+        return res;
+}
+
+static struct freq_attr ramp_up_step_attr = __ATTR(ramp_up_step, 0644,
+                show_ramp_up_step, store_ramp_up_step);
+
+static ssize_t show_ramp_down_step(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%u\n", ramp_down_step);
+}
+
+static ssize_t store_ramp_down_step(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input >= 0)
+          ramp_down_step = input;
+        return res;
+}
+
+static struct freq_attr ramp_down_step_attr = __ATTR(ramp_down_step, 0644,
+                show_ramp_down_step, store_ramp_down_step);
+
+static ssize_t show_max_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%lu\n", max_cpu_load);
+}
+
+static ssize_t store_max_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input > 0 && input <= 100)
+          max_cpu_load = input;
+        return res;
+}
+
+static struct freq_attr max_cpu_load_attr = __ATTR(max_cpu_load, 0644,
+                show_max_cpu_load, store_max_cpu_load);
+
+static ssize_t show_min_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+        return sprintf(buf, "%lu\n", min_cpu_load);
+}
+
+static ssize_t store_min_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+        unsigned long input;
+        res = strict_strtoul(buf, 0, &input);
+        if (res >= 0 && input > 0 && input < 100)
+          min_cpu_load = input;
+        return res;
+}
+
+static struct freq_attr min_cpu_load_attr = __ATTR(min_cpu_load, 0644,
+                show_min_cpu_load, store_min_cpu_load);
+
+static struct attribute * savagedzen_attributes[] = {
+        &debug_mask_attr.attr,
+        &up_rate_us_attr.attr,
+        &down_rate_us_attr.attr,
+        &up_min_freq_attr.attr,
+        &sleep_max_freq_attr.attr,
+        &sleep_wakeup_freq_attr.attr,
+        &awake_min_freq_attr.attr,
+        &sample_rate_jiffies_attr.attr,
+        &ramp_up_step_attr.attr,
+        &ramp_down_step_attr.attr,
+        &max_cpu_load_attr.attr,
+        &min_cpu_load_attr.attr,
+        NULL,
+};
+
+static struct attribute_group savagedzen_attr_group = {
+        .attrs = savagedzen_attributes,
+        .name = "savagedzen",
+};
+
+static int cpufreq_governor_savagedzen(struct cpufreq_policy *new_policy,
+                unsigned int event)
+{
+        unsigned int cpu = new_policy->cpu;
+        int rc;
+        struct savagedzen_info_s *this_savagedzen = &per_cpu(savagedzen_info, cpu);
+
+        switch (event) {
+        case CPUFREQ_GOV_START:
+                if ((!cpu_online(cpu)) || (!new_policy->cur))
+                        return -EINVAL;
+
+                /*
+                 * Do not register the idle hook and create sysfs
+                 * entries if we have already done so.
+                 */
+                if (atomic_inc_return(&active_count) <= 1) {
+                        rc = sysfs_create_group(&new_policy->kobj, &savagedzen_attr_group);
+                        if (rc)
+                                return rc;
+                        pm_idle_old = pm_idle;
+                        pm_idle = cpufreq_idle;
+                }
+
+                this_savagedzen->cur_policy = new_policy;
+                this_savagedzen->enable = 1;
+
+                // notice no break here!
+
+        case CPUFREQ_GOV_LIMITS:
+                savagedzen_update_min_max(this_savagedzen,new_policy,suspended);
+                if (this_savagedzen->cur_policy->cur != this_savagedzen->max_speed) {
+                        if (debug_mask & SAVAGEDZEN_DEBUG_JUMPS)
+                                printk(KERN_INFO "savagedzenI: initializing to %d\n",this_savagedzen->max_speed);
+                        __cpufreq_driver_target(new_policy, this_savagedzen->max_speed, CPUFREQ_RELATION_H);
+                }
+                break;
+
+        case CPUFREQ_GOV_STOP:
+                del_timer(&this_savagedzen->timer);
+                this_savagedzen->enable = 0;
+
+                if (atomic_dec_return(&active_count) > 1)
+                        return 0;
+                sysfs_remove_group(&new_policy->kobj,
+                                &savagedzen_attr_group);
+
+                pm_idle = pm_idle_old;
+                break;
+        }
+
+        return 0;
+}
+
+static void savagedzen_suspend(int cpu, int suspend)
+{
+        struct savagedzen_info_s *this_savagedzen = &per_cpu(savagedzen_info, smp_processor_id());
+        struct cpufreq_policy *policy = this_savagedzen->cur_policy;
+        unsigned int new_freq;
+
+        if (!this_savagedzen->enable || sleep_max_freq==0) // disable behavior for sleep_max_freq==0
+                return;
+
+        savagedzen_update_min_max(this_savagedzen,policy,suspend);
+        if (suspend) {
+            if (policy->cur > this_savagedzen->max_speed) {
+                    new_freq = this_savagedzen->max_speed;
+
+                    if (debug_mask & SAVAGEDZEN_DEBUG_JUMPS)
+                            printk(KERN_INFO "savagedzenS: suspending at %d\n",new_freq);
+
+                    __cpufreq_driver_target(policy, new_freq,
+                                            CPUFREQ_RELATION_H);
+            }
+        } else { // resume at max speed:
+                new_freq = validate_freq(this_savagedzen,sleep_wakeup_freq);
+
+                if (debug_mask & SAVAGEDZEN_DEBUG_JUMPS)
+                        printk(KERN_INFO "savagedzenS: awaking at %d\n",new_freq);
+
+                __cpufreq_driver_target(policy, new_freq,
+                                        CPUFREQ_RELATION_L);
+        }
+}
+
+static void savagedzen_early_suspend(struct early_suspend *handler) {
+        int i;
+        suspended = 1;
+        for_each_online_cpu(i)
+                savagedzen_suspend(i,1);
+}
+
+static void savagedzen_late_resume(struct early_suspend *handler) {
+        int i;
+        suspended = 0;
+        for_each_online_cpu(i)
+                savagedzen_suspend(i,0);
+}
+
+static struct early_suspend savagedzen_power_suspend = {
+        .suspend = savagedzen_early_suspend,
+        .resume = savagedzen_late_resume,
+};
+
+static int __init cpufreq_savagedzen_init(void)
+{
+        unsigned int i;
+        struct savagedzen_info_s *this_savagedzen;
+        debug_mask = 0;
+        up_rate_us = DEFAULT_UP_RATE_US;
+        down_rate_us = DEFAULT_DOWN_RATE_US;
+        up_min_freq = DEFAULT_UP_MIN_FREQ;
+        sleep_max_freq = DEFAULT_SLEEP_MAX_FREQ;
+        sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
+        awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
+        sample_rate_jiffies = DEFAULT_SAMPLE_RATE_JIFFIES;
+        ramp_up_step = DEFAULT_RAMP_UP_STEP;
+        ramp_down_step = DEFAULT_RAMP_DOWN_STEP;
+        max_cpu_load = DEFAULT_MAX_CPU_LOAD;
+        min_cpu_load = DEFAULT_MIN_CPU_LOAD;
+
+        suspended = 0;
+
+        /* Initalize per-cpu data: */
+        for_each_possible_cpu(i) {
+                this_savagedzen = &per_cpu(savagedzen_info, i);
+                this_savagedzen->enable = 0;
+                this_savagedzen->cur_policy = 0;
+                this_savagedzen->force_ramp_up = 0;
+                this_savagedzen->max_speed = DEFAULT_SLEEP_WAKEUP_FREQ;
+                this_savagedzen->min_speed = DEFAULT_AWAKE_MIN_FREQ;
+                this_savagedzen->time_in_idle = 0;
+                this_savagedzen->idle_exit_time = 0;
+                this_savagedzen->freq_change_time = 0;
+                this_savagedzen->freq_change_time_in_idle = 0;
+                this_savagedzen->cur_cpu_load = 0;
+                // intialize timer:
+                init_timer_deferrable(&this_savagedzen->timer);
+                this_savagedzen->timer.function = cpufreq_savagedzen_timer;
+                this_savagedzen->timer.data = i;
+        }
+
+        /* Scale up is high priority */
+        up_wq = create_workqueue("ksavagedzen_up");
+        down_wq = create_workqueue("ksavagedzen_down");
+
+        INIT_WORK(&freq_scale_work, cpufreq_savagedzen_freq_change_time_work);
+
+        register_early_suspend(&savagedzen_power_suspend);
+
+        return cpufreq_register_governor(&cpufreq_gov_savagedzen);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_savagedzen
+pure_initcall(cpufreq_savagedzen_init);
+#else
+module_init(cpufreq_savagedzen_init);
+#endif
+
+static void __exit cpufreq_savagedzen_exit(void)
+{
+        cpufreq_unregister_governor(&cpufreq_gov_savagedzen);
+        destroy_workqueue(up_wq);
+        destroy_workqueue(down_wq);
+}
+
+module_exit(cpufreq_savagedzen_exit);
+
+MODULE_AUTHOR ("jsseidel");
+MODULE_DESCRIPTION ("'cpufreq_savagedzen' - A badass cpufreq governor! Based on Smartass");
+MODULE_LICENSE ("GPL");
+
diff --git a/Kernel/drivers/cpufreq/cpufreq_smoothass.c b/Kernel/drivers/cpufreq/cpufreq_smoothass.c
new file mode 100644
index 0000000..1e3dce7
--- /dev/null
+++ b/Kernel/drivers/cpufreq/cpufreq_smoothass.c
@@ -0,0 +1,625 @@
+/*
+* drivers/cpufreq/cpufreq_smoothass.c
+*
+* Copyright (C) 2010 Google, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* Author: Erasmux
+*
+* Based on the interactive governor By Mike Chan (mike@android.com)
+* which was adaptated to 2.6.29 kernel by Nadlabak (pavel@doshaska.net)
+*
+* requires to add
+* EXPORT_SYMBOL_GPL(nr_running);
+* at the end of kernel/sched.c
+*
+*/
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <asm/cputime.h>
+#include <linux/earlysuspend.h>
+
+static void (*pm_idle_old)(void);
+static atomic_t active_count = ATOMIC_INIT(0);
+
+struct smoothass_info_s {
+struct cpufreq_policy *cur_policy;
+struct timer_list timer;
+u64 time_in_idle;
+u64 idle_exit_time;
+unsigned int force_ramp_up;
+unsigned int enable;
+};
+static DEFINE_PER_CPU(struct smoothass_info_s, smoothass_info);
+
+/* Workqueues handle frequency scaling */
+static struct workqueue_struct *up_wq;
+static struct workqueue_struct *down_wq;
+static struct work_struct freq_scale_work;
+
+static u64 freq_change_time;
+static u64 freq_change_time_in_idle;
+
+static cpumask_t work_cpumask;
+static unsigned int suspended;
+
+/*
+* The minimum amount of time to spend at a frequency before we can ramp down,
+* default is 45ms.
+*/
+#define DEFAULT_DOWN_RATE_US 45000
+static unsigned long down_rate_us;
+
+/*
+* When ramping up frequency with no idle cycles jump to at least this frequency.
+* Zero disables. Set a very high value to jump to policy max freqeuncy.
+*/
+#define DEFAULT_UP_MIN_FREQ 1036800
+static unsigned int up_min_freq;
+
+/*
+* When sleep_max_freq>0 the frequency when suspended will be capped
+* by this frequency. Also will wake up at max frequency of policy
+* to minimize wakeup issues.
+* Set sleep_max_freq=0 to disable this behavior.
+*/
+#define DEFAULT_SLEEP_MAX_FREQ 499200
+static unsigned int sleep_max_freq;
+
+/*
+* Sampling rate, I highly recommend to leave it at 2.
+*/
+#define DEFAULT_SAMPLE_RATE_JIFFIES 2
+static unsigned int sample_rate_jiffies;
+
+/*
+* Freqeuncy delta when ramping up.
+* zero disables causes to always jump straight to max frequency.
+*/
+#define DEFAULT_RAMP_UP_STEP 576000
+static unsigned int ramp_up_step;
+
+/*
+* Max freqeuncy delta when ramping down. zero disables.
+*/
+#define DEFAULT_MAX_RAMP_DOWN 384000
+static unsigned int max_ramp_down;
+
+/*
+* CPU freq will be increased if measured load > max_cpu_load;
+*/
+#define DEFAULT_MAX_CPU_LOAD 70
+static unsigned long max_cpu_load;
+
+/*
+* CPU freq will be decreased if measured load < min_cpu_load;
+*/
+#define DEFAULT_MIN_CPU_LOAD 35
+static unsigned long min_cpu_load;
+
+
+static int cpufreq_governor_smoothass(struct cpufreq_policy *policy,
+unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_SMOOTHASS
+static
+#endif
+struct cpufreq_governor cpufreq_gov_smoothass = {
+.name = "smoothass",
+.governor = cpufreq_governor_smoothass,
+.max_transition_latency = 6000000,
+.owner = THIS_MODULE,
+};
+
+static void cpufreq_smoothass_timer(unsigned long data)
+{
+u64 delta_idle;
+u64 update_time;
+u64 now_idle;
+struct smoothass_info_s *this_smoothass = &per_cpu(smoothass_info, data);
+struct cpufreq_policy *policy = this_smoothass->cur_policy;
+
+now_idle = get_cpu_idle_time_us(data, &update_time);
+
+if (update_time == this_smoothass->idle_exit_time)
+return;
+
+delta_idle = cputime64_sub(now_idle, this_smoothass->time_in_idle);
+//printk(KERN_INFO "smoothass: t=%llu i=%llu\n",cputime64_sub(update_time,this_smoothass->idle_exit_time),delta_idle);
+
+/* Scale up if there were no idle cycles since coming out of idle */
+if (delta_idle == 0) {
+if (policy->cur == policy->max)
+return;
+
+if (nr_running() < 1)
+return;
+
+this_smoothass->force_ramp_up = 1;
+cpumask_set_cpu(data, &work_cpumask);
+queue_work(up_wq, &freq_scale_work);
+return;
+}
+
+/*
+* There is a window where if the cpu utlization can go from low to high
+* between the timer expiring, delta_idle will be > 0 and the cpu will
+* be 100% busy, preventing idle from running, and this timer from
+* firing. So setup another timer to fire to check cpu utlization.
+* Do not setup the timer if there is no scheduled work.
+*/
+if (!timer_pending(&this_smoothass->timer) && nr_running() > 0) {
+this_smoothass->time_in_idle = get_cpu_idle_time_us(
+data, &this_smoothass->idle_exit_time);
+mod_timer(&this_smoothass->timer, jiffies + sample_rate_jiffies);
+}
+
+if (policy->cur == policy->min)
+return;
+
+/*
+* Do not scale down unless we have been at this frequency for the
+* minimum sample time.
+*/
+if (cputime64_sub(update_time, freq_change_time) < down_rate_us)
+return;
+
+cpumask_set_cpu(data, &work_cpumask);
+queue_work(down_wq, &freq_scale_work);
+}
+
+static void cpufreq_idle(void)
+{
+struct smoothass_info_s *this_smoothass = &per_cpu(smoothass_info, smp_processor_id());
+struct cpufreq_policy *policy = this_smoothass->cur_policy;
+
+pm_idle_old();
+
+if (!cpumask_test_cpu(smp_processor_id(), policy->cpus))
+return;
+
+/* Timer to fire in 1-2 ticks, jiffie aligned. */
+if (timer_pending(&this_smoothass->timer) == 0) {
+this_smoothass->time_in_idle = get_cpu_idle_time_us(
+smp_processor_id(), &this_smoothass->idle_exit_time);
+mod_timer(&this_smoothass->timer, jiffies + sample_rate_jiffies);
+}
+}
+
+/*
+* Choose the cpu frequency based off the load. For now choose the minimum
+* frequency that will satisfy the load, which is not always the lower power.
+*/
+static unsigned int cpufreq_smoothass_calc_freq(unsigned int cpu, struct cpufreq_policy *policy)
+{
+unsigned int delta_time;
+unsigned int idle_time;
+unsigned int cpu_load;
+unsigned int new_freq;
+u64 current_wall_time;
+u64 current_idle_time;
+
+current_idle_time = get_cpu_idle_time_us(cpu, &current_wall_time);
+
+idle_time = (unsigned int)( current_idle_time - freq_change_time_in_idle );
+delta_time = (unsigned int)( current_wall_time - freq_change_time );
+
+cpu_load = 100 * (delta_time - idle_time) / delta_time;
+//printk(KERN_INFO "Smoothass calc_freq: delta_time=%u cpu_load=%u\n",delta_time,cpu_load);
+if (cpu_load < min_cpu_load) {
+cpu_load += 100 - max_cpu_load; // dummy load.
+new_freq = policy->cur * cpu_load / 100;
+if (max_ramp_down && new_freq < policy->cur - max_ramp_down)
+new_freq = policy->cur - max_ramp_down;
+//printk(KERN_INFO "Smoothass calc_freq: %u => %u\n",policy->cur,new_freq);
+return new_freq;
+} if (cpu_load > max_cpu_load) {
+if (ramp_up_step)
+new_freq = policy->cur + ramp_up_step;
+else
+new_freq = policy->max;
+return new_freq;
+}
+return policy->cur;
+}
+
+/* We use the same work function to sale up and down */
+static void cpufreq_smoothass_freq_change_time_work(struct work_struct *work)
+{
+unsigned int cpu;
+unsigned int new_freq;
+struct smoothass_info_s *this_smoothass;
+struct cpufreq_policy *policy;
+cpumask_t tmp_mask = work_cpumask;
+for_each_cpu(cpu, tmp_mask) {
+this_smoothass = &per_cpu(smoothass_info, cpu);
+policy = this_smoothass->cur_policy;
+
+if (this_smoothass->force_ramp_up) {
+this_smoothass->force_ramp_up = 0;
+
+if (nr_running() == 1) {
+cpumask_clear_cpu(cpu, &work_cpumask);
+return;
+}
+
+if (policy->cur == policy->max)
+return;
+
+if (ramp_up_step)
+new_freq = policy->cur + ramp_up_step;
+else
+new_freq = policy->max;
+
+if (suspended && sleep_max_freq) {
+if (new_freq > sleep_max_freq)
+new_freq = sleep_max_freq;
+} else {
+if (new_freq < up_min_freq)
+new_freq = up_min_freq;
+}
+
+} else {
+new_freq = cpufreq_smoothass_calc_freq(cpu,policy);
+
+// in suspend limit to sleep_max_freq and
+// jump straight to sleep_max_freq to avoid wakeup problems
+if (suspended && sleep_max_freq &&
+(new_freq > sleep_max_freq || new_freq > policy->cur))
+new_freq = sleep_max_freq;
+}
+
+if (new_freq > policy->max)
+new_freq = policy->max;
+
+if (new_freq < policy->min)
+new_freq = policy->min;
+
+__cpufreq_driver_target(policy, new_freq,
+CPUFREQ_RELATION_L);
+
+freq_change_time_in_idle = get_cpu_idle_time_us(cpu,
+&freq_change_time);
+
+cpumask_clear_cpu(cpu, &work_cpumask);
+}
+
+
+}
+
+static ssize_t show_down_rate_us(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%lu\n", down_rate_us);
+}
+
+static ssize_t store_down_rate_us(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input >= 1000 && input <= 100000000)
+down_rate_us = input;
+return res;
+}
+
+static struct freq_attr down_rate_us_attr = __ATTR(down_rate_us, 0644,
+show_down_rate_us, store_down_rate_us);
+
+static ssize_t show_up_min_freq(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%u\n", up_min_freq);
+}
+
+static ssize_t store_up_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input >= 0)
+up_min_freq = input;
+return res;
+}
+
+static struct freq_attr up_min_freq_attr = __ATTR(up_min_freq, 0644,
+show_up_min_freq, store_up_min_freq);
+
+static ssize_t show_sleep_max_freq(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%u\n", sleep_max_freq);
+}
+
+static ssize_t store_sleep_max_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input >= 0)
+sleep_max_freq = input;
+return res;
+}
+
+static struct freq_attr sleep_max_freq_attr = __ATTR(sleep_max_freq, 0644,
+show_sleep_max_freq, store_sleep_max_freq);
+
+static ssize_t show_sample_rate_jiffies(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%u\n", sample_rate_jiffies);
+}
+
+static ssize_t store_sample_rate_jiffies(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input > 0 && input <= 1000)
+sample_rate_jiffies = input;
+return res;
+}
+
+static struct freq_attr sample_rate_jiffies_attr = __ATTR(sample_rate_jiffies, 0644,
+show_sample_rate_jiffies, store_sample_rate_jiffies);
+
+static ssize_t show_ramp_up_step(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%u\n", ramp_up_step);
+}
+
+static ssize_t store_ramp_up_step(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0)
+ramp_up_step = input;
+return res;
+}
+
+static struct freq_attr ramp_up_step_attr = __ATTR(ramp_up_step, 0644,
+show_ramp_up_step, store_ramp_up_step);
+
+static ssize_t show_max_ramp_down(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%u\n", max_ramp_down);
+}
+
+static ssize_t store_max_ramp_down(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0)
+max_ramp_down = input;
+return res;
+}
+
+static struct freq_attr max_ramp_down_attr = __ATTR(max_ramp_down, 0644,
+show_max_ramp_down, store_max_ramp_down);
+
+static ssize_t show_max_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%lu\n", max_cpu_load);
+}
+
+static ssize_t store_max_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input > 0 && input <= 100)
+max_cpu_load = input;
+return res;
+}
+
+static struct freq_attr max_cpu_load_attr = __ATTR(max_cpu_load, 0644,
+show_max_cpu_load, store_max_cpu_load);
+
+static ssize_t show_min_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+return sprintf(buf, "%lu\n", min_cpu_load);
+}
+
+static ssize_t store_min_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+        ssize_t res;
+unsigned long input;
+res = strict_strtoul(buf, 0, &input);
+if (res >= 0 && input > 0 && input < 100)
+min_cpu_load = input;
+return res;
+}
+
+static struct freq_attr min_cpu_load_attr = __ATTR(min_cpu_load, 0644,
+show_min_cpu_load, store_min_cpu_load);
+
+static struct attribute * smoothass_attributes[] = {
+&down_rate_us_attr.attr,
+&up_min_freq_attr.attr,
+&sleep_max_freq_attr.attr,
+&sample_rate_jiffies_attr.attr,
+&ramp_up_step_attr.attr,
+&max_ramp_down_attr.attr,
+&max_cpu_load_attr.attr,
+&min_cpu_load_attr.attr,
+NULL,
+};
+
+static struct attribute_group smoothass_attr_group = {
+.attrs = smoothass_attributes,
+.name = "smoothass",
+};
+
+static int cpufreq_governor_smoothass(struct cpufreq_policy *new_policy,
+unsigned int event)
+{
+unsigned int cpu = new_policy->cpu;
+int rc;
+struct smoothass_info_s *this_smoothass = &per_cpu(smoothass_info, cpu);
+
+switch (event) {
+case CPUFREQ_GOV_START:
+if ((!cpu_online(cpu)) || (!new_policy->cur))
+return -EINVAL;
+
+if (this_smoothass->enable) /* Already enabled */
+break;
+
+/*
+* Do not register the idle hook and create sysfs
+* entries if we have already done so.
+*/
+if (atomic_inc_return(&active_count) > 1)
+return 0;
+
+rc = sysfs_create_group(&new_policy->kobj, &smoothass_attr_group);
+if (rc)
+return rc;
+pm_idle_old = pm_idle;
+pm_idle = cpufreq_idle;
+
+this_smoothass->cur_policy = new_policy;
+this_smoothass->enable = 1;
+
+// notice no break here!
+
+case CPUFREQ_GOV_LIMITS:
+if (this_smoothass->cur_policy->cur != new_policy->max)
+__cpufreq_driver_target(new_policy, new_policy->max, CPUFREQ_RELATION_H);
+
+break;
+
+case CPUFREQ_GOV_STOP:
+this_smoothass->enable = 0;
+
+if (atomic_dec_return(&active_count) > 1)
+return 0;
+sysfs_remove_group(&new_policy->kobj,
+&smoothass_attr_group);
+
+pm_idle = pm_idle_old;
+del_timer(&this_smoothass->timer);
+break;
+}
+
+return 0;
+}
+
+static void smoothass_suspend(int cpu, int suspend)
+{
+struct smoothass_info_s *this_smoothass = &per_cpu(smoothass_info, smp_processor_id());
+struct cpufreq_policy *policy = this_smoothass->cur_policy;
+unsigned int new_freq;
+
+if (!this_smoothass->enable || sleep_max_freq==0) // disable behavior for sleep_max_freq==0
+return;
+
+if (suspend) {
+if (policy->cur > sleep_max_freq) {
+new_freq = sleep_max_freq;
+if (new_freq > policy->max)
+new_freq = policy->max;
+if (new_freq < policy->min)
+new_freq = policy->min;
+__cpufreq_driver_target(policy, new_freq,
+CPUFREQ_RELATION_H);
+}
+} else { // resume at max speed:
+__cpufreq_driver_target(policy, policy->max,
+CPUFREQ_RELATION_H);
+}
+
+}
+
+static void smoothass_early_suspend(struct early_suspend *handler) {
+int i;
+suspended = 1;
+for_each_online_cpu(i)
+smoothass_suspend(i,1);
+}
+
+static void smoothass_late_resume(struct early_suspend *handler) {
+int i;
+suspended = 0;
+for_each_online_cpu(i)
+smoothass_suspend(i,0);
+}
+
+static struct early_suspend smoothass_power_suspend = {
+.suspend = smoothass_early_suspend,
+.resume = smoothass_late_resume,
+};
+
+static int __init cpufreq_smoothass_init(void)
+{
+unsigned int i;
+struct smoothass_info_s *this_smoothass;
+down_rate_us = DEFAULT_DOWN_RATE_US;
+up_min_freq = DEFAULT_UP_MIN_FREQ;
+sleep_max_freq = DEFAULT_SLEEP_MAX_FREQ;
+sample_rate_jiffies = DEFAULT_SAMPLE_RATE_JIFFIES;
+ramp_up_step = DEFAULT_RAMP_UP_STEP;
+max_ramp_down = DEFAULT_MAX_RAMP_DOWN;
+max_cpu_load = DEFAULT_MAX_CPU_LOAD;
+min_cpu_load = DEFAULT_MIN_CPU_LOAD;
+
+suspended = 0;
+
+/* Initalize per-cpu data: */
+for_each_possible_cpu(i) {
+this_smoothass = &per_cpu(smoothass_info, i);
+this_smoothass->enable = 0;
+this_smoothass->force_ramp_up = 0;
+this_smoothass->time_in_idle = 0;
+this_smoothass->idle_exit_time = 0;
+// intialize timer:
+init_timer_deferrable(&this_smoothass->timer);
+this_smoothass->timer.function = cpufreq_smoothass_timer;
+this_smoothass->timer.data = i;
+}
+
+/* Scale up is high priority */
+up_wq = create_rt_workqueue("ksmoothass_up");
+down_wq = create_workqueue("ksmoothass_down");
+
+INIT_WORK(&freq_scale_work, cpufreq_smoothass_freq_change_time_work);
+
+register_early_suspend(&smoothass_power_suspend);
+
+return cpufreq_register_governor(&cpufreq_gov_smoothass);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_SMOOTHASS
+pure_initcall(cpufreq_smoothass_init);
+#else
+module_init(cpufreq_smoothass_init);
+#endif
+
+static void __exit cpufreq_smoothass_exit(void)
+{
+cpufreq_unregister_governor(&cpufreq_gov_smoothass);
+destroy_workqueue(up_wq);
+destroy_workqueue(down_wq);
+}
+
+module_exit(cpufreq_smoothass_exit);
+
+MODULE_AUTHOR ("Erasmux, modified by LeeDrOiD");
+MODULE_DESCRIPTION ("'cpufreq_smoothass' - A smart cpufreq governor");
+MODULE_LICENSE ("GPL");
+
+
+
diff --git a/Kernel/sound/soc/codecs/Kconfig.voodoo b/Kernel/sound/soc/codecs/Kconfig.voodoo
new file mode 100644
index 0000000..ea4d51e
--- /dev/null
+++ b/Kernel/sound/soc/codecs/Kconfig.voodoo
@@ -0,0 +1,53 @@
+menuconfig SND_VOODOO
+	bool "Voodoo sound driver"
+	depends on SND_UNIVERSAL_WM8994 || SND_S3C24XX_SOC || SND_SOC_WM8994_P3
+	default y
+	help
+	  With this option enabled, the kernel compile an additionnal driver
+	  that extend the existing sound driver
+
+config SND_VOODOO_HP_LEVEL_CONTROL
+	bool "Add headphone amplifier level control"
+	depends on SND_VOODOO
+	default y
+	help
+	  Adds a control allowing to adjust the analog gain of the headphone
+	  amplifier
+
+config SND_VOODOO_HP_LEVEL
+	int "default level at boot 0-62"
+	depends on SND_VOODOO_HP_LEVEL_CONTROL
+	default 54 if MACH_HERRING=y || M110S=y
+	default 47
+	range 0 62
+	help
+	  Default headphone amplifier level. Take care not setting it to high,
+	  it would introduce hiss for people not using the control app
+
+config SND_VOODOO_RECORD_PRESETS
+	bool "Microphone recording presets"
+	depends on SND_VOODOO
+	default y
+	help
+	  Recording presets with Dynamic Range Compression auto-gain
+	  on microphone:
+	    - Original
+	    - High sensitivity
+	    - Balanced (recommanded, default)
+	    - Loud environment - concert
+
+config SND_VOODOO_MODULE
+	tristate "Build also as module (incomplete)"
+	depends on SND_VOODOO && m && n
+	default n
+	help
+	  requires additionnal source
+
+config SND_VOODOO_DEVELOPMENT
+	bool "Codec development tools (unsafe)"
+	depends on SND_VOODOO
+	default n
+	help
+	  Allow to codec dump registers and load register-address/value batchs
+	  Powerful but also dangerous tool
+
diff --git a/Kernel/sound/soc/codecs/victory/wm8994_voodoo.c b/Kernel/sound/soc/codecs/victory/wm8994_voodoo.c
new file mode 100644
index 0000000..d877d78
--- /dev/null
+++ b/Kernel/sound/soc/codecs/victory/wm8994_voodoo.c
@@ -0,0 +1,1871 @@
+/*
+ * voodoo_sound.c  --  WM8994 ALSA Soc Audio driver related
+ *
+ *  Copyright (C) 2010/11 Franois SIMOND / twitter & XDA-developers @supercurio
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <sound/soc.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/version.h>
+#include "wm8994_voodoo.h"
+
+#ifndef MODULE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) && !defined(GALAXY_TAB)
+#include "wm8994_samsung.h"
+#else
+#include "wm8994.h"
+#endif
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) && !defined(GALAXY_TAB)
+#include "../wm8994_samsung.h"
+#else
+#include "../wm8994.h"
+#endif
+#endif
+
+#define SUBJECT "wm8994_voodoo.c"
+
+#ifdef MODULE
+#include "tegrak_voodoo_sound.h"
+
+// wm8994_write -> tegrak_wm8994_write for dynamic link
+#ifdef wm8994_write
+#undef wm8994_write
+#endif
+
+// wm8994_read -> tegrak_wm8994_read for dynamic link
+#ifdef wm8994_read
+#undef wm8994_read
+#endif
+
+#define wm8994_write(codec, reg, value) tegrak_wm8994_write(codec, reg, value)
+#define wm8994_read(codec, reg) tegrak_wm8994_read(codec, reg)
+#endif
+
+bool bypass_write_hook = false;
+
+short unsigned int debug_log_level = LOG_OFF;
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+unsigned short hp_level[2] = { CONFIG_SND_VOODOO_HP_LEVEL,
+			       CONFIG_SND_VOODOO_HP_LEVEL };
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+bool fm_radio_headset_restore_bass = true;
+bool fm_radio_headset_restore_highs = true;
+bool fm_radio_headset_normalize_gain = true;
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+unsigned short recording_preset = 1;
+unsigned short origin_recgain;
+unsigned short origin_recgain_mixer;
+#endif
+
+#ifdef NEXUS_S
+bool speaker_tuning = false;
+#endif
+
+// global active or kill switch
+bool enable = false;
+
+bool dac_osr128 = true;
+bool adc_osr128 = false;
+#ifndef GALAXY_TAB_TEGRA
+bool fll_tuning = true;
+#endif
+bool dac_direct = true;
+bool mono_downmix = false;
+
+// equalizer
+
+// digital gain value in mili dB
+int digital_gain = 0;
+
+bool headphone_eq = false;
+short eq_gains[5] = { 0, 0, 0, 0, 0 };
+short eq_bands[5] = { 3, 4, 4, 4, 3 };
+char eq_band_coef_names[][2] = { "A", "B", "C", "PG" };
+
+unsigned int eq_band_values[5][4] = {
+	{0x0FCA, 0x0400, 0x00D8},
+	{0x1EB5, 0xF145, 0x0B75, 0x01C5},
+	{0x1C58, 0xF373, 0x0A54, 0x0558},
+	{0x168E, 0xF829, 0x07AD, 0x1103},
+	{0x0564, 0x0559, 0x4000}
+};
+
+// 3D effect
+bool stereo_expansion = false;
+short unsigned int stereo_expansion_gain = 16;
+
+// keep here a pointer to the codec structure
+struct snd_soc_codec *codec;
+
+#define DECLARE_BOOL_SHOW(name) 					       \
+static ssize_t name##_show(struct device *dev,				       \
+struct device_attribute *attr, char *buf)				       \
+{									       \
+	return sprintf(buf,"%u\n",(name ? 1 : 0));			       \
+}
+
+#define DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(name, updater, with_mute)	       \
+static ssize_t name##_store(struct device *dev, struct device_attribute *attr, \
+	const char *buf, size_t size)					       \
+{									       \
+	unsigned short state;						       \
+	if (sscanf(buf, "%hu", &state) == 1) {				       \
+		name = state == 0 ? false : true;			       \
+		if (debug_log(LOG_INFOS))				       \
+			printk("Voodoo sound: %s: %u\n", #updater, state);     \
+		updater(with_mute);					       \
+	}								       \
+	return size;							       \
+}
+
+#define DECLARE_EQ_GAIN_SHOW(band)					       \
+static ssize_t headphone_eq_b##band##_gain_show(struct device *dev,	       \
+					 struct device_attribute *attr,	       \
+					 char *buf)			       \
+{									       \
+	return sprintf(buf, "%d\n", eq_gains[band - 1]);		       \
+}
+
+#define DECLARE_EQ_GAIN_STORE(band)					       \
+static ssize_t headphone_eq_b##band##_gain_store(struct device *dev,	       \
+					  struct device_attribute *attr,       \
+					  const char *buf, size_t size)	       \
+{									       \
+	short new_gain;							       \
+	if (sscanf(buf, "%hd", &new_gain) == 1) {			       \
+		if (new_gain >= -12 && new_gain <= 12) {		       \
+			smooth_apply_eq_band_gain(band - 1,		       \
+						  eq_gains[band - 1],	       \
+						  new_gain,		       \
+						  headphone_eq);	       \
+			eq_gains[band - 1] = new_gain;			       \
+		}							       \
+	}								       \
+	return size;							       \
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+#define DECLARE_WM8994(codec) struct wm8994_priv *wm8994 = codec->drvdata;
+#else
+#define DECLARE_WM8994(codec) struct wm8994_priv *wm8994 = codec->private_data;
+#endif
+
+bool debug_log(short unsigned int level)
+{
+	if (debug_log_level >= level)
+		return true;
+
+	return false;
+}
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+int hpvol(int channel)
+{
+	int vol;
+
+	vol = hp_level[channel];
+
+	if (is_path_media_or_fm_no_call_no_record()) {
+		// negative digital gain compensation
+		if (digital_gain < 0)
+			vol = (vol - ((digital_gain / 100) + 5) / 10);
+
+		if (vol > 62)
+			return 62;
+	}
+
+	return vol;
+}
+
+void write_hpvol(unsigned short l, unsigned short r)
+{
+	unsigned short val;
+
+	// we don't need the Volume Update flag when sending the first volume
+	val = (WM8994_HPOUT1L_MUTE_N | l);
+	val |= WM8994_HPOUT1L_ZC;
+	wm8994_write(codec, WM8994_LEFT_OUTPUT_VOLUME, val);
+
+	// this time we write the right volume plus the Volume Update flag.
+	// This way, both volume are set at the same time
+	val = (WM8994_HPOUT1_VU | WM8994_HPOUT1R_MUTE_N | r);
+	val |= WM8994_HPOUT1L_ZC;
+	wm8994_write(codec, WM8994_RIGHT_OUTPUT_VOLUME, val);
+}
+
+void update_hpvol(bool with_fade)
+{
+	unsigned short val;
+	unsigned short i;
+	short steps;
+	int hp_level_old[2];
+	unsigned short hp_level_registers[2] = { WM8994_LEFT_OUTPUT_VOLUME,
+						 WM8994_RIGHT_OUTPUT_VOLUME };
+
+	DECLARE_WM8994(codec);
+
+	// don't affect headphone amplifier volume
+	// when not on heapdhones or if call is active
+	if (!is_path(HEADPHONES)
+	    || (wm8994->codec_state & CALL_ACTIVE))
+		return;
+
+
+	if (!with_fade) {
+		bypass_write_hook = true;
+		write_hpvol(hpvol(0), hpvol(1));
+		bypass_write_hook = false;
+		return;
+	}
+
+	// read previous levels
+	for (i = 0; i < 2; i++) {
+		val = wm8994_read(codec, hp_level_registers[i]);
+		val &= ~(WM8994_HPOUT1_VU_MASK);
+		val &= ~(WM8994_HPOUT1L_ZC_MASK);
+		val &= ~(WM8994_HPOUT1L_MUTE_N_MASK);
+		hp_level_old[i] = val + (digital_gain / 1000);
+
+		if (hp_level_old[i] < 0)
+			hp_level_old[i] = 0;
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: previous hp_level[%hu]: %d\n",
+			       i, hp_level_old[i]);
+	}
+
+	// calculate number of steps for volume fade
+	steps = hp_level[0] - hp_level_old[0];
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: volume change steps: %hd "
+		       "start: %hu, end: %hu\n",
+		       steps,
+		       hp_level_old[0],
+		       hp_level[0]);
+
+	while (steps != 0) {
+		if (hp_level[0] < hp_level_old[0])
+			steps++;
+		else
+			steps--;
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: volume: %hu\n",
+			       (hpvol(0) - steps));
+
+		bypass_write_hook = true;
+		write_hpvol(hpvol(0) - steps, hpvol(1) - steps);
+		bypass_write_hook = false;
+
+		if (steps != 0)
+			udelay(1000);
+	}
+
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+void update_fm_radio_headset_restore_freqs(bool with_mute)
+{
+	unsigned short val;
+	DECLARE_WM8994(codec);
+
+	bypass_write_hook = true;
+	// apply only when FM radio is active
+	if (wm8994->fmradio_path == FMR_OFF)
+		return;
+
+	if (with_mute) {
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1,
+			     WM8994_AIF2DAC_MUTE |
+			     WM8994_AIF2DAC_MUTERATE |
+			     WM8994_AIF2DAC_UNMUTE_RAMP |
+			     WM8994_AIF2DAC_DEEMP_MASK);
+		msleep(180);
+	}
+
+	if (fm_radio_headset_restore_bass) {
+		// disable Sidetone high-pass filter
+		// was designed for voice and not FM radio
+		wm8994_write(codec, WM8994_SIDETONE, 0x0000);
+		// disable 4FS ultrasonic mode and
+		// restore the hi-fi <4Hz hi pass filter
+		wm8994_write(codec, WM8994_AIF2_ADC_FILTERS,
+			     WM8994_AIF2ADCL_HPF |
+			     WM8994_AIF2ADCR_HPF);
+	} else {
+		// default settings in GT-I9000 Froyo XXJPX kernel sources
+		wm8994_write(codec, WM8994_SIDETONE, 0x01c0);
+		wm8994_write(codec, WM8994_AIF2_ADC_FILTERS, 0xF800);
+	}
+
+	if (fm_radio_headset_restore_highs) {
+		val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+		val &= ~(WM8994_AIF2DAC_DEEMP_MASK);
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+	} else {
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, 0x0036);
+	}
+
+	// un-mute
+	if (with_mute) {
+		val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+		val &= ~(WM8994_AIF2DAC_MUTE_MASK);
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+	}
+	bypass_write_hook = false;
+}
+
+void update_fm_radio_headset_normalize_gain(bool with_mute)
+{
+	DECLARE_WM8994(codec);
+
+	bypass_write_hook = true;
+	// apply only when FM radio is active
+	if (wm8994->fmradio_path == FMR_OFF)
+		return;
+
+	if (fm_radio_headset_normalize_gain) {
+		// Bumped volume, change with Zero Cross
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_3_4_VOLUME, 0x52);
+		wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_3_4_VOLUME, 0x152);
+		wm8994_write(codec, WM8994_AIF2_DRC_2, 0x0840);
+		wm8994_write(codec, WM8994_AIF2_DRC_3, 0x2408);
+		wm8994_write(codec, WM8994_AIF2_DRC_4, 0x0082);
+		wm8994_write(codec, WM8994_AIF2_DRC_5, 0x0100);
+		wm8994_write(codec, WM8994_AIF2_DRC_1, 0x019C);
+	} else {
+		// Original volume, change with Zero Cross
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_3_4_VOLUME, 0x4B);
+		wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_3_4_VOLUME, 0x14B);
+		wm8994_write(codec, WM8994_AIF2_DRC_2, 0x0840);
+		wm8994_write(codec, WM8994_AIF2_DRC_3, 0x2400);
+		wm8994_write(codec, WM8994_AIF2_DRC_4, 0x0000);
+		wm8994_write(codec, WM8994_AIF2_DRC_5, 0x0000);
+		wm8994_write(codec, WM8994_AIF2_DRC_1, 0x019C);
+	}
+	bypass_write_hook = false;
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+void update_recording_preset(bool with_mute)
+{
+	if (!is_path(MAIN_MICROPHONE))
+		return;
+
+	switch (recording_preset) {
+	case 0:
+		// Original:
+		// On Galaxy S: IN1L_VOL1=11000 (+19.5 dB)
+		// On Nexus S: variable value
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME,
+			     WM8994_IN1L_VU | origin_recgain);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3, origin_recgain_mixer);
+		// DRC disabled
+		wm8994_write(codec, WM8994_AIF1_DRC1_1, 0x0080);
+		break;
+	case 2:
+		// High sensitivy:
+		// Original - 4.5 dB, IN1L_VOL1=10101 (+15 dB)
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x0115);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+			     WM8994_IN1L_TO_MIXINL |
+			     WM8994_IN1L_MIXINL_VOL);
+		// DRC Input: -6dB, Ouptut -3.75dB
+		//     Above knee 1/8, Below knee 1/2
+		//     Max gain 24 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0426);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0019);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x0105);
+		break;
+	case 3:
+		// Concert new: IN1L_VOL1=10110 (+4.5 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x010F);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -4.5dB, Ouptut -6.75dB
+		//     Above knee 1/4, Below knee 1/2
+		//     Max gain 24 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0846);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0011);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00C9);
+		break;
+	case 4:
+		// ULTRA LOUD:
+		// Original - 36 dB - 30 dB IN1L_VOL1=00000 (-16.5 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x0100);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -7.5dB, Ouptut -6dB
+		//     Above knee 1/8, Below knee 1/4
+		//     Max gain 36 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0847);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x001A);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00C9);
+		break;
+	default:
+		// make sure recording_preset is the default
+		recording_preset = 1;
+		// New Balanced: Original - 16.5 dB
+		// IN1L_VOL1=01101 (+27 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x055D);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -18.5dB, Ouptut -9dB
+		//     Above knee 1/8, Below knee 1/2
+		//     Max gain 18 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0845);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0019);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x030C);
+		break;
+	}
+}
+#endif
+
+bool is_path(int unified_path)
+{
+	DECLARE_WM8994(codec);
+
+	switch (unified_path) {
+	// speaker
+	case SPEAKER:
+#ifdef GALAXY_TAB
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == RING_SPK
+			|| wm8994->fmradio_path == FMR_SPK
+			|| wm8994->fmradio_path == FMR_SPK_MIX);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == SPK_HP);
+#else
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == RING_SPK);
+#endif
+#endif
+
+	// headphones
+	case HEADPHONES:
+
+#ifdef NEXUS_S
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+#ifdef GALAXY_TAB
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+		return (wm8994->cur_path == HP3P
+			|| wm8994->cur_path == HP4P
+			|| wm8994->fmradio_path == FMR_HP);
+#endif
+#else
+#ifdef M110S
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+		return (wm8994->cur_path == HP);
+#endif
+#else
+#ifdef GALAXY_TAB_TEGRA
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC
+			|| wm8994->fmradio_path == FMR_HP);
+#else
+		return (wm8994->cur_path == HP
+			|| wm8994->fmradio_path == FMR_HP);
+#endif
+#endif
+#endif
+#endif
+#endif
+
+	// FM Radio on headphones
+	case RADIO_HEADPHONES:
+#ifdef NEXUS_S
+		return false;
+#else
+#ifdef M110S
+		return false;
+#else
+#ifdef GALAXY_TAB_TEGRA
+		return false;
+#else
+#ifdef GALAXY_TAB
+		return false;
+#else
+		return (wm8994->codec_state & FMRADIO_ACTIVE)
+		    && (wm8994->fmradio_path == FMR_HP);
+#endif
+#endif
+#endif
+#endif
+
+	// Standard recording presets
+	// for M110S Gingerbread: added check non call
+	case MAIN_MICROPHONE:
+		return (wm8994->codec_state & CAPTURE_ACTIVE)
+		    && (wm8994->rec_path == MAIN)
+		    && !(wm8994->codec_state & CALL_ACTIVE);
+
+	}
+	return false;
+}
+
+bool is_path_media_or_fm_no_call_no_record()
+{
+
+	DECLARE_WM8994(codec);
+
+	if ((is_path(HEADPHONES)
+	     && (wm8994->codec_state & PLAYBACK_ACTIVE)
+	     && (wm8994->stream_state & PCM_STREAM_PLAYBACK)
+	     && !(wm8994->codec_state & CALL_ACTIVE)
+	     && (wm8994->rec_path == MIC_OFF)
+	    ) || is_path(RADIO_HEADPHONES))
+		return true;
+
+	return false;
+}
+
+#ifdef NEXUS_S
+void update_speaker_tuning(bool with_mute)
+{
+	DECLARE_WM8994(codec);
+
+	if (!(is_path(SPEAKER) || (wm8994->codec_state & CALL_ACTIVE)))
+		return;
+
+	if (speaker_tuning) {
+		// DRC settings
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0010);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00EB);
+
+		// hardware EQ
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1,   0x041D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2,   0x4C00);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_A,  0x0FE3);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_B,  0x0403);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_PG, 0x0074);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_A,  0x1F03);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_B,  0xF0F9);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_PG, 0x03DA);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_A,  0x1ED2);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_B,  0xF11A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_PG, 0x045D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_A,  0x0E76);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_B,  0xFCE4);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_PG, 0x330D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_A,  0xFC8F);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_B,  0x0400);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_PG, 0x323C);
+
+		// Speaker Boost tuning
+		wm8994_write(codec, WM8994_CLASSD,                 0x0170);
+	} else {
+		// DRC settings
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0028);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x0186);
+
+		// hardware EQ
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1,   0x0019);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2,   0x6280);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_A,  0x0FC3);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_B,  0x03FD);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_PG, 0x00F4);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_A,  0x1F30);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_B,  0xF0CD);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_PG, 0x032C);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_A,  0x1C52);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_B,  0xF379);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_PG, 0x0DC1);
+		wm8994_write(codec, WM8994_CLASSD,                 0x0170);
+
+		// Speaker Boost tuning
+		wm8994_write(codec, WM8994_CLASSD,                 0x0168);
+	}
+}
+#endif
+
+unsigned short osr128_get_value(unsigned short val)
+{
+	if (dac_osr128 == 1)
+		val |= WM8994_DAC_OSR128;
+	else
+		val &= ~WM8994_DAC_OSR128;
+
+	if (adc_osr128 == 1)
+		val |= WM8994_ADC_OSR128;
+	else
+		val &= ~WM8994_ADC_OSR128;
+
+	return val;
+}
+
+void update_osr128(bool with_mute)
+{
+	unsigned short val;
+	val = osr128_get_value(wm8994_read(codec, WM8994_OVERSAMPLING));
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_OVERSAMPLING, val);
+	bypass_write_hook = false;
+}
+
+#ifndef GALAXY_TAB_TEGRA
+unsigned short fll_tuning_get_value(unsigned short val)
+{
+	val = (val >> WM8994_FLL1_GAIN_WIDTH << WM8994_FLL1_GAIN_WIDTH);
+	if (fll_tuning == 1)
+		val |= 5;
+
+	return val;
+}
+
+void update_fll_tuning(bool with_mute)
+{
+	unsigned short val;
+	val = fll_tuning_get_value(wm8994_read(codec, WM8994_FLL1_CONTROL_4));
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_FLL1_CONTROL_4, val);
+	bypass_write_hook = false;
+}
+#endif
+
+unsigned short mono_downmix_get_value(unsigned short val, bool can_reverse)
+{
+	DECLARE_WM8994(codec);
+
+	// Takes care not switching to Stereo on speaker or during a call
+	if (!is_path(SPEAKER) && !(wm8994->codec_state & CALL_ACTIVE)) {
+		if (mono_downmix) {
+			val |= WM8994_AIF1DAC1_MONO;
+		} else {
+			if (can_reverse)
+				val &= ~WM8994_AIF1DAC1_MONO;
+		}
+	}
+
+	return val;
+}
+
+void update_mono_downmix(bool with_mute)
+{
+	unsigned short val1, val2, val3;
+	val1 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF1_DAC1_FILTERS_1),
+				      true);
+	val2 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF1_DAC2_FILTERS_1),
+				      true);
+	val3 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF2_DAC_FILTERS_1),
+				      true);
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val1);
+	wm8994_write(codec, WM8994_AIF1_DAC2_FILTERS_1, val2);
+	wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val3);
+	bypass_write_hook = false;
+}
+
+unsigned short dac_direct_get_value(unsigned short val, bool can_reverse)
+{
+	if (is_path_media_or_fm_no_call_no_record()) {
+
+		if (dac_direct) {
+			if (val == WM8994_DAC1L_TO_MIXOUTL)
+				return WM8994_DAC1L_TO_HPOUT1L;
+		} else {
+			if (val == WM8994_DAC1L_TO_HPOUT1L && can_reverse)
+				return WM8994_DAC1L_TO_MIXOUTL;
+		}
+	}
+
+	return val;
+}
+
+void update_dac_direct(bool with_mute)
+{
+	unsigned short val1, val2;
+	val1 = dac_direct_get_value(wm8994_read(codec,
+						WM8994_OUTPUT_MIXER_1), true);
+	val2 = dac_direct_get_value(wm8994_read(codec,
+						WM8994_OUTPUT_MIXER_2), true);
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val1);
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val2);
+	bypass_write_hook = false;
+}
+
+unsigned short digital_gain_get_value(unsigned short val)
+{
+	// AIF gain to 0dB
+	int aif_gain = 0xC0;
+	int i;
+	int step = -375;
+
+	if (is_path_media_or_fm_no_call_no_record()) {
+
+		if (digital_gain <= 0) {
+			// clear the actual DAC volume for this value
+			val &= ~(WM8994_DAC1R_VOL_MASK);
+
+			// calculation with round
+			i = ((digital_gain * 10 / step) + 5) / 10;
+			aif_gain -= i;
+			val |= aif_gain;
+
+			if (debug_log(LOG_INFOS))
+				printk("Voodoo sound: digital gain: %d mdB, "
+				       "%d mdB steps: %d, "
+				       "real AIF gain: %d mdB\n",
+				       digital_gain, step, i, i * step);
+		}
+	}
+
+	return val;
+}
+
+void update_digital_gain(bool with_mute)
+{
+	unsigned short val1, val2;
+	val1 = digital_gain_get_value(wm8994_read(codec,
+						WM8994_AIF1_DAC1_LEFT_VOLUME));
+	val2 = digital_gain_get_value(wm8994_read(codec,
+						WM8994_AIF1_DAC1_RIGHT_VOLUME));
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_AIF1_DAC1_LEFT_VOLUME,
+		     WM8994_DAC1_VU | val1);
+	wm8994_write(codec, WM8994_AIF1_DAC1_RIGHT_VOLUME,
+		     WM8994_DAC1_VU | val2);
+	bypass_write_hook = false;
+}
+
+void update_headphone_eq(bool update_bands)
+{
+	int gains_1;
+	int gains_2;
+
+	if (!is_path_media_or_fm_no_call_no_record()) {
+		// don't apply the EQ
+		return;
+	}
+
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: EQ gains (dB): %hd, %hd, %hd, %hd, %hd\n",
+		       eq_gains[0], eq_gains[1], eq_gains[2],
+		       eq_gains[3], eq_gains[4]);
+
+	gains_1 =
+	    ((eq_gains[0] + 12) << WM8994_AIF1DAC1_EQ_B1_GAIN_SHIFT) |
+	    ((eq_gains[1] + 12) << WM8994_AIF1DAC1_EQ_B2_GAIN_SHIFT) |
+	    ((eq_gains[2] + 12) << WM8994_AIF1DAC1_EQ_B3_GAIN_SHIFT) |
+	    headphone_eq;
+
+	gains_2 =
+	    ((eq_gains[3] + 12) << WM8994_AIF1DAC1_EQ_B4_GAIN_SHIFT) |
+	    ((eq_gains[4] + 12) << WM8994_AIF1DAC1_EQ_B5_GAIN_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1, gains_1);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2, gains_2);
+
+	// don't send EQ configuration if its not enabled
+	if (!headphone_eq)
+		return;
+
+	if (update_bands)
+		update_headphone_eq_bands();
+}
+
+void update_headphone_eq_bands()
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+
+	for (i = 0; i < ARRAY_SIZE(eq_band_values); i++) {
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: send EQ Band %d\n", i + 1);
+
+		for (j = 0; j < eq_bands[i]; j++) {
+			wm8994_write(codec,
+				     first_reg + k, eq_band_values[i][j]);
+			k++;
+		}
+	}
+}
+
+void smooth_apply_eq_band_gain(int band, int start, int end, bool current_state)
+{
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: EQ smooth transition for Band %d "
+		       "from %d to %d\n", band + 1, start, end);
+
+	if (start == end) {
+		if (end != 0)
+			update_headphone_eq(true);
+		else
+			update_headphone_eq(false);
+		return;
+	}
+
+	if (current_state)
+		update_headphone_eq_bands();
+
+	while (start != end) {
+		if (start < end)
+			start++;
+		else
+			start--;
+
+		eq_gains[band] = start;
+		update_headphone_eq(false);
+	}
+}
+
+void update_stereo_expansion(bool with_mute)
+{
+	short unsigned int val;
+
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_2);
+	if (stereo_expansion) {
+		val &= ~(WM8994_AIF1DAC1_3D_GAIN_MASK);
+		val |= (stereo_expansion_gain << WM8994_AIF1DAC1_3D_GAIN_SHIFT);
+	}
+	val &= ~(WM8994_AIF1DAC1_3D_ENA_MASK);
+	val |= (stereo_expansion << WM8994_AIF1DAC1_3D_ENA_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_2, val);
+}
+
+void load_current_eq_values()
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+
+	for (i = 0; i < ARRAY_SIZE(eq_band_values); i++)
+		for (j = 0; j < eq_bands[i]; j++) {
+			eq_band_values[i][j] =
+			    wm8994_read(codec, first_reg + k);
+			k++;
+		}
+}
+
+void apply_saturation_prevention_drc()
+{
+	unsigned short val;
+	unsigned short drc_gain = 0;
+	int i;
+	int step = 750;
+
+	// don't apply the limiter if not playing media
+	// (exclude FM radio, it has its own DRC settings)
+	if (!is_path_media_or_fm_no_call_no_record()
+	    || is_path(RADIO_HEADPHONES))
+		return;
+
+	// don't apply the limiter without stereo_expansion or headphone_eq
+	// or a positive digital gain
+	if (!(stereo_expansion
+	      || headphone_eq
+	      || digital_gain >= 0))
+		return;
+
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: apply saturation prevention DRC\n");
+
+	// configure the DRC to avoid saturation: not actually compress signal
+	// gain is unmodified. Should affect only what's higher than 0 dBFS
+
+	// tune Attack & Decacy values
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_2);
+	val &= ~(WM8994_AIF1DRC1_ATK_MASK);
+	val &= ~(WM8994_AIF1DRC1_DCY_MASK);
+	val |= (0x1 << WM8994_AIF1DRC1_ATK_SHIFT);
+	val |= (0x4 << WM8994_AIF1DRC1_DCY_SHIFT);
+
+	// set DRC maximum gain to 36 dB
+	val &= ~(WM8994_AIF1DRC1_MAXGAIN_MASK);
+	val |= (0x3 << WM8994_AIF1DRC1_MAXGAIN_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DRC1_2, val);
+
+	// Above knee: flat (what really avoid the saturation)
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_3);
+	val |= (0x5 << WM8994_AIF1DRC1_HI_COMP_SHIFT);
+	wm8994_write(codec, WM8994_AIF1_DRC1_3, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_1);
+	// disable Quick Release and Anti Clip
+	// both do do more harm than good for this particular usage
+	val &= ~(WM8994_AIF1DRC1_QR_MASK);
+	val &= ~(WM8994_AIF1DRC1_ANTICLIP_MASK);
+
+	// enable DRC
+	val &= ~(WM8994_AIF1DAC1_DRC_ENA_MASK);
+	val |= WM8994_AIF1DAC1_DRC_ENA;
+	wm8994_write(codec, WM8994_AIF1_DRC1_1, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_4);
+	val &= ~(WM8994_AIF1DRC1_KNEE_IP_MASK);
+
+	if (digital_gain >= 0) {
+		// deal with positive digital gains
+		i = ((digital_gain * 10 / step) + 5) / 10;
+		drc_gain += i;
+		val |= (drc_gain << WM8994_AIF1DRC1_KNEE_IP_SHIFT);
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: digital gain: %d mdB, "
+			       "%d mdB steps: %d, real DRC gain: %d mdB\n",
+			       digital_gain, step, i, i * step);
+
+	}
+	wm8994_write(codec, WM8994_AIF1_DRC1_4, val);
+}
+
+/*
+ *
+ * Declaring the controling misc devices
+ *
+ */
+static ssize_t debug_log_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%u\n", debug_log_level);
+}
+
+static ssize_t debug_log_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	sscanf(buf, "%hu", &debug_log_level);
+	return size;
+}
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+static ssize_t headphone_amplifier_level_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	// output median of left and right headphone amplifier volumes
+	return sprintf(buf, "%u\n", (hp_level[0] + hp_level[1]) / 2);
+}
+
+static ssize_t headphone_amplifier_level_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t size)
+{
+	unsigned short vol;
+	if (sscanf(buf, "%hu", &vol) == 1) {
+
+		// hard limit to 62 because 63 introduces distortions
+		if (vol > 62)
+			vol = 62;
+
+		// left and right are set to the same volumes by this control
+		hp_level[0] = hp_level[1] = vol;
+
+		update_digital_gain(false);
+		update_hpvol(true);
+	}
+	return size;
+}
+#endif
+
+#ifdef NEXUS_S
+DECLARE_BOOL_SHOW(speaker_tuning);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(speaker_tuning,
+				    update_speaker_tuning,
+				    false);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+DECLARE_BOOL_SHOW(fm_radio_headset_restore_bass);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_restore_bass,
+				    update_fm_radio_headset_restore_freqs,
+				    true);
+
+DECLARE_BOOL_SHOW(fm_radio_headset_restore_highs);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_restore_highs,
+				    update_fm_radio_headset_restore_freqs,
+				    true);
+
+DECLARE_BOOL_SHOW(fm_radio_headset_normalize_gain);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_normalize_gain,
+				    update_fm_radio_headset_normalize_gain,
+				    false);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+static ssize_t recording_preset_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", recording_preset);
+}
+
+static ssize_t recording_preset_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	unsigned short preset_number;
+	if (sscanf(buf, "%hu", &preset_number) == 1) {
+		recording_preset = preset_number;
+		update_recording_preset(false);
+	}
+	return size;
+}
+#endif
+
+DECLARE_BOOL_SHOW(dac_osr128);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(dac_osr128,
+				    update_osr128,
+				    false);
+
+DECLARE_BOOL_SHOW(adc_osr128);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(adc_osr128,
+				    update_osr128,
+				    false);
+
+#ifndef GALAXY_TAB_TEGRA
+DECLARE_BOOL_SHOW(fll_tuning);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fll_tuning,
+				    update_fll_tuning,
+				    false);
+#endif
+
+DECLARE_BOOL_SHOW(mono_downmix);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(mono_downmix,
+				    update_mono_downmix,
+				    false);
+
+DECLARE_BOOL_SHOW(dac_direct);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(dac_direct,
+				    update_dac_direct,
+				    false);
+
+static ssize_t digital_gain_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", digital_gain);
+}
+
+static ssize_t digital_gain_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	int new_digital_gain;
+	if (sscanf(buf, "%d", &new_digital_gain) == 1) {
+		if (new_digital_gain <= 36000 && new_digital_gain >= -71625) {
+			if (new_digital_gain > digital_gain) {
+				// reduce analog volume first
+				digital_gain = new_digital_gain;
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+				update_hpvol(false);
+#endif
+				update_digital_gain(false);
+			} else {
+				// reduce digital volume first
+				digital_gain = new_digital_gain;
+				update_digital_gain(false);
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+				update_hpvol(false);
+#endif
+			}
+		}
+		apply_saturation_prevention_drc();
+	}
+	return size;
+}
+
+DECLARE_BOOL_SHOW(headphone_eq);
+static ssize_t headphone_eq_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	unsigned short state;
+	bool current_state;
+	int i;
+	short eq_gains_copy[ARRAY_SIZE(eq_gains)];
+
+	if (sscanf(buf, "%hu", &state) == 1) {
+		current_state = state == 0 ? false : true;
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: EQ activation: %u\n", state);
+
+		if (current_state) {
+			// fade from 0dB each EQ band
+			headphone_eq = current_state;
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++)
+				smooth_apply_eq_band_gain(i, 0, eq_gains[i],
+							  current_state);
+		} else {
+			// fade to 0dB each EQ band
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++) {
+				eq_gains_copy[i] = eq_gains[i];
+				smooth_apply_eq_band_gain(i, eq_gains[i], 0,
+							  current_state);
+			}
+			// restore original gains in driver memory not codec
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++)
+				eq_gains[i] = eq_gains_copy[i];
+			headphone_eq = current_state;
+		}
+	}
+	return size;
+}
+
+DECLARE_EQ_GAIN_SHOW(1);
+DECLARE_EQ_GAIN_STORE(1);
+DECLARE_EQ_GAIN_SHOW(2);
+DECLARE_EQ_GAIN_STORE(2);
+DECLARE_EQ_GAIN_SHOW(3);
+DECLARE_EQ_GAIN_STORE(3);
+DECLARE_EQ_GAIN_SHOW(4);
+DECLARE_EQ_GAIN_STORE(4);
+DECLARE_EQ_GAIN_SHOW(5);
+DECLARE_EQ_GAIN_STORE(5);
+
+static ssize_t headphone_eq_bands_values_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+	int bands_size = ARRAY_SIZE(eq_bands);
+	char *name;
+
+	for (i = 0; i < bands_size; i++)
+		for (j = 0; j < eq_bands[i]; j++) {
+
+			// display 3-coef bands properly (hi & lo shelf)
+			if (j + 1 == eq_bands[i])
+				name = eq_band_coef_names[3];
+			else
+				name = eq_band_coef_names[j];
+
+			sprintf(buf, "%s%d %s 0x%04X\n", buf,
+				i + 1, name,
+				wm8994_read(codec, first_reg + k));
+			k++;
+		}
+
+	return sprintf(buf, "%s", buf);
+}
+
+static ssize_t headphone_eq_bands_values_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t size)
+{
+	int i;
+	short unsigned int val;
+	short unsigned int band;
+	char coef_name[2];
+	unsigned int bytes_read = 0;
+
+	while (sscanf(buf, "%hu %s %hx%n",
+		      &band, coef_name, &val, &bytes_read) == 3) {
+
+		buf += bytes_read;
+
+		if (band < 1 || band > 5)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(eq_band_coef_names); i++) {
+			// loop through band coefficient letters
+			if (strncmp(eq_band_coef_names[i], coef_name, 2) == 0) {
+				if (eq_bands[band - 1] == 3 && i == 3)
+					// deal with high and low shelves
+					eq_band_values[band - 1][2] = val;
+				else
+					// parametric bands
+					eq_band_values[band - 1][i] = val;
+
+				if (debug_log(LOG_INFOS))
+					printk("Voodoo sound: read EQ from "
+					       "sysfs: EQ Band %hd %s: 0x%04X\n"
+					       , band, coef_name, val);
+				break;
+			}
+		}
+	}
+
+	return size;
+}
+
+DECLARE_BOOL_SHOW(stereo_expansion);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(stereo_expansion,
+				    update_stereo_expansion,
+				    false);
+
+static ssize_t stereo_expansion_gain_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%u\n", stereo_expansion_gain);
+}
+
+static ssize_t stereo_expansion_gain_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t size)
+{
+	short unsigned val;
+
+	if (sscanf(buf, "%hu", &val) == 1)
+		if (val >= 0 && val < 32) {
+			stereo_expansion_gain = val;
+			update_stereo_expansion(false);
+		}
+
+	return size;
+}
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+static ssize_t show_wm8994_register_dump(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	// modified version of register_dump from wm8994_aries.c
+	// r = wm8994 register
+	int r;
+
+	for (r = 0; r <= 0x6; r++)
+		sprintf(buf, "0x%X 0x%X\n", r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x15, wm8994_read(codec, 0x15));
+
+	for (r = 0x18; r <= 0x3C; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x4C, wm8994_read(codec, 0x4C));
+
+	for (r = 0x51; r <= 0x5C; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x60, wm8994_read(codec, 0x60));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x101, wm8994_read(codec, 0x101));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x110, wm8994_read(codec, 0x110));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x111, wm8994_read(codec, 0x111));
+
+	for (r = 0x200; r <= 0x212; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x220; r <= 0x224; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x240; r <= 0x244; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x300; r <= 0x317; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x400; r <= 0x411; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x420; r <= 0x423; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x440; r <= 0x444; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x450; r <= 0x454; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x480; r <= 0x493; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x4A0; r <= 0x4B3; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x500; r <= 0x503; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x510, wm8994_read(codec, 0x510));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x520, wm8994_read(codec, 0x520));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x521, wm8994_read(codec, 0x521));
+
+	for (r = 0x540; r <= 0x544; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x580; r <= 0x593; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x600; r <= 0x614; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x620, wm8994_read(codec, 0x620));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x621, wm8994_read(codec, 0x621));
+
+	for (r = 0x700; r <= 0x70A; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	return sprintf(buf, "%s", buf);
+}
+
+static ssize_t store_wm8994_write(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	short unsigned int reg = 0;
+	short unsigned int val = 0;
+	int unsigned bytes_read = 0;
+
+	while (sscanf(buf, "%hx %hx%n", &reg, &val, &bytes_read) == 2) {
+		buf += bytes_read;
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: read from sysfs: %X, %X\n",
+			       reg, val);
+
+		bypass_write_hook = true;
+		wm8994_write(codec, reg, val);
+		bypass_write_hook = false;
+	}
+	return size;
+}
+#endif
+
+static ssize_t voodoo_sound_version(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", VOODOO_SOUND_VERSION);
+}
+
+#ifndef MODULE
+DECLARE_BOOL_SHOW(enable);
+static ssize_t enable_store(struct device *dev,
+			    struct device_attribute *attr, const char *buf,
+			    size_t size)
+{
+	unsigned short state;
+	bool bool_state;
+	if (sscanf(buf, "%hu", &state) == 1) {
+		bool_state = state == 0 ? false : true;
+		if (state != enable) {
+			enable = bool_state;
+			update_enable();
+		}
+	}
+	return size;
+}
+#endif
+
+static DEVICE_ATTR(debug_log, S_IRUGO | S_IWUGO,
+		   debug_log_show,
+		   debug_log_store);
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+static DEVICE_ATTR(headphone_amplifier_level, S_IRUGO | S_IWUGO,
+		   headphone_amplifier_level_show,
+		   headphone_amplifier_level_store);
+#endif
+
+#ifdef NEXUS_S
+static DEVICE_ATTR(speaker_tuning, S_IRUGO | S_IWUGO,
+		   speaker_tuning_show,
+		   speaker_tuning_store);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+static DEVICE_ATTR(fm_radio_headset_restore_bass, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_restore_bass_show,
+		   fm_radio_headset_restore_bass_store);
+
+static DEVICE_ATTR(fm_radio_headset_restore_highs, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_restore_highs_show,
+		   fm_radio_headset_restore_highs_store);
+
+static DEVICE_ATTR(fm_radio_headset_normalize_gain, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_normalize_gain_show,
+		   fm_radio_headset_normalize_gain_store);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+static DEVICE_ATTR(recording_preset, S_IRUGO | S_IWUGO,
+		   recording_preset_show,
+		   recording_preset_store);
+#endif
+
+static DEVICE_ATTR(dac_osr128, S_IRUGO | S_IWUGO,
+		   dac_osr128_show,
+		   dac_osr128_store);
+
+static DEVICE_ATTR(adc_osr128, S_IRUGO | S_IWUGO,
+		   adc_osr128_show,
+		   adc_osr128_store);
+
+#ifndef GALAXY_TAB_TEGRA
+static DEVICE_ATTR(fll_tuning, S_IRUGO | S_IWUGO,
+		   fll_tuning_show,
+		   fll_tuning_store);
+#endif
+
+static DEVICE_ATTR(dac_direct, S_IRUGO | S_IWUGO,
+		   dac_direct_show,
+		   dac_direct_store);
+
+static DEVICE_ATTR(digital_gain, S_IRUGO | S_IWUGO,
+		   digital_gain_show,
+		   digital_gain_store);
+
+static DEVICE_ATTR(headphone_eq, S_IRUGO | S_IWUGO,
+		   headphone_eq_show,
+		   headphone_eq_store);
+
+static DEVICE_ATTR(headphone_eq_b1_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b1_gain_show,
+		   headphone_eq_b1_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b2_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b2_gain_show,
+		   headphone_eq_b2_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b3_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b3_gain_show,
+		   headphone_eq_b3_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b4_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b4_gain_show,
+		   headphone_eq_b4_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b5_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b5_gain_show,
+		   headphone_eq_b5_gain_store);
+
+static DEVICE_ATTR(headphone_eq_bands_values, S_IRUGO | S_IWUGO,
+		   headphone_eq_bands_values_show,
+		   headphone_eq_bands_values_store);
+
+static DEVICE_ATTR(stereo_expansion, S_IRUGO | S_IWUGO,
+		   stereo_expansion_show,
+		   stereo_expansion_store);
+
+static DEVICE_ATTR(stereo_expansion_gain, S_IRUGO | S_IWUGO,
+		   stereo_expansion_gain_show,
+		   stereo_expansion_gain_store);
+
+static DEVICE_ATTR(mono_downmix, S_IRUGO | S_IWUGO,
+		   mono_downmix_show,
+		   mono_downmix_store);
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+static DEVICE_ATTR(wm8994_register_dump, S_IRUGO,
+		   show_wm8994_register_dump,
+		   NULL);
+
+static DEVICE_ATTR(wm8994_write, S_IWUSR,
+		   NULL,
+		   store_wm8994_write);
+#endif
+
+static DEVICE_ATTR(version, S_IRUGO,
+		   voodoo_sound_version,
+		   NULL);
+
+#ifndef MODULE
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUGO,
+		   enable_show,
+		   enable_store);
+#endif
+
+#ifdef MODULE
+static DEVICE_ATTR(module, 0,
+		   NULL,
+		   NULL);
+#endif
+
+static struct attribute *voodoo_sound_attributes[] = {
+	&dev_attr_debug_log.attr,
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+	&dev_attr_headphone_amplifier_level.attr,
+#endif
+#ifdef NEXUS_S
+	&dev_attr_speaker_tuning.attr,
+#endif
+#ifdef CONFIG_SND_VOODOO_FM
+	&dev_attr_fm_radio_headset_restore_bass.attr,
+	&dev_attr_fm_radio_headset_restore_highs.attr,
+	&dev_attr_fm_radio_headset_normalize_gain.attr,
+#endif
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+	&dev_attr_recording_preset.attr,
+#endif
+	&dev_attr_dac_osr128.attr,
+	&dev_attr_adc_osr128.attr,
+#ifndef GALAXY_TAB_TEGRA
+	&dev_attr_fll_tuning.attr,
+#endif
+	&dev_attr_dac_direct.attr,
+	&dev_attr_digital_gain.attr,
+	&dev_attr_headphone_eq.attr,
+	&dev_attr_headphone_eq_b1_gain.attr,
+	&dev_attr_headphone_eq_b2_gain.attr,
+	&dev_attr_headphone_eq_b3_gain.attr,
+	&dev_attr_headphone_eq_b4_gain.attr,
+	&dev_attr_headphone_eq_b5_gain.attr,
+	&dev_attr_headphone_eq_bands_values.attr,
+	&dev_attr_stereo_expansion.attr,
+	&dev_attr_stereo_expansion_gain.attr,
+	&dev_attr_mono_downmix.attr,
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+	&dev_attr_wm8994_register_dump.attr,
+	&dev_attr_wm8994_write.attr,
+#endif
+#ifdef MODULE
+	&dev_attr_module.attr,
+#endif
+	&dev_attr_version.attr,
+	NULL
+};
+
+#ifndef MODULE
+static struct attribute *voodoo_sound_control_attributes[] = {
+	&dev_attr_enable.attr,
+	NULL
+};
+#endif
+
+static struct attribute_group voodoo_sound_group = {
+	.attrs = voodoo_sound_attributes,
+};
+
+#ifndef MODULE
+static struct attribute_group voodoo_sound_control_group = {
+	.attrs = voodoo_sound_control_attributes,
+};
+#endif
+
+static struct miscdevice voodoo_sound_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "voodoo_sound",
+};
+
+#ifndef MODULE
+static struct miscdevice voodoo_sound_control_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "voodoo_sound_control",
+};
+#endif
+
+void voodoo_hook_wm8994_pcm_remove()
+{
+	printk("Voodoo sound: removing driver v%d\n", VOODOO_SOUND_VERSION);
+	sysfs_remove_group(&voodoo_sound_device.this_device->kobj,
+			   &voodoo_sound_group);
+	misc_deregister(&voodoo_sound_device);
+}
+
+void update_enable()
+{
+	if (enable) {
+		printk("Voodoo sound: initializing driver v%d\n",
+		       VOODOO_SOUND_VERSION);
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+		printk("Voodoo sound: codec development tools enabled\n");
+#endif
+
+		misc_register(&voodoo_sound_device);
+		if (sysfs_create_group(&voodoo_sound_device.this_device->kobj,
+				       &voodoo_sound_group) < 0) {
+			printk("%s sysfs_create_group fail\n", __FUNCTION__);
+			pr_err("Failed to create sysfs group for (%s)!\n",
+			       voodoo_sound_device.name);
+		}
+	} else
+		voodoo_hook_wm8994_pcm_remove();
+}
+
+/*
+ *
+ * Driver Hooks
+ *
+ */
+
+#ifdef CONFIG_SND_VOODOO_FM
+void voodoo_hook_fmradio_headset()
+{
+	// global kill switch
+	if (!enable)
+		return;
+
+	if (!fm_radio_headset_restore_bass
+	    && !fm_radio_headset_restore_highs
+	    && !fm_radio_headset_normalize_gain)
+		return;
+
+	update_fm_radio_headset_restore_freqs(false);
+	update_fm_radio_headset_normalize_gain(false);
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+void voodoo_hook_record_main_mic()
+{
+	// global kill switch
+	if (!enable)
+		return;
+
+	if (recording_preset == 0)
+		return;
+
+	origin_recgain = wm8994_read(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME);
+	origin_recgain_mixer = wm8994_read(codec, WM8994_INPUT_MIXER_3);
+	update_recording_preset(false);
+}
+#endif
+
+#ifdef NEXUS_S
+void voodoo_hook_playback_speaker()
+{
+	// global kill switch
+	if (!enable)
+		return;
+	if (!speaker_tuning)
+		return;
+
+	update_speaker_tuning(false);
+}
+#endif
+
+unsigned int voodoo_hook_wm8994_write(struct snd_soc_codec *codec_,
+				      unsigned int reg, unsigned int value)
+{
+	DECLARE_WM8994(codec_);
+
+	// global kill switch
+	if (!enable)
+		return value;
+
+	// modify some registers before those being written to the codec
+	// be sure our pointer to codec is up to date
+	codec = codec_;
+
+	if (!bypass_write_hook) {
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+		if (is_path(HEADPHONES)
+		    && !(wm8994->codec_state & CALL_ACTIVE)) {
+
+			if (reg == WM8994_LEFT_OUTPUT_VOLUME)
+				value =
+				    (WM8994_HPOUT1_VU |
+				     WM8994_HPOUT1L_MUTE_N |
+				     hpvol(0));
+
+			if (reg == WM8994_RIGHT_OUTPUT_VOLUME)
+				value =
+				    (WM8994_HPOUT1_VU |
+				     WM8994_HPOUT1R_MUTE_N |
+				     hpvol(1));
+		}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		// FM tuning virtual hook for Gingerbread
+		if (is_path(RADIO_HEADPHONES)) {
+			if (reg == WM8994_AIF2_DRC_1
+			    || reg == WM8994_AIF2_DAC_FILTERS_1)
+				voodoo_hook_fmradio_headset();
+		}
+#else
+		// FM tuning virtual hook for Froyo
+		if (is_path(RADIO_HEADPHONES)) {
+			if (reg == WM8994_INPUT_MIXER_2
+			    || reg == WM8994_AIF2_DRC_1
+			    || reg == WM8994_ANALOGUE_HP_1)
+				voodoo_hook_fmradio_headset();
+		}
+#endif
+#endif
+		// global Oversampling tuning
+		if (reg == WM8994_OVERSAMPLING)
+			value = osr128_get_value(value);
+
+#ifndef GALAXY_TAB_TEGRA
+		// global Anti-Jitter tuning
+		if (reg == WM8994_FLL1_CONTROL_4)
+			value = fll_tuning_get_value(value);
+#endif
+
+		// global Mono downmix tuning
+		if (reg == WM8994_AIF1_DAC1_FILTERS_1
+		    || reg == WM8994_AIF1_DAC2_FILTERS_1
+		    || reg == WM8994_AIF2_DAC_FILTERS_1)
+			value = mono_downmix_get_value(value, false);
+
+		// DAC direct tuning virtual hook
+		if (reg == WM8994_OUTPUT_MIXER_1
+		    || reg == WM8994_OUTPUT_MIXER_2)
+			value = dac_direct_get_value(value, false);
+
+		// Digital Headroom virtual hook
+		if (reg == WM8994_AIF1_DAC1_LEFT_VOLUME
+		    || reg == WM8994_AIF1_DAC1_RIGHT_VOLUME)
+			value = digital_gain_get_value(value);
+
+		// Headphones EQ & 3D virtual hook
+		if (reg == WM8994_AIF1_DAC1_FILTERS_1
+		    || reg == WM8994_AIF1_DAC2_FILTERS_1
+		    || reg == WM8994_AIF2_DAC_FILTERS_1) {
+			bypass_write_hook = true;
+			apply_saturation_prevention_drc();
+			update_headphone_eq(true);
+			update_stereo_expansion(false);
+			bypass_write_hook = false;
+		}
+
+	}
+	if (debug_log(LOG_VERBOSE))
+	// log every write to dmesg
+		printk("Voodoo sound: wm8994_write 0x%03X 0x%04X "
+#ifdef NEXUS_S
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+		       "power_state=%i\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+		       wm8994->cur_path, wm8994->rec_path,
+		       wm8994->power_state);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "fmradio_path=%i, fmr_mix_path=%i, "
+#endif
+#ifndef GALAXY_TAB
+		       "input_source=%i, "
+#endif
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA) && !defined(GALAXY_TAB)
+		       "output_source=%i, "
+#endif
+		       "power_state=%i\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       wm8994->fmradio_path, wm8994->fmr_mix_path,
+#endif
+		       wm8994->cur_path, wm8994->rec_path,
+#ifndef GALAXY_TAB
+		       wm8994->input_source,
+#endif
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA) && !defined(GALAXY_TAB)
+		       wm8994->output_source,
+#endif
+		       wm8994->power_state);
+#else
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "fmradio_path=%i, fmr_mix_path=%i, "
+#endif
+#ifdef CONFIG_S5PC110_KEPLER_BOARD
+		       "call_record_path=%i, call_record_ch=%i, "
+		       "AUDIENCE_state=%i, "
+		       "Fac_SUB_MIC_state=%i, TTY_state=%i, "
+#endif
+		       "power_state=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "recognition_active=%i, ringtone_active=%i"
+#endif
+		       "\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+		       wm8994->cur_path, wm8994->rec_path,
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       wm8994->fmradio_path, wm8994->fmr_mix_path,
+#endif
+#ifdef CONFIG_S5PC110_KEPLER_BOARD
+		       wm8994->call_record_path, wm8994->call_record_ch,
+		       wm8994->AUDIENCE_state,
+		       wm8994->Fac_SUB_MIC_state, wm8994->TTY_state,
+#endif
+		       wm8994->power_state
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       ,wm8994->recognition_active,
+		       wm8994->ringtone_active
+#endif
+		);
+#endif
+#endif
+	return value;
+}
+
+void voodoo_hook_wm8994_pcm_probe(struct snd_soc_codec *codec_)
+{
+	enable = true;
+	update_enable();
+
+#ifndef MODULE
+	misc_register(&voodoo_sound_control_device);
+	if (sysfs_create_group(&voodoo_sound_control_device.this_device->kobj,
+			       &voodoo_sound_control_group) < 0) {
+		printk("%s sysfs_create_group fail\n", __FUNCTION__);
+		pr_err("Failed to create sysfs group for device (%s)!\n",
+		       voodoo_sound_control_device.name);
+	}
+#endif
+
+	// make a copy of the codec pointer
+	codec = codec_;
+
+	// initialize eq_band_values[] from default codec EQ values
+	load_current_eq_values();
+}
diff --git a/Kernel/sound/soc/codecs/victory/wm8994_voodoo.h b/Kernel/sound/soc/codecs/victory/wm8994_voodoo.h
new file mode 100644
index 0000000..578f8e8
--- /dev/null
+++ b/Kernel/sound/soc/codecs/victory/wm8994_voodoo.h
@@ -0,0 +1,67 @@
+/*
+ * wm8994.h  --  WM8994 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define VOODOO_SOUND_VERSION 10
+
+#if defined(CONFIG_MACH_HERRING) || defined (CONFIG_SAMSUNG_GALAXYS)	       \
+	|| defined (CONFIG_SAMSUNG_GALAXYSB)				       \
+	|| defined (CONFIG_SAMSUNG_CAPTIVATE)				       \
+	|| defined (CONFIG_SAMSUNG_VIBRANT)				       \
+	|| defined (CONFIG_SAMSUNG_FASCINATE)				       \
+	|| defined (CONFIG_SAMSUNG_EPIC)
+#define NEXUS_S
+#endif
+
+#if defined(CONFIG_FB_S3C_AMS701KA) || defined(CONFIG_KOR_MODEL_M180S)
+#define GALAXY_TAB
+#endif
+
+#ifdef CONFIG_M110S
+#define M110S
+#endif
+
+#ifdef CONFIG_MACH_SAMSUNG_VARIATION_TEGRA
+#define GALAXY_TAB_TEGRA
+#endif
+
+#ifdef CONFIG_TDMB_T3700
+#define M110S
+#endif
+
+enum debug_log { LOG_OFF, LOG_INFOS, LOG_VERBOSE };
+bool debug_log(short unsigned int level);
+
+enum unified_path { HEADPHONES, RADIO_HEADPHONES, SPEAKER, MAIN_MICROPHONE };
+
+bool is_path(int unified_path);
+bool is_path_media_or_fm_no_call_no_record(void);
+unsigned int voodoo_hook_wm8994_write(struct snd_soc_codec *codec,
+				      unsigned int reg, unsigned int value);
+void voodoo_hook_fmradio_headset(void);
+void voodoo_hook_wm8994_pcm_probe(struct snd_soc_codec *codec);
+void voodoo_hook_wm8994_pcm_remove(void);
+void voodoo_hook_record_main_mic(void);
+void voodoo_hook_playback_speaker(void);
+
+void load_current_eq_values(void);
+void apply_saturation_prevention_drc(void);
+
+void update_hpvol(bool with_fade);
+void update_fm_radio_headset_restore_freqs(bool with_mute);
+void update_fm_radio_headset_normalize_gain(bool with_mute);
+void update_recording_preset(bool with_mute);
+void update_full_bitwidth(bool with_mute);
+void update_osr128(bool with_mute);
+void update_fll_tuning(bool with_mute);
+void update_mono_downmix(bool with_mute);
+void update_dac_direct(bool with_mute);
+void update_digital_gain(bool with_mute);
+void update_stereo_expansion(bool with_mute);
+void update_headphone_eq(bool update_bands);
+void update_headphone_eq_bands(void);
+void update_enable(void);
diff --git a/Kernel/sound/soc/codecs/wm8994_aries.c.orig b/Kernel/sound/soc/codecs/wm8994_aries.c.orig
new file mode 100644
index 0000000..c93de2a
--- /dev/null
+++ b/Kernel/sound/soc/codecs/wm8994_aries.c.orig
@@ -0,0 +1,3007 @@
+/*
+ * wm8994_crespo.c  --  WM8994 ALSA Soc Audio driver related Aries
+ *
+ *  Copyright (C) 2010 Samsung Electronics.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <plat/gpio-cfg.h>
+#include <plat/map-base.h>
+#include <mach/regs-clock.h>
+#include "wm8994_samsung.h"
+#ifdef CONFIG_SND_VOODOO 
+#include "wm8994_voodoo.h" 
+#endif 
+
+/*
+ * Debug Feature
+ */
+#define SUBJECT "wm8994_crespo.c"
+
+#ifdef FEATURE_SS_AUDIO_CAL
+extern unsigned int tty_mode;
+extern unsigned int loopback_mode;
+#endif
+
+/*
+ * Definitions of tunning volumes for wm8994
+ */
+struct gain_info_t playback_gain_table[PLAYBACK_GAIN_NUM] = {
+	{ /* COMMON */
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC1_LEFT_VOLUME,	/* 610h */
+		.mask = WM8994_DAC1L_VOL_MASK,
+		.gain = WM8994_DAC1_VU | 0xC0
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC1_RIGHT_VOLUME,	/* 611h */
+		.mask = WM8994_DAC1R_VOL_MASK,
+		.gain = WM8994_DAC1_VU | 0xC0
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_AIF1_DAC1_LEFT_VOLUME,	/* 402h */
+		.mask = WM8994_AIF1DAC1L_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xC0
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_AIF1_DAC1_RIGHT_VOLUME,	/* 403h */
+		.mask = WM8994_AIF1DAC1R_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xC0
+	}, { /* RCV */
+		.mode = PLAYBACK_RCV,
+		.reg  = WM8994_OUTPUT_MIXER_5,		/* 31h */
+		.mask = WM8994_DACL_MIXOUTL_VOL_MASK,
+		.gain = 0x0 << WM8994_DACL_MIXOUTL_VOL_SHIFT
+	}, {
+		.mode = PLAYBACK_RCV,
+		.reg  = WM8994_OUTPUT_MIXER_6,		/* 32h */
+		.mask = WM8994_DACR_MIXOUTR_VOL_MASK,
+		.gain = 0x0 << WM8994_DACR_MIXOUTR_VOL_SHIFT
+	}, {
+		.mode = PLAYBACK_RCV,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x3D
+	}, {
+		.mode = PLAYBACK_RCV,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x3D
+	}, {
+		.mode = PLAYBACK_RCV,
+		.reg  = WM8994_HPOUT2_VOLUME,		/* 1Fh */
+		.mask = WM8994_HPOUT2_VOL_MASK,
+		.gain = 0x0 << WM8994_HPOUT2_VOL_SHIFT
+	}, { /* SPK */
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_SPKMIXL_ATTENUATION,	/* 22h */
+		.mask = WM8994_SPKMIXL_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_SPKMIXR_ATTENUATION,	/* 23h */
+		.mask = WM8994_SPKMIXR_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3E     /* +5dB */
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_SPEAKER_VOLUME_RIGHT,	/* 27h */
+		.mask = WM8994_SPKOUTR_VOL_MASK,
+		.gain = 0
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_CLASSD,			/* 25h */
+		.mask = WM8994_SPKOUTL_BOOST_MASK,
+		.gain = 0x05 << WM8994_SPKOUTL_BOOST_SHIFT  /* +7.5dB */
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_AIF1_DAC1_LEFT_VOLUME,	/* 402h */
+		.mask = WM8994_AIF1DAC1L_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xB8           /* -2.625dB */
+	}, {
+		.mode = PLAYBACK_SPK,
+		.reg  = WM8994_AIF1_DAC1_RIGHT_VOLUME,	/* 403h */
+		.mask = WM8994_AIF1DAC1R_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xB8           /* -2.625dB */
+	}, { /* HP */
+		.mode = PLAYBACK_HP,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31 /* -8dB */
+	}, {
+		.mode = PLAYBACK_HP,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31 /* -8dB */
+	}, {
+		.mode = PLAYBACK_HP,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = PLAYBACK_HP,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, { /* SPK_HP */
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_SPKMIXL_ATTENUATION,	/* 22h */
+		.mask = WM8994_SPKMIXL_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_SPKMIXR_ATTENUATION,	/* 23h */
+		.mask = WM8994_SPKMIXR_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3E
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_SPEAKER_VOLUME_RIGHT,	/* 27h */
+		.mask = WM8994_SPKOUTR_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_CLASSD,			/* 25h */
+		.mask = WM8994_SPKOUTL_BOOST_MASK,
+		.gain = 0x5 << WM8994_SPKOUTL_BOOST_SHIFT
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x1E
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x1E
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = PLAYBACK_SPK_HP,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, { /* RING_SPK */
+		.mode = PLAYBACK_RING_SPK,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3E
+	}, {
+		.mode = PLAYBACK_RING_SPK,
+		.reg  = WM8994_CLASSD,			/* 25h */
+		.mask = WM8994_SPKOUTL_BOOST_MASK,
+		.gain = 0x5 << WM8994_SPKOUTL_BOOST_SHIFT
+	}, { /* RING_HP */
+		.mode = PLAYBACK_RING_HP,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x34
+	}, {
+		.mode = PLAYBACK_RING_HP,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x34
+	}, {
+		.mode = PLAYBACK_RING_HP,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = PLAYBACK_RING_HP,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, { /* RING_SPK_HP */
+		.mode = PLAYBACK_RING_SPK_HP,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3E
+	}, {
+		.mode = PLAYBACK_RING_SPK_HP,
+		.reg  = WM8994_CLASSD,			/* 25h */
+		.mask = WM8994_SPKOUTL_BOOST_MASK,
+		.gain = 0x5 << WM8994_SPKOUTL_BOOST_SHIFT
+	}, {
+		.mode = PLAYBACK_RING_SPK_HP,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x1E
+	}, {
+		.mode = PLAYBACK_RING_SPK_HP,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x1E
+	}, { /* HP_NO_MIC */
+		.mode = PLAYBACK_HP_NO_MIC,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,  /* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x36   /* -3dB */
+	}, {
+		.mode = PLAYBACK_HP_NO_MIC,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME, /* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x36   /* -3dB */
+	}, {
+		.mode = PLAYBACK_HP_NO_MIC,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = PLAYBACK_HP_NO_MIC,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,   /* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+    },
+};
+
+struct gain_info_t voicecall_gain_table[VOICECALL_GAIN_NUM] = {
+	{ /* COMMON */
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC1_LEFT_VOLUME,	/* 610h */
+		.mask = WM8994_DAC1L_VOL_MASK,
+		.gain = WM8994_DAC1_VU | 0xC0     /* 0dB */
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC1_RIGHT_VOLUME,	/* 611h */
+		.mask = WM8994_DAC1R_VOL_MASK,
+		.gain = WM8994_DAC1_VU | 0xC0     /* 0dB */
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_AIF1_DAC1_LEFT_VOLUME,	/* 402h */
+		.mask = WM8994_AIF1DAC1L_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xC0   /* 0dB */
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_AIF1_DAC1_RIGHT_VOLUME,	/* 403h */
+		.mask = WM8994_AIF1DAC1R_VOL_MASK,
+		.gain = WM8994_AIF1DAC1_VU | 0xC0     /* 0dB */
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC2_LEFT_VOLUME,	/* 612h */
+		.mask = WM8994_DAC2L_VOL_MASK,
+		.gain = WM8994_DAC2_VU | 0xC0         /* 0dB */
+	}, {
+		.mode = COMMON_SET_BIT,
+		.reg  = WM8994_DAC2_RIGHT_VOLUME,	/* 613h */
+		.mask = WM8994_DAC2R_VOL_MASK,
+		.gain = WM8994_DAC2_VU | 0xC0         /* 0dB */
+	}, { /* RCV */
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x15   /* +15dB */
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10                    /* +30dB */
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_OUTPUT_MIXER_5,		/* 31h */
+		.mask = WM8994_DACL_MIXOUTL_VOL_MASK,
+		.gain = 0x0 << WM8994_DACL_MIXOUTL_VOL_SHIFT
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_OUTPUT_MIXER_6,		/* 32h */
+		.mask = WM8994_DACR_MIXOUTR_VOL_MASK,
+		.gain = 0x0 << WM8994_DACR_MIXOUTR_VOL_SHIFT
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x3F
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x3F
+	}, {
+		.mode = VOICECALL_RCV,
+		.reg  = WM8994_HPOUT2_VOLUME,		/* 1Fh */
+		.mask = WM8994_HPOUT2_VOL_MASK,
+		.gain = 0x0 << WM8994_HPOUT2_VOL_SHIFT
+	}, { /* SPK */
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10     /* Mic +7.5dB */
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x12   /* Mic +30dB */
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_SPKMIXL_ATTENUATION,	/* 22h */
+		.mask = WM8994_SPKMIXL_VOL_MASK,
+		.gain = 0x0     /* Speaker +0dB */
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_SPKMIXR_ATTENUATION,	/* 23h */
+		.mask = WM8994_SPKMIXR_VOL_MASK,
+		.gain = 0x0     /* Speaker +0dB */
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3C    /* Left Speaker +3dB */
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_SPEAKER_VOLUME_RIGHT,	/* 27h */
+		.mask = WM8994_SPKOUTR_VOL_MASK,   /* Right Speaker -57dB */
+		.gain = 0x0
+	}, {
+		.mode = VOICECALL_SPK,
+		.reg  = WM8994_CLASSD,			/* 25h */
+		.mask = WM8994_SPKOUTL_BOOST_MASK,
+		.gain = 0x7 << WM8994_SPKOUTL_BOOST_SHIFT /* Left spaker +12dB */
+	}, { /* HP */
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,	/* 1Ah */
+		.mask = WM8994_IN1R_VOL_MASK,
+		.gain = WM8994_IN1R_VU | 0x1D
+	}, {
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_INPUT_MIXER_4,		/* 2Ah */
+		.mask = WM8994_IN1R_MIXINR_VOL_MASK | WM8994_MIXOUTR_MIXINR_VOL_MASK,
+		.gain = 0x0
+	}, {
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x30
+	}, {
+		.mode = VOICECALL_HP,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x30
+	}, { /* HP_NO_MIC */
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x12	/* +10.5dB */
+	}, {
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10
+	}, {
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_LEFT_OPGA_VOLUME,	/* 20h */
+		.mask = WM8994_MIXOUTL_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_RIGHT_OPGA_VOLUME,	/* 21h */
+		.mask = WM8994_MIXOUTR_VOL_MASK,
+		.gain = WM8994_MIXOUT_VU | 0x39
+	}, {
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x30
+	}, {
+		.mode = VOICECALL_HP_NO_MIC,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME, /* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x30
+	}
+
+};
+
+struct gain_info_t recording_gain_table[RECORDING_GAIN_NUM] = {
+	{ /* MAIN */
+		.mode = RECORDING_MAIN,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x12    /* +10.5dB */
+	}, {
+		.mode = RECORDING_MAIN,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10                /* +30dB */
+	}, {
+		.mode = RECORDING_MAIN,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0       /* 0dB */
+	}, {
+		.mode = RECORDING_MAIN,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0       /* 0dB */
+	}, { /* HP */
+		.mode = RECORDING_HP,
+		.reg  = WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,	/* 1Ah */
+		.mask = WM8994_IN1R_VOL_MASK,
+		.gain = WM8994_IN1R_VU | 0x15
+	}, {
+		.mode = RECORDING_HP,
+		.reg  = WM8994_INPUT_MIXER_4,		/* 2Ah */
+		.mask = WM8994_IN1R_MIXINR_VOL_MASK | WM8994_MIXOUTR_MIXINR_VOL_MASK,
+		.gain = 0x10
+	}, {
+		.mode = RECORDING_HP,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	}, {
+		.mode = RECORDING_HP,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	}, { /* RECOGNITION_MAIN */
+		.mode = RECORDING_REC_MAIN,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x0D /* +3dB */
+	}, {
+		.mode = RECORDING_REC_MAIN,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10  /* 30dB */
+	}, {
+		.mode = RECORDING_REC_MAIN,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xc0   /* +0dB */
+	}, {
+		.mode = RECORDING_REC_MAIN,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xc0   /* +0dB */
+	}, { /* RECOGNITION_HP */
+		.mode = RECORDING_REC_HP,
+		.reg  = WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,	/* 1Ah */
+		.mask = WM8994_IN1R_VOL_MASK,
+		.gain = WM8994_IN1R_VU | 0x12    /* +10.5dB */
+	}, {
+		.mode = RECORDING_REC_HP,
+		.reg  = WM8994_INPUT_MIXER_4,		/* 2Ah */
+		.mask = WM8994_IN1R_MIXINR_VOL_MASK | WM8994_MIXOUTR_MIXINR_VOL_MASK,
+		.gain = 0x10   /* +30dB */
+	}, {
+		.mode = RECORDING_REC_HP,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	}, {
+		.mode = RECORDING_REC_HP,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	}, { /* CAMCORDER_MAIN */
+		.mode = RECORDING_CAM_MAIN,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x17    /* +18dB */
+	}, {
+		.mode = RECORDING_CAM_MAIN,
+		.reg  = WM8994_INPUT_MIXER_3,		/* 29h */
+		.mask = WM8994_IN1L_MIXINL_VOL_MASK | WM8994_MIXOUTL_MIXINL_VOL_MASK,
+		.gain = 0x10  /* 30dB */
+	}, {
+		.mode = RECORDING_CAM_MAIN,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0   /* +0dB */
+	}, {
+		.mode = RECORDING_CAM_MAIN,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0   /* +0dB */
+	}, { /* CAMCORDER_HP */
+		.mode = RECORDING_CAM_HP,
+		.reg  = WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,	/* 1Ah */
+		.mask = WM8994_IN1R_VOL_MASK,
+		.gain = WM8994_IN1R_VU | 0x15    /* +15dB */
+	}, {
+		.mode = RECORDING_CAM_HP,
+		.reg  = WM8994_INPUT_MIXER_4,		/* 2Ah */
+		.mask = WM8994_IN1R_MIXINR_VOL_MASK | WM8994_MIXOUTR_MIXINR_VOL_MASK,
+		.gain = 0x10   /* +30dB */
+	}, {
+		.mode = RECORDING_CAM_HP,
+		.reg  = WM8994_AIF1_ADC1_LEFT_VOLUME,	/* 400h */
+		.mask = WM8994_AIF1ADC1L_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	}, {
+		.mode = RECORDING_CAM_HP,
+		.reg  = WM8994_AIF1_ADC1_RIGHT_VOLUME,	/* 401h */
+		.mask = WM8994_AIF1ADC1R_VOL_MASK,
+		.gain = WM8994_AIF1ADC1_VU | 0xC0
+	},
+};
+
+struct gain_info_t gain_code_table[GAIN_CODE_NUM] = {
+	/* Playback */
+	{/* HP */
+		.mode = PLAYBACK_HP | PLAYBACK_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31		/* -8dB */
+	}, {
+		.mode = PLAYBACK_HP | PLAYBACK_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31		/* -8dB */
+	}, {/* HP_NO_MIC */
+		.mode = PLAYBACK_HP_NO_MIC | PLAYBACK_MODE | GAIN_DIVISION_BIT,
+	        .reg  = WM8994_LEFT_OUTPUT_VOLUME,  /* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31	 /* -8dB */
+	}, {
+		.mode = PLAYBACK_HP_NO_MIC | PLAYBACK_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME, /* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x31	 /* -8dB */
+	},	{/* Voicecall RCV */
+		.mode = VOICECALL_RCV | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x14		/* +13.5dB */
+	}, {/* SPK */
+		.mode = VOICECALL_SPK | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x0D		/* +3dB */
+	}, {
+		.mode = VOICECALL_SPK | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_SPEAKER_VOLUME_LEFT,	/* 26h */
+		.mask = WM8994_SPKOUTL_VOL_MASK,
+		.gain = WM8994_SPKOUT_VU | 0x3A		/* +1dB */
+	}, {/* HP */
+		.mode = VOICECALL_HP | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,	/* 1Ah */
+		.mask = WM8994_IN1R_VOL_MASK,
+		.gain = WM8994_IN1R_VU | 0x1D		/* +27dB */
+	}, {
+		.mode = VOICECALL_HP | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x3a		/* +1dB */
+	}, {
+		.mode = VOICECALL_HP | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x3a		/* +1dB */
+	}, {/* HP_NO_MIC */
+		.mode = VOICECALL_HP_NO_MIC | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_LINE_INPUT_1_2_VOLUME,	/* 18h */
+		.mask = WM8994_IN1L_VOL_MASK,
+		.gain = WM8994_IN1L_VU | 0x12	/* +10.5dB */
+	}, {
+		.mode = VOICECALL_HP_NO_MIC | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_LEFT_OUTPUT_VOLUME,	/* 1Ch */
+		.mask = WM8994_HPOUT1L_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x3a		/* +1dB */
+	}, {
+		.mode = VOICECALL_HP_NO_MIC | VOICECALL_MODE | GAIN_DIVISION_BIT,
+		.reg  = WM8994_RIGHT_OUTPUT_VOLUME,	/* 1Dh */
+		.mask = WM8994_HPOUT1R_VOL_MASK,
+		.gain = WM8994_HPOUT1_VU | 0x3a		/* +1dB */
+	},
+};
+
+static void wait_for_dc_servo(struct snd_soc_codec *codec, unsigned int op)
+{
+        unsigned int reg;
+        int count = 0;
+        unsigned int val, start;
+
+        val = op | WM8994_DCS_ENA_CHAN_0 | WM8994_DCS_ENA_CHAN_1;
+
+        /* Trigger the command */
+        snd_soc_write(codec, WM8994_DC_SERVO_1, val);
+
+	start = jiffies;
+        pr_debug("Waiting for DC servo...\n");
+
+        do {
+                count++;
+                msleep(1);
+                reg = snd_soc_read(codec, WM8994_DC_SERVO_1);
+                pr_debug("DC servo: %x\n", reg);
+        } while (reg & op && count < 400);
+
+	pr_info("DC servo took %dms\n", jiffies_to_msecs(jiffies - start));
+
+        if (reg & op)
+                pr_err("Timed out waiting for DC Servo\n");
+}
+
+/* S5P_SLEEP_CONFIG must be controlled by codec if codec use XUSBTI */
+int wm8994_configure_clock(struct snd_soc_codec *codec, int en)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	if (en) {
+		clk_enable(wm8994->codec_clk);
+		DEBUG_LOG("USBOSC Enabled in Sleep Mode\n");
+	} else {
+		clk_disable(wm8994->codec_clk);
+		DEBUG_LOG("USBOSC disable in Sleep Mode\n");
+	}
+
+	return 0;
+}
+
+void audio_ctrl_mic_bias_gpio(struct wm8994_platform_data *pdata, int enable)
+{
+	DEBUG_LOG("enable = [%d]", enable);
+
+	if (!pdata)
+		pr_err("failed to turn off micbias pin\n");
+	else {
+		if (enable)
+			pdata->set_mic_bias(true);
+		else
+			pdata->set_mic_bias(false);
+	}
+}
+
+static int wm8994_earsel_control(struct wm8994_platform_data *pdata, int en)
+{
+
+	if (!pdata) {
+		pr_err("failed to control wm8994 ear selection\n");
+		return -EINVAL;
+	}
+
+	gpio_set_value(pdata->ear_sel, en);
+
+	return 0;
+
+}
+
+/* Audio Routing routines for the universal board..wm8994 codec*/
+void wm8994_disable_path(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+	enum audio_path path = wm8994->cur_path;
+
+	DEBUG_LOG("Path = [%d]", path);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+
+	switch (path) {
+	case RCV:
+		/* Disbale the HPOUT2 */
+		val &= ~(WM8994_HPOUT2_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+		/* Disable left MIXOUT */
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+		val &= ~(WM8994_DAC1L_TO_MIXOUTL_MASK);
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+		/* Disable right MIXOUT */
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+		val &= ~(WM8994_DAC1R_TO_MIXOUTR_MASK);
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+		/* Disable HPOUT Mixer */
+		val = wm8994_read(codec, WM8994_HPOUT2_MIXER);
+		val &= ~(WM8994_MIXOUTLVOL_TO_HPOUT2_MASK |
+			WM8994_MIXOUTRVOL_TO_HPOUT2_MASK);
+		wm8994_write(codec, WM8994_HPOUT2_MIXER, val);
+
+		/* Disable mixout volume control */
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+		val &= ~(WM8994_MIXOUTLVOL_ENA_MASK |
+			WM8994_MIXOUTRVOL_ENA_MASK |
+			WM8994_MIXOUTL_ENA_MASK |
+			WM8994_MIXOUTR_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+		break;
+
+	case SPK:
+		/* Disbale the SPKOUTL */
+		val &= ~(WM8994_SPKOUTL_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+		/* Disable SPKLVOL */
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+		val &= ~(WM8994_SPKLVOL_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+
+		/* Disable SPKOUT mixer */
+		val = wm8994_read(codec, WM8994_SPKOUT_MIXERS);
+		val &= ~(WM8994_SPKMIXL_TO_SPKOUTL_MASK |
+			 WM8994_SPKMIXR_TO_SPKOUTL_MASK |
+			 WM8994_SPKMIXR_TO_SPKOUTR_MASK);
+		wm8994_write(codec, WM8994_SPKOUT_MIXERS, val);
+
+		/* Mute Speaker mixer */
+		val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+		val &= ~(WM8994_DAC1L_TO_SPKMIXL_MASK);
+		wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+		break;
+
+	case HP:
+	case HP_NO_MIC:
+		val = wm8994_read(codec, WM8994_DAC1_LEFT_VOLUME);
+		val &= ~(0x02C0);
+		val |= 0x02C0;
+		wm8994_write(codec, WM8994_DAC1_LEFT_VOLUME, 0x02C0);
+
+		val = wm8994_read(codec, WM8994_DAC1_RIGHT_VOLUME);
+		val &= ~(0x02C0);
+		val |= 0x02C0;
+		wm8994_write(codec, WM8994_DAC1_RIGHT_VOLUME, 0x02C0);
+
+		val = wm8994_read(codec, WM8994_ANALOGUE_HP_1);
+		val &= ~(0x0022);
+		val |= 0x0022;
+		wm8994_write(codec, WM8994_ANALOGUE_HP_1, 0x0022);
+
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+		val &= ~(0x0);
+		val |= 0x0;
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_1, 0x0);
+
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+		val &= ~(0x0);
+		val |= 0x0;
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_2, 0x0);
+
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+		val &= ~(0x0300);
+		val |= 0x0300;
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, 0x0300);
+
+		val = wm8994_read(codec, WM8994_CHARGE_PUMP_1);
+		val &= ~(0x1F25);
+		val |= 0x1F25;
+		wm8994_write(codec, WM8994_CHARGE_PUMP_1, 0x1F25);
+		break;
+
+	case BT:
+		val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+		val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+		val |= (WM8994_AIF1DAC1_MUTE);
+		wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+		break;
+
+	case SPK_HP:
+		val &= ~(WM8994_HPOUT1L_ENA_MASK | WM8994_HPOUT1R_ENA_MASK |
+				WM8994_SPKOUTL_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+		/* Disable DAC1L to HPOUT1L path */
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+		val &= ~(WM8994_DAC1L_TO_HPOUT1L_MASK |
+				WM8994_DAC1L_TO_MIXOUTL_MASK);
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+		/* Disable DAC1R to HPOUT1R path */
+		val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+		val &= ~(WM8994_DAC1R_TO_HPOUT1R_MASK |
+				WM8994_DAC1R_TO_MIXOUTR_MASK);
+		wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+		/* Disable Charge Pump */
+		val = wm8994_read(codec, WM8994_CHARGE_PUMP_1);
+		val &= ~WM8994_CP_ENA_MASK;
+		val |= WM8994_CP_ENA_DEFAULT;
+		wm8994_write(codec, WM8994_CHARGE_PUMP_1, val);
+
+		/* Intermediate HP settings */
+		val = wm8994_read(codec, WM8994_ANALOGUE_HP_1);
+		val &= ~(WM8994_HPOUT1R_DLY_MASK | WM8994_HPOUT1R_OUTP_MASK |
+		      WM8994_HPOUT1R_RMV_SHORT_MASK | WM8994_HPOUT1L_DLY_MASK |
+		      WM8994_HPOUT1L_OUTP_MASK | WM8994_HPOUT1L_RMV_SHORT_MASK);
+		wm8994_write(codec, WM8994_ANALOGUE_HP_1, val);
+
+		/* Disable SPKLVOL */
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+		val &= ~(WM8994_SPKLVOL_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+
+		/* Disable SPKOUT mixer */
+		val = wm8994_read(codec, WM8994_SPKOUT_MIXERS);
+		val &= ~(WM8994_SPKMIXL_TO_SPKOUTL_MASK |
+			 WM8994_SPKMIXR_TO_SPKOUTL_MASK |
+			 WM8994_SPKMIXR_TO_SPKOUTR_MASK);
+		wm8994_write(codec, WM8994_SPKOUT_MIXERS, val);
+
+		/* Mute Speaker mixer */
+		val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+		val &= ~(WM8994_DAC1L_TO_SPKMIXL_MASK);
+		wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+		break;
+
+	default:
+		DEBUG_LOG_ERR("Path[%d] is not invaild!\n", path);
+		return;
+		break;
+	}
+}
+
+void wm8994_disable_rec_path(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+	enum mic_path mic = wm8994->rec_path;
+
+	wm8994->rec_path = MIC_OFF;
+
+	if (!(wm8994->codec_state & CALL_ACTIVE))
+		audio_ctrl_mic_bias_gpio(wm8994->pdata, 0);
+
+	switch (mic) {
+	case MAIN:
+		DEBUG_LOG("Disabling MAIN Mic Path..\n");
+
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_2);
+		val &= ~(WM8994_IN1L_ENA_MASK | WM8994_MIXINL_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, val);
+
+		/* Mute IN1L PGA, update volume */
+		val = wm8994_read(codec,
+				WM8994_LEFT_LINE_INPUT_1_2_VOLUME);
+		val &= ~(WM8994_IN1L_MUTE_MASK | WM8994_IN1L_VOL_MASK);
+		val |= (WM8994_IN1L_VU | WM8994_IN1L_MUTE);
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME,
+				val);
+
+		/*Mute the PGA */
+		val = wm8994_read(codec, WM8994_INPUT_MIXER_3);
+		val &= ~(WM8994_IN1L_TO_MIXINL_MASK |
+			WM8994_IN1L_MIXINL_VOL_MASK |
+			WM8994_MIXOUTL_MIXINL_VOL_MASK);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3, val);
+
+		/* Disconnect IN1LN ans IN1LP to the inputs */
+		val = wm8994_read(codec, WM8994_INPUT_MIXER_2);
+		val &= (WM8994_IN1LN_TO_IN1L_MASK | WM8994_IN1LP_TO_IN1L_MASK);
+		wm8994_write(codec, WM8994_INPUT_MIXER_2, val);
+
+		/* Digital Paths */
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+		val &= ~(WM8994_ADCL_ENA_MASK | WM8994_AIF1ADC1L_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_4, val);
+
+		/* Disable timeslots */
+		val = wm8994_read(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING);
+		val &= ~(WM8994_ADC1L_TO_AIF1ADC1L);
+		wm8994_write(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING, val);
+		break;
+
+	case SUB:
+		DEBUG_LOG("Disbaling SUB Mic path..\n");
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_2);
+		val &= ~(WM8994_IN1R_ENA_MASK | WM8994_MIXINR_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, val);
+
+		/* Disable volume,unmute Right Line */
+		val = wm8994_read(codec,
+				WM8994_RIGHT_LINE_INPUT_1_2_VOLUME);
+		val &= ~WM8994_IN1R_MUTE_MASK;	/* Unmute IN1R */
+		val |= (WM8994_IN1R_VU | WM8994_IN1R_MUTE);
+		wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_1_2_VOLUME,
+			     val);
+
+		/* Mute right pga, set volume */
+		val = wm8994_read(codec, WM8994_INPUT_MIXER_4);
+		val &= ~(WM8994_IN1R_TO_MIXINR_MASK |
+		      WM8994_IN1R_MIXINR_VOL_MASK |
+		      WM8994_MIXOUTR_MIXINR_VOL_MASK);
+		wm8994_write(codec, WM8994_INPUT_MIXER_4, val);
+
+		/* Disconnect in1rn to inr1 and in1rp to inrp */
+		val = wm8994_read(codec, WM8994_INPUT_MIXER_2);
+		val &= ~(WM8994_IN1RN_TO_IN1R_MASK | WM8994_IN1RP_TO_IN1R_MASK);
+		wm8994_write(codec, WM8994_INPUT_MIXER_2, val);
+
+		/* Digital Paths */
+		/* Disable right ADC and time slot */
+		val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+		val &= ~(WM8994_ADCR_ENA_MASK | WM8994_AIF1ADC1R_ENA_MASK);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_4, val);
+
+		/* ADC Right mixer routing */
+		val = wm8994_read(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING);
+		val &= ~(WM8994_ADC1R_TO_AIF1ADC1R_MASK);
+		wm8994_write(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING, val);
+		break;
+
+	case BT_REC:
+		DEBUG_LOG("Disbaling BT Mic path..\n");
+		val = wm8994_read(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING);
+		val &= ~(WM8994_AIF2DACL_TO_AIF1ADC1L_MASK |
+			WM8994_ADC1L_TO_AIF1ADC1L_MASK);
+		wm8994_write(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING, val);
+
+		val = wm8994_read(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING);
+		val &= ~(WM8994_AIF2DACR_TO_AIF1ADC1R_MASK |
+			WM8994_ADC1R_TO_AIF1ADC1R_MASK);
+		wm8994_write(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING, val);
+
+		val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+		val &= ~(WM8994_AIF2DAC_MUTE_MASK);
+		val |= (WM8994_AIF2DAC_MUTE);
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+		break;
+
+	case MIC_OFF:
+		DEBUG_LOG("Mic is already OFF!\n");
+		break;
+
+	default:
+		DEBUG_LOG_ERR("Path[%d] is not invaild!\n", mic);
+		break;
+	}
+}
+
+void wm8994_set_bluetooth_common_setting(struct snd_soc_codec *codec)
+{
+	u32 val;
+
+	wm8994_write(codec, WM8994_GPIO_1, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_2, 0x8100);
+	wm8994_write(codec, WM8994_GPIO_3, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_4, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_5, 0x8100);
+	wm8994_write(codec, WM8994_GPIO_6, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_7, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_8, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_9, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_10, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_11, 0xA101);
+
+	wm8994_write(codec, WM8994_FLL2_CONTROL_2, 0x0700);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_3, 0x3126);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_4, 0x0100);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_5, 0x0C88);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_1,
+		WM8994_FLL2_FRACN_ENA | WM8994_FLL2_ENA);
+
+	val = wm8994_read(codec, WM8994_AIF2_CLOCKING_1);
+	if (!(val & WM8994_AIF2CLK_ENA))
+		wm8994_write(codec, WM8994_AIF2_CLOCKING_1, 0x0018);
+
+	wm8994_write(codec, WM8994_AIF2_RATE, 0x9 << WM8994_AIF2CLK_RATE_SHIFT);
+
+	/* AIF2 Interface - PCM Stereo mode */
+	/* Left Justified, BCLK invert, LRCLK Invert */
+	wm8994_write(codec, WM8994_AIF2_CONTROL_1,
+		WM8994_AIF2ADCR_SRC | WM8994_AIF2_BCLK_INV | 0x18);
+
+	wm8994_write(codec, WM8994_AIF2_BCLK, 0x70);
+	wm8994_write(codec, WM8994_AIF2_CONTROL_2, 0x0000);
+	wm8994_write(codec, WM8994_AIF2_MASTER_SLAVE, WM8994_AIF2_MSTR |
+		WM8994_AIF2_CLK_FRC | WM8994_AIF2_LRCLK_FRC);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK |
+		WM8994_AIF1DAC1L_ENA_MASK | WM8994_AIF1DAC1R_ENA_MASK |
+		WM8994_DAC1L_ENA_MASK | WM8994_DAC1R_ENA_MASK);
+	val |= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA |
+		WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+		WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	/* Clocking */
+	val = wm8994_read(codec, WM8994_CLOCKING_1);
+	val |= (WM8994_DSP_FS2CLK_ENA | WM8994_SYSCLK_SRC);
+	wm8994_write(codec, WM8994_CLOCKING_1, val);
+
+	/* AIF1 & AIF2 Output is connected to DAC1 */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK |
+		WM8994_AIF2DACL_TO_DAC1L_MASK);
+	val |= (WM8994_AIF1DAC1L_TO_DAC1L | WM8994_AIF2DACL_TO_DAC1L);
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC1R_MASK |
+		WM8994_AIF2DACR_TO_DAC1R_MASK);
+	val |= (WM8994_AIF1DAC1R_TO_DAC1R | WM8994_AIF2DACR_TO_DAC1R);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING, val);
+}
+
+void wm8994_record_headset_mic(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+
+	DEBUG_LOG("Recording through Headset Mic\n");
+
+	wm8994_write(codec, WM8994_ANTIPOP_2, 0x68);
+
+	/* Enable high pass filter to control bounce on startup */
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_FILTERS);
+	val &= ~(WM8994_AIF1ADC1L_HPF_MASK | WM8994_AIF1ADC1R_HPF_MASK);
+	val |= (WM8994_AIF1ADC1R_HPF);
+	wm8994_write(codec, WM8994_AIF1_ADC1_FILTERS, val);
+
+	/* Enable mic bias, vmid, bias generator */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_1);
+	val &= ~(WM8994_INPUTS_CLAMP_MASK);
+	val |= (WM8994_INPUTS_CLAMP);
+	wm8994_write(codec, WM8994_INPUT_MIXER_1, val);
+
+	val = (WM8994_MIXINR_ENA | WM8994_IN1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, val);
+
+
+	val = (WM8994_IN1RN_TO_IN1R | WM8994_IN1RP_TO_IN1R);
+	wm8994_write(codec, WM8994_INPUT_MIXER_2, val);
+
+	val = wm8994_read(codec, WM8994_RIGHT_LINE_INPUT_1_2_VOLUME);
+	val &= ~(WM8994_IN1R_MUTE_MASK);
+	wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_1_2_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_4);
+	val &= ~(WM8994_IN1R_TO_MIXINR_MASK);
+	val |= (WM8994_IN1R_TO_MIXINR);
+	wm8994_write(codec, WM8994_INPUT_MIXER_4 , val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_1);
+	val &= ~(WM8994_INPUTS_CLAMP_MASK);
+	wm8994_write(codec, WM8994_INPUT_MIXER_1, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_RIGHT_VOLUME);
+	val |= (WM8994_AIF1ADC1_VU);
+	wm8994_write(codec, WM8994_AIF1_ADC1_RIGHT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_FILTERS);
+	val &= ~(WM8994_AIF1ADC1L_HPF_MASK | WM8994_AIF1ADC1R_HPF_MASK);
+	val |= (WM8994_AIF1ADC1R_HPF | 0x2000);
+	wm8994_write(codec, WM8994_AIF1_ADC1_FILTERS, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_MASTER_SLAVE);
+	val |= (WM8994_AIF1_MSTR | WM8994_AIF1_CLK_FRC | WM8994_AIF1_LRCLK_FRC);
+	wm8994_write(codec, WM8994_AIF1_MASTER_SLAVE, val);
+
+	wm8994_write(codec, WM8994_GPIO_1, 0xA101);
+
+	/* Mixing left channel output to right channel */
+	val = wm8994_read(codec, WM8994_AIF1_CONTROL_1);
+	val &= ~(WM8994_AIF1ADCL_SRC_MASK | WM8994_AIF1ADCR_SRC_MASK);
+	val |= (WM8994_AIF1ADCL_SRC | WM8994_AIF1ADCR_SRC);
+	wm8994_write(codec, WM8994_AIF1_CONTROL_1, val);
+
+	/* Digital Paths  */
+	/* Enable right ADC and time slot */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+	val &= ~(WM8994_ADCR_ENA_MASK | WM8994_AIF1ADC1R_ENA_MASK);
+	val |= (WM8994_AIF1ADC1R_ENA | WM8994_ADCR_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_4, val);
+
+
+	/* ADC Right mixer routing */
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1R_TO_AIF1ADC1R_MASK);
+	val |= WM8994_ADC1R_TO_AIF1ADC1R;
+	wm8994_write(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+	val &= ~WM8994_MIXINL_TO_SPKMIXL_MASK;
+	wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+	val &= ~WM8994_MIXINL_TO_MIXOUTL_MASK;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+	val &= ~WM8994_MIXINR_TO_MIXOUTR_MASK;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2L_MASK);
+	wm8994_write(codec, WM8994_DAC2_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2R_MASK);
+	wm8994_write(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING, val);
+
+	if (wm8994->input_source == RECOGNITION)
+		wm8994_set_codec_gain(codec, RECORDING_MODE, RECORDING_REC_HP);
+	else if (wm8994->input_source == CAMCORDER)
+		wm8994_set_codec_gain(codec, RECORDING_MODE, RECORDING_CAM_HP);
+	else
+		wm8994_set_codec_gain(codec, RECORDING_MODE, RECORDING_HP);
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+  voodoo_hook_record_main_mic();
+#endif
+}
+
+void wm8994_record_main_mic(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+
+	DEBUG_LOG("Recording through Main Mic\n");
+	audio_ctrl_mic_bias_gpio(wm8994->pdata, 1);
+
+	/* Main mic volume issue fix: requested H/W */
+	wm8994_write(codec, WM8994_ANTIPOP_2, 0x68);
+
+	/* High pass filter to control bounce on enable */
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_FILTERS);
+	val &= ~(WM8994_AIF1ADC1L_HPF_MASK | WM8994_AIF1ADC1R_HPF_MASK);
+	val |= (WM8994_AIF1ADC1L_HPF);
+	wm8994_write(codec, WM8994_AIF1_ADC1_FILTERS, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_1);
+	val &= ~(WM8994_INPUTS_CLAMP_MASK);
+	val |= (WM8994_INPUTS_CLAMP);
+	wm8994_write(codec, WM8994_INPUT_MIXER_1, val);
+
+	val = (WM8994_MIXINL_ENA | WM8994_IN1L_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, val);
+
+	val = (WM8994_IN1LP_TO_IN1L | WM8994_IN1LN_TO_IN1L);
+	wm8994_write(codec, WM8994_INPUT_MIXER_2, val);
+
+
+	val = wm8994_read(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME);
+	val &= ~(WM8994_IN1L_MUTE_MASK);
+	wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_3);
+	val &= ~(WM8994_IN1L_TO_MIXINL_MASK);
+	val |= (WM8994_IN1L_TO_MIXINL);
+	wm8994_write(codec, WM8994_INPUT_MIXER_3, val);
+
+	val = wm8994_read(codec, WM8994_INPUT_MIXER_1);
+	val &= ~(WM8994_INPUTS_CLAMP_MASK);
+	wm8994_write(codec, WM8994_INPUT_MIXER_1, val);
+
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_LEFT_VOLUME);
+	val |= (WM8994_AIF1ADC1_VU);
+	wm8994_write(codec, WM8994_AIF1_ADC1_LEFT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_FILTERS);
+	val &= ~(WM8994_AIF1ADC1L_HPF_MASK | WM8994_AIF1ADC1R_HPF_MASK);
+	val |= (WM8994_AIF1ADC1L_HPF | 0x2000);
+	wm8994_write(codec, WM8994_AIF1_ADC1_FILTERS, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_MASTER_SLAVE);
+	val |= (WM8994_AIF1_MSTR | WM8994_AIF1_CLK_FRC | WM8994_AIF1_LRCLK_FRC);
+	wm8994_write(codec, WM8994_AIF1_MASTER_SLAVE, val);
+
+	wm8994_write(codec, WM8994_GPIO_1, 0xA101);
+
+	val = wm8994_read(codec, WM8994_AIF1_CONTROL_1);
+	val &= ~(WM8994_AIF1ADCL_SRC_MASK | WM8994_AIF1ADCR_SRC_MASK);
+	val |= (WM8994_AIF1ADCR_SRC);
+	wm8994_write(codec, WM8994_AIF1_CONTROL_1, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+	val &= ~(WM8994_ADCL_ENA_MASK | WM8994_AIF1ADC1L_ENA_MASK);
+	val |= (WM8994_AIF1ADC1L_ENA | WM8994_ADCL_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_4, val);
+
+	/* Enable timeslots */
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING);
+	val |= WM8994_ADC1L_TO_AIF1ADC1L;
+	wm8994_write(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+	val &= ~WM8994_MIXINL_TO_SPKMIXL_MASK;
+	wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+	val &= ~WM8994_MIXINL_TO_MIXOUTL_MASK;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+	val &= ~WM8994_MIXINR_TO_MIXOUTR_MASK;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2L_MASK);
+	wm8994_write(codec, WM8994_DAC2_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2R_MASK);
+	wm8994_write(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING, val);
+
+	if (wm8994->input_source == RECOGNITION)
+		wm8994_set_codec_gain(codec, RECORDING_MODE,
+				RECORDING_REC_MAIN);
+	else if (wm8994->input_source == CAMCORDER)
+		wm8994_set_codec_gain(codec, RECORDING_MODE,
+				RECORDING_CAM_MAIN);
+	else
+		wm8994_set_codec_gain(codec, RECORDING_MODE, RECORDING_MAIN);
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS 
+  voodoo_hook_record_main_mic(); 
+#endif 
+}
+
+void wm8994_record_bluetooth(struct snd_soc_codec *codec)
+{
+	u16 val;
+
+	DEBUG_LOG("BT Record Path for Voice Command\n");
+
+	wm8994_set_bluetooth_common_setting(codec);
+
+	val = wm8994_read(codec, WM8994_DAC2_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2L_MASK);
+	wm8994_write(codec, WM8994_DAC2_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_ADC1_TO_DAC2R_MASK);
+	wm8994_write(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, 0x0000);
+
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, 0x0000);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+	val &= ~(WM8994_AIF1ADC1L_ENA_MASK | WM8994_AIF1ADC1R_ENA_MASK);
+	val |= (WM8994_AIF1ADC1L_ENA | WM8994_AIF1ADC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_4 , val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK);
+	val |= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_6);
+	val &= ~(WM8994_AIF3_ADCDAT_SRC_MASK | WM8994_AIF2_DACDAT_SRC_MASK);
+	val |= (0x1 << WM8994_AIF3_ADCDAT_SRC_SHIFT | WM8994_AIF2_DACDAT_SRC);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_6, val);
+
+	val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+	val &= ~(WM8994_AIF2DAC_MUTE_MASK);
+	wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF2DACL_TO_AIF1ADC1L_MASK);
+	val |= (WM8994_AIF2DACL_TO_AIF1ADC1L);
+	wm8994_write(codec, WM8994_AIF1_ADC1_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF2DACR_TO_AIF1ADC1R_MASK);
+	val |= (WM8994_AIF2DACR_TO_AIF1ADC1R);
+	wm8994_write(codec, WM8994_AIF1_ADC1_RIGHT_MIXER_ROUTING, val);
+
+	wm8994_write(codec, WM8994_AIF2_CLOCKING_1, 0x0019);
+
+	wm8994_write(codec, WM8994_OVERSAMPLING, 0X0000);
+
+	wm8994_write(codec, WM8994_GPIO_8, WM8994_GP8_DIR | WM8994_GP8_DB);
+	wm8994_write(codec, WM8994_GPIO_9, WM8994_GP9_DB);
+	wm8994_write(codec, WM8994_GPIO_10, WM8994_GP10_DB);
+	wm8994_write(codec, WM8994_GPIO_11, WM8994_GP11_DB);
+}
+void wm8994_set_playback_receiver(struct snd_soc_codec *codec)
+{
+	u16 val;
+
+	DEBUG_LOG("");
+
+	val = wm8994_read(codec, WM8994_LEFT_OPGA_VOLUME);
+	val &= ~(WM8994_MIXOUTL_MUTE_N_MASK);
+	val |= (WM8994_MIXOUTL_MUTE_N);
+	wm8994_write(codec, WM8994_LEFT_OPGA_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_RIGHT_OPGA_VOLUME);
+	val &= ~(WM8994_MIXOUTR_MUTE_N_MASK);
+	val |= (WM8994_MIXOUTR_MUTE_N);
+	wm8994_write(codec, WM8994_RIGHT_OPGA_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_HPOUT2_VOLUME);
+	val &= ~(WM8994_HPOUT2_MUTE_MASK);
+	wm8994_write(codec, WM8994_HPOUT2_VOLUME, val);
+
+	/* Unmute DAC1 left */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_VOLUME);
+	val &= ~(WM8994_DAC1L_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_LEFT_VOLUME, val);
+
+	/* Unmute and volume ctrl RightDAC */
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_VOLUME);
+	val &= ~(WM8994_DAC1R_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+	val &= ~(WM8994_DAC1L_TO_MIXOUTL_MASK);
+	val |= (WM8994_DAC1L_TO_MIXOUTL);
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+	val &= ~(WM8994_DAC1R_TO_MIXOUTR_MASK);
+	val |= (WM8994_DAC1R_TO_MIXOUTR);
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+	val = wm8994_read(codec, WM8994_HPOUT2_MIXER);
+	val &= ~(WM8994_MIXOUTLVOL_TO_HPOUT2_MASK |
+			WM8994_MIXOUTRVOL_TO_HPOUT2_MASK);
+	val |= (WM8994_MIXOUTRVOL_TO_HPOUT2 | WM8994_MIXOUTLVOL_TO_HPOUT2);
+	wm8994_write(codec, WM8994_HPOUT2_MIXER, val);
+
+	wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_RCV);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_DAC1R_ENA_MASK | WM8994_DAC1L_ENA_MASK |
+			WM8994_AIF1DAC1R_ENA_MASK | WM8994_AIF1DAC1L_ENA_MASK);
+	val |= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+			WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK);
+	val |= (WM8994_AIF1DAC1L_TO_DAC1L);
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC1R_MASK);
+	val |= (WM8994_AIF1DAC1R_TO_DAC1R);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_CLOCKING_1);
+	val &= ~(WM8994_DSP_FS1CLK_ENA_MASK | WM8994_DSP_FSINTCLK_ENA_MASK);
+	val |= (WM8994_DSP_FS1CLK_ENA | WM8994_DSP_FSINTCLK_ENA);
+	wm8994_write(codec, WM8994_CLOCKING_1, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+	val &= ~(WM8994_MIXOUTLVOL_ENA_MASK | WM8994_MIXOUTRVOL_ENA_MASK |
+	      WM8994_MIXOUTL_ENA_MASK | WM8994_MIXOUTR_ENA_MASK);
+	val |= (WM8994_MIXOUTL_ENA | WM8994_MIXOUTR_ENA |
+			WM8994_MIXOUTRVOL_ENA | WM8994_MIXOUTLVOL_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK |
+			WM8994_HPOUT2_ENA_MASK | WM8994_HPOUT1L_ENA_MASK |
+			WM8994_HPOUT1R_ENA_MASK | WM8994_SPKOUTL_ENA_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL | WM8994_HPOUT2_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+	val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+	val |= (WM8994_AIF1DAC1_UNMUTE | WM8994_AIF1DAC1_MONO);
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+
+}
+
+void wm8994_set_playback_headset(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+
+	u16 testreturn1 = 0;
+	u16 testreturn2 = 0;
+	u16 testlow1 = 0;
+	u16 testhigh1 = 0;
+	u8 testlow = 0;
+	u8 testhigh = 0;
+
+	DEBUG_LOG("");
+
+	wm8994_earsel_control(wm8994->pdata, 0);
+
+	/* Enable the Timeslot0 to DAC1L */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK);
+	val |= WM8994_AIF1DAC1L_TO_DAC1L;
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+	/* Enable the Timeslot0 to DAC1R */
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC1R_MASK);
+	val |= WM8994_AIF1DAC1R_TO_DAC1R;
+	wm8994_write(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, 0x102);
+	val &= ~(0x0003);
+	val = 0x0003;
+	wm8994_write(codec, 0x102, val);
+
+	val = wm8994_read(codec, 0x56);
+	val &= ~(0x0003);
+	val = 0x0003;
+	wm8994_write(codec, 0x56, val);
+
+	val = wm8994_read(codec, 0x102);
+	val &= ~(0x0000);
+	val = 0x0000;
+	wm8994_write(codec, 0x102, val);
+
+	val = wm8994_read(codec, WM8994_CLASS_W_1);
+	val &= ~(0x0005);
+	val |= 0x0005;
+	wm8994_write(codec, WM8994_CLASS_W_1, val);
+
+	val = wm8994_read(codec, WM8994_LEFT_OUTPUT_VOLUME);
+	val &= ~(WM8994_HPOUT1L_MUTE_N_MASK);
+	val |= (WM8994_HPOUT1L_MUTE_N);
+	wm8994_write(codec, WM8994_LEFT_OUTPUT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_RIGHT_OUTPUT_VOLUME);
+	val &= ~(WM8994_HPOUT1R_MUTE_N_MASK);
+	val |= (WM8994_HPOUT1R_MUTE_N);
+	wm8994_write(codec, WM8994_RIGHT_OUTPUT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_LEFT_OPGA_VOLUME);
+	val &= ~(WM8994_MIXOUTL_MUTE_N_MASK);
+	val |= (WM8994_MIXOUTL_MUTE_N);
+	wm8994_write(codec, WM8994_LEFT_OPGA_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_RIGHT_OPGA_VOLUME);
+	val &= ~(WM8994_MIXOUTR_MUTE_N_MASK);
+	val |= (WM8994_MIXOUTR_MUTE_N);
+	wm8994_write(codec, WM8994_RIGHT_OPGA_VOLUME, val);
+
+	if (wm8994->ringtone_active)
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_RING_HP);
+	else if (wm8994->cur_path == HP_NO_MIC)
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_HP_NO_MIC);
+	else
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_HP);
+
+	val = wm8994_read(codec, WM8994_DC_SERVO_2);
+	val &= ~(0x03E0);
+	val = 0x03E0;
+	wm8994_write(codec, WM8994_DC_SERVO_2, val);
+
+	/* Enable vmid,bias, hp left and right */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK |
+		WM8994_HPOUT1L_ENA_MASK | WM8994_HPOUT1R_ENA_MASK |
+		WM8994_SPKOUTR_ENA_MASK | WM8994_SPKOUTL_ENA_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL |
+		WM8994_HPOUT1R_ENA | WM8994_HPOUT1L_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = wm8994_read(codec, WM8994_ANALOGUE_HP_1);
+	val &= ~(0x0022);
+	val = 0x0022;
+	wm8994_write(codec, WM8994_ANALOGUE_HP_1, val);
+
+	/* Enable Charge Pump */
+	/* this is from wolfson */
+	val = wm8994_read(codec, WM8994_CHARGE_PUMP_1);
+	val &= ~WM8994_CP_ENA_MASK ;
+	val |= WM8994_CP_ENA | WM8994_CP_ENA_DEFAULT;
+	wm8994_write(codec, WM8994_CHARGE_PUMP_1, val);
+
+	msleep(5);
+
+	/* Enable Dac1 and DAC2 and the Timeslot0 for AIF1 */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_DAC1R_ENA_MASK | WM8994_DAC1L_ENA_MASK |
+		WM8994_AIF1DAC1R_ENA_MASK | WM8994_AIF1DAC1L_ENA_MASK);
+	val |= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+		WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	/* Enable DAC1L to HPOUT1L path */
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+	val &=  ~(WM8994_DAC1L_TO_HPOUT1L_MASK | WM8994_DAC1L_TO_MIXOUTL_MASK);
+	val |= WM8994_DAC1L_TO_MIXOUTL;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+	/* Enable DAC1R to HPOUT1R path */
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+	val &= ~(WM8994_DAC1R_TO_HPOUT1R_MASK | WM8994_DAC1R_TO_MIXOUTR_MASK);
+	val |= WM8994_DAC1R_TO_MIXOUTR;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+	val &= ~(WM8994_MIXOUTLVOL_ENA_MASK | WM8994_MIXOUTRVOL_ENA_MASK |
+		WM8994_MIXOUTL_ENA_MASK | WM8994_MIXOUTR_ENA_MASK |
+		WM8994_SPKRVOL_ENA_MASK | WM8994_SPKLVOL_ENA_MASK);
+	val |= (WM8994_MIXOUTLVOL_ENA | WM8994_MIXOUTRVOL_ENA |
+		WM8994_MIXOUTL_ENA | WM8994_MIXOUTR_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, 0x0030);
+
+	if (!wm8994->dc_servo[DCS_MEDIA]) {
+		wait_for_dc_servo(codec,
+				  WM8994_DCS_TRIG_SERIES_0 |
+				  WM8994_DCS_TRIG_SERIES_1);
+
+		testreturn1 = wm8994_read(codec, WM8994_DC_SERVO_4);
+
+		testlow = (signed char)(testreturn1 & 0xff);
+		testhigh = (signed char)((testreturn1>>8) & 0xff);
+
+		testlow1 = ((signed short)(testlow-5)) & 0x00ff;
+		testhigh1 = (((signed short)(testhigh-5)<<8) & 0xff00);
+		testreturn2 = testlow1|testhigh1;
+	} else {
+		testreturn2 = wm8994->dc_servo[DCS_MEDIA];
+	}
+
+	wm8994_write(codec, WM8994_DC_SERVO_4, testreturn2);
+	wm8994->dc_servo[DCS_MEDIA] = testreturn2;
+
+	wait_for_dc_servo(codec,
+			  WM8994_DCS_TRIG_DAC_WR_0 | WM8994_DCS_TRIG_DAC_WR_1);
+
+	/* Intermediate HP settings */
+	val = wm8994_read(codec, WM8994_ANALOGUE_HP_1);
+	val &= ~(WM8994_HPOUT1R_DLY_MASK | WM8994_HPOUT1R_OUTP_MASK |
+		WM8994_HPOUT1R_RMV_SHORT_MASK | WM8994_HPOUT1L_DLY_MASK |
+		WM8994_HPOUT1L_OUTP_MASK | WM8994_HPOUT1L_RMV_SHORT_MASK);
+	val = (WM8994_HPOUT1L_RMV_SHORT | WM8994_HPOUT1L_OUTP|
+		WM8994_HPOUT1L_DLY | WM8994_HPOUT1R_RMV_SHORT |
+		WM8994_HPOUT1R_OUTP | WM8994_HPOUT1R_DLY);
+	wm8994_write(codec, WM8994_ANALOGUE_HP_1, val);
+
+	/* Unmute DAC1 left */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_VOLUME);
+	val &= ~(WM8994_DAC1L_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_LEFT_VOLUME, val);
+
+	/* Unmute and volume ctrl RightDAC */
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_VOLUME);
+	val &= ~(WM8994_DAC1R_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_VOLUME, val);
+
+	/* Unmute the AF1DAC1 */
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+	val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+	val |= WM8994_AIF1DAC1_UNMUTE;
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+
+}
+
+void wm8994_set_playback_speaker(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+
+	DEBUG_LOG("");
+
+	/* Disable end point for preventing pop up noise.*/
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_SPKOUTL_ENA_MASK);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+	val &= ~(WM8994_MIXOUTLVOL_ENA_MASK | WM8994_MIXOUTRVOL_ENA_MASK |
+		WM8994_MIXOUTL_ENA_MASK | WM8994_MIXOUTR_ENA_MASK |
+		WM8994_SPKRVOL_ENA_MASK | WM8994_SPKLVOL_ENA_MASK);
+	val |= WM8994_SPKLVOL_ENA;
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+
+	/* Speaker Volume Control */
+	/* Unmute the SPKMIXVOLUME */
+	val = wm8994_read(codec, WM8994_SPEAKER_VOLUME_LEFT);
+	val &= ~(WM8994_SPKOUTL_MUTE_N_MASK);
+	val |= (WM8994_SPKOUTL_MUTE_N);
+	wm8994_write(codec, WM8994_SPEAKER_VOLUME_LEFT, val);
+
+	val = wm8994_read(codec, WM8994_SPEAKER_VOLUME_RIGHT);
+	val &= ~(WM8994_SPKOUTR_MUTE_N_MASK);
+	wm8994_write(codec, WM8994_SPEAKER_VOLUME_RIGHT, val);
+
+	/* Unmute DAC1 left */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_VOLUME);
+	val &= ~(WM8994_DAC1L_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_LEFT_VOLUME, val);
+
+	/* Unmute and volume ctrl RightDAC */
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_VOLUME);
+	val &= ~(WM8994_DAC1R_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_SPKOUT_MIXERS);
+	val &= ~(WM8994_SPKMIXL_TO_SPKOUTL_MASK |
+		 WM8994_SPKMIXR_TO_SPKOUTL_MASK |
+		 WM8994_SPKMIXR_TO_SPKOUTR_MASK);
+	val |= WM8994_SPKMIXL_TO_SPKOUTL;
+	wm8994_write(codec, WM8994_SPKOUT_MIXERS, val);
+
+	/* Unmute the DAC path */
+	val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+	val &= ~(WM8994_DAC1L_TO_SPKMIXL_MASK);
+	val |= WM8994_DAC1L_TO_SPKMIXL;
+	wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+
+	/* Eable DAC1 Left and timeslot left */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_DAC1L_ENA_MASK | WM8994_AIF1DAC1R_ENA_MASK |
+		WM8994_AIF1DAC1L_ENA_MASK);
+	val |= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA | WM8994_DAC1L_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	/* DRC setting */
+	wm8994_write(codec, WM8994_AIF1_DRC1_1, 0x00BC);
+	wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0028);
+	wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x0186);
+
+	/* EQ AIF1 setting */
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1,   0x0019);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2,   0x6280);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_A,  0x0FC3);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_B,  0x03FD);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_PG, 0x00F4);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_A,  0x1F30);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_B,  0xF0CD);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_C,  0x040A);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_PG, 0x032C);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_A,  0x1C52);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_B,  0xF379);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_C,  0x040A);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_PG, 0x0DC1);
+
+	if (wm8994->ringtone_active)
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_RING_SPK);
+	else
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_SPK);
+
+	/* enable timeslot0 to left dac */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK);
+	val |= WM8994_AIF1DAC1L_TO_DAC1L;
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+#ifdef CONFIG_SND_VOODOO
+  voodoo_hook_playback_speaker();
+#endif
+
+	/* Enbale bias,vmid and Left speaker */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK |
+		WM8994_HPOUT1L_ENA_MASK | WM8994_HPOUT1R_ENA_MASK |
+		WM8994_SPKOUTR_ENA_MASK | WM8994_SPKOUTL_ENA_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL | WM8994_SPKOUTL_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	/* Unmute */
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+	val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+	val |= (WM8994_AIF1DAC1_UNMUTE | WM8994_AIF1DAC1_MONO);
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+
+}
+
+void wm8994_set_playback_speaker_headset(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	u16 val;
+
+	u16 nreadservo4val = 0;
+	u16 ncompensationresult = 0;
+	u16 ncompensationresultlow = 0;
+	u16 ncompensationresulthigh = 0;
+	u8  nservo4low = 0;
+	u8  nservo4high = 0;
+
+	wm8994_earsel_control(wm8994->pdata, 0);
+
+	/* Enable the Timeslot0 to DAC1L */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK);
+	val |= WM8994_AIF1DAC1L_TO_DAC1L;
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+	/* Enable the Timeslot0 to DAC1R */
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC1R_MASK);
+	val |= WM8994_AIF1DAC1R_TO_DAC1R;
+	wm8994_write(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING, val);
+
+	/* Speaker Volume Control */
+	val = wm8994_read(codec, WM8994_SPEAKER_VOLUME_LEFT);
+	val &= ~(WM8994_SPKOUTL_MUTE_N_MASK);
+	val |= (WM8994_SPKOUTL_MUTE_N);
+	wm8994_write(codec, WM8994_SPEAKER_VOLUME_LEFT, val);
+
+	val = wm8994_read(codec, WM8994_SPEAKER_VOLUME_RIGHT);
+	val &= ~(WM8994_SPKOUTR_MUTE_N_MASK);
+	wm8994_write(codec, WM8994_SPEAKER_VOLUME_RIGHT, val);
+
+	val = wm8994_read(codec, WM8994_SPKOUT_MIXERS);
+	val &= ~(WM8994_SPKMIXL_TO_SPKOUTL_MASK |
+		WM8994_SPKMIXR_TO_SPKOUTL_MASK |
+		WM8994_SPKMIXR_TO_SPKOUTR_MASK);
+	val |= WM8994_SPKMIXL_TO_SPKOUTL;
+	wm8994_write(codec, WM8994_SPKOUT_MIXERS, val);
+
+	/* Unmute the DAC path */
+	val = wm8994_read(codec, WM8994_SPEAKER_MIXER);
+	val &= ~(WM8994_DAC1L_TO_SPKMIXL_MASK);
+	val |= WM8994_DAC1L_TO_SPKMIXL;
+	wm8994_write(codec, WM8994_SPEAKER_MIXER, val);
+
+	/* Configuring the Digital Paths */
+	val = wm8994_read(codec, 0x102);
+	val &= ~(0x0003);
+	val = 0x0003;
+	wm8994_write(codec, 0x102, val);
+
+	val = wm8994_read(codec, 0x56);
+	val &= ~(0x0003);
+	val = 0x0003;
+	wm8994_write(codec, 0x56, val);
+
+	val = wm8994_read(codec, 0x102);
+	val &= ~(0x0000);
+	val = 0x0000;
+	wm8994_write(codec, 0x102, val);
+
+	val = wm8994_read(codec, WM8994_CLASS_W_1);
+	val &= ~(0x0005);
+	val = 0x0005;
+	wm8994_write(codec, WM8994_CLASS_W_1, val);
+
+	val = wm8994_read(codec, WM8994_LEFT_OUTPUT_VOLUME);
+	val &= ~(WM8994_HPOUT1L_MUTE_N_MASK);
+	val |= (WM8994_HPOUT1L_MUTE_N);
+	wm8994_write(codec, WM8994_LEFT_OUTPUT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_RIGHT_OUTPUT_VOLUME);
+	val &= ~(WM8994_HPOUT1R_MUTE_N_MASK);
+	val |= (WM8994_HPOUT1R_MUTE_N);
+	wm8994_write(codec, WM8994_RIGHT_OUTPUT_VOLUME, val);
+
+	/* DC Servo Series Count */
+	val = 0x03E0;
+	wm8994_write(codec, WM8994_DC_SERVO_2, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK |
+		WM8994_HPOUT1L_ENA_MASK | WM8994_HPOUT1R_ENA_MASK |
+		WM8994_SPKOUTL_ENA_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL |
+		WM8994_HPOUT1R_ENA | WM8994_HPOUT1L_ENA |
+		WM8994_SPKOUTL_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	val = (WM8994_HPOUT1L_DLY | WM8994_HPOUT1R_DLY);
+	wm8994_write(codec, WM8994_ANALOGUE_HP_1, val);
+
+	/* Enable Charge Pump */
+	/* this is from wolfson */
+	val = wm8994_read(codec, WM8994_CHARGE_PUMP_1);
+	val &= ~WM8994_CP_ENA_MASK ;
+	val |= WM8994_CP_ENA | WM8994_CP_ENA_DEFAULT;
+	wm8994_write(codec, WM8994_CHARGE_PUMP_1, val);
+
+	msleep(5);
+
+	/* Enable DAC1 and DAC2 and the Timeslot0 for AIF1 */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_DAC1R_ENA_MASK | WM8994_DAC1L_ENA_MASK |
+		WM8994_AIF1DAC1R_ENA_MASK | WM8994_AIF1DAC1L_ENA_MASK);
+	val |= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+		WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	/* Enbale DAC1L to HPOUT1L path */
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_1);
+	val &=  ~(WM8994_DAC1L_TO_HPOUT1L_MASK | WM8994_DAC1L_TO_MIXOUTL_MASK);
+	val |=  WM8994_DAC1L_TO_MIXOUTL;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val);
+
+	/* Enbale DAC1R to HPOUT1R path */
+	val = wm8994_read(codec, WM8994_OUTPUT_MIXER_2);
+	val &= ~(WM8994_DAC1R_TO_HPOUT1R_MASK | WM8994_DAC1R_TO_MIXOUTR_MASK);
+	val |= WM8994_DAC1R_TO_MIXOUTR;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val);
+
+	/* Enbale bias,vmid, hp left and right and Left speaker */
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_3);
+	val &= ~(WM8994_MIXOUTLVOL_ENA_MASK | WM8994_MIXOUTRVOL_ENA_MASK |
+		WM8994_MIXOUTL_ENA_MASK | WM8994_MIXOUTR_ENA_MASK |
+		WM8994_SPKLVOL_ENA_MASK);
+	val |= (WM8994_MIXOUTL_ENA | WM8994_MIXOUTR_ENA | WM8994_SPKLVOL_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, val);
+
+	/* DC Servo */
+	if (!wm8994->dc_servo[DCS_SPK_HP]) {
+		wait_for_dc_servo(codec,
+				  WM8994_DCS_TRIG_SERIES_0 |
+				  WM8994_DCS_TRIG_SERIES_1);
+
+		nreadservo4val = wm8994_read(codec, WM8994_DC_SERVO_4);
+		nservo4low = (signed char)(nreadservo4val & 0xff);
+		nservo4high = (signed char)((nreadservo4val>>8) & 0xff);
+
+		ncompensationresultlow = ((signed short)nservo4low - 5)
+			& 0x00ff;
+		ncompensationresulthigh = ((signed short)(nservo4high - 5)<<8)
+			& 0xff00;
+		ncompensationresult = ncompensationresultlow |
+			ncompensationresulthigh;
+	} else {
+		ncompensationresult = wm8994->dc_servo[DCS_SPK_HP];
+	}
+
+	wm8994_write(codec, WM8994_DC_SERVO_4, ncompensationresult);
+	wm8994->dc_servo[DCS_SPK_HP] = ncompensationresult;
+
+	wait_for_dc_servo(codec,
+			  WM8994_DCS_TRIG_DAC_WR_1 | WM8994_DCS_TRIG_DAC_WR_0);
+
+	val = wm8994_read(codec, WM8994_ANALOGUE_HP_1);
+	val &= ~(WM8994_HPOUT1R_DLY_MASK | WM8994_HPOUT1R_OUTP_MASK |
+		WM8994_HPOUT1R_RMV_SHORT_MASK |	WM8994_HPOUT1L_DLY_MASK |
+		WM8994_HPOUT1L_OUTP_MASK | WM8994_HPOUT1L_RMV_SHORT_MASK);
+	val |= (WM8994_HPOUT1L_RMV_SHORT | WM8994_HPOUT1L_OUTP |
+		WM8994_HPOUT1L_DLY | WM8994_HPOUT1R_RMV_SHORT |
+		WM8994_HPOUT1R_OUTP | WM8994_HPOUT1R_DLY);
+	wm8994_write(codec, WM8994_ANALOGUE_HP_1, val);
+
+	if (wm8994->ringtone_active)
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE,
+				PLAYBACK_RING_SPK_HP);
+	else
+		wm8994_set_codec_gain(codec, PLAYBACK_MODE, PLAYBACK_SPK_HP);
+
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_VOLUME);
+	val &= ~(WM8994_DAC1L_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_LEFT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_VOLUME);
+	val &= ~(WM8994_DAC1R_MUTE_MASK);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_VOLUME, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+	val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+	val |= (WM8994_AIF1DAC1_UNMUTE | WM8994_AIF1DAC1_MONO);
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+
+}
+
+void wm8994_set_playback_bluetooth(struct snd_soc_codec *codec)
+{
+	u16 val;
+
+	DEBUG_LOG("BT Playback Path for SCO\n");
+
+	wm8994_set_bluetooth_common_setting(codec);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_1);
+	val &= ~(WM8994_BIAS_ENA_MASK | WM8994_VMID_SEL_MASK);
+	val |= (WM8994_BIAS_ENA | WM8994_VMID_SEL_NORMAL);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_1, val);
+
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_2, 0x0000);
+
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_3, 0x0000);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_4);
+	val &= ~(WM8994_AIF2ADCL_ENA_MASK | WM8994_AIF2ADCR_ENA_MASK);
+	val |= (WM8994_AIF2ADCL_ENA | WM8994_AIF2ADCR_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_4, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK |
+		WM8994_AIF1DAC1L_ENA_MASK | WM8994_AIF1DAC1R_ENA_MASK |
+		WM8994_DAC1L_ENA_MASK | WM8994_DAC1R_ENA_MASK);
+	val |= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA |
+		WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+		WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_6);
+	val &= ~(WM8994_AIF3_ADCDAT_SRC_MASK);
+	val |= (0x0001 << WM8994_AIF3_ADCDAT_SRC_SHIFT);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_6, val);
+
+	/* Mixer Routing*/
+	val = wm8994_read(codec, WM8994_DAC2_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC2L_MASK);
+	val |= (WM8994_AIF1DAC1L_TO_DAC2L);
+	wm8994_write(codec, WM8994_DAC2_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC2R_MASK);
+	val |= (WM8994_AIF1DAC1R_TO_DAC2R);
+	wm8994_write(codec, WM8994_DAC2_RIGHT_MIXER_ROUTING, val);
+
+	/* Volume*/
+	wm8994_write(codec, WM8994_DAC2_LEFT_VOLUME, 0x01C0);
+	wm8994_write(codec, WM8994_DAC2_RIGHT_VOLUME, 0x01C0);
+
+	wm8994_write(codec, WM8994_AIF2_CLOCKING_1, 0x0019);
+
+	wm8994_write(codec, WM8994_OVERSAMPLING, 0X0000);
+
+	/* GPIO Configuration*/
+	wm8994_write(codec, WM8994_GPIO_8, WM8994_GP8_DIR | WM8994_GP8_DB);
+	wm8994_write(codec, WM8994_GPIO_9, WM8994_GP9_DB);
+	wm8994_write(codec, WM8994_GPIO_10, WM8994_GP10_DB);
+	wm8994_write(codec, WM8994_GPIO_11, WM8994_GP11_DB);
+
+	/* Un-Mute*/
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+	val &= ~(WM8994_AIF1DAC1_MUTE_MASK | WM8994_AIF1DAC1_MONO_MASK);
+	val |= (WM8994_AIF1DAC1_UNMUTE);
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+
+}
+
+void wm8994_set_voicecall_common_setting(struct snd_soc_codec *codec)
+{
+	int val;
+
+	/* GPIO Configuration */
+	wm8994_write(codec, WM8994_GPIO_1, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_2, 0x8100);
+	wm8994_write(codec, WM8994_GPIO_3, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_4, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_5, 0x8100);
+	wm8994_write(codec, WM8994_GPIO_6, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_7, 0x0100);
+	wm8994_write(codec, WM8994_GPIO_8, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_9, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_10, 0xA101);
+	wm8994_write(codec, WM8994_GPIO_11, 0xA101);
+
+	wm8994_write(codec, WM8994_FLL2_CONTROL_2, 0x2F00);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_3, 0x3126);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_4, 0x0100);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_5, 0x0C88);
+	wm8994_write(codec, WM8994_FLL2_CONTROL_1,
+		WM8994_FLL2_FRACN_ENA | WM8994_FLL2_ENA);
+
+	val = wm8994_read(codec, WM8994_AIF2_CLOCKING_1);
+	if (!(val & WM8994_AIF2CLK_ENA))
+		wm8994_write(codec, WM8994_AIF2_CLOCKING_1, 0x0018);
+
+	wm8994_write(codec, WM8994_AIF2_RATE, 0x3 << WM8994_AIF2CLK_RATE_SHIFT);
+
+	/* AIF2 Interface - PCM Stereo mode */
+	/* Left Justified, BCLK invert, LRCLK Invert */
+	wm8994_write(codec, WM8994_AIF2_CONTROL_1,
+		WM8994_AIF2ADCR_SRC | WM8994_AIF2_BCLK_INV | 0x18);
+
+	wm8994_write(codec, WM8994_AIF2_BCLK, 0x70);
+	wm8994_write(codec, WM8994_AIF2_CONTROL_2, 0x0000);
+	wm8994_write(codec, WM8994_AIF2_MASTER_SLAVE, WM8994_AIF2_MSTR |
+		WM8994_AIF2_CLK_FRC | WM8994_AIF2_LRCLK_FRC);
+
+	val = wm8994_read(codec, WM8994_POWER_MANAGEMENT_5);
+	val &= ~(WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK |
+		WM8994_AIF1DAC1L_ENA_MASK | WM8994_AIF1DAC1R_ENA_MASK |
+		WM8994_DAC1L_ENA_MASK | WM8994_DAC1R_ENA_MASK);
+	val |= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA |
+		WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA |
+		WM8994_DAC1L_ENA | WM8994_DAC1R_ENA);
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_5, val);
+
+	/* Clocking */
+	val = wm8994_read(codec, WM8994_CLOCKING_1);
+	val |= (WM8994_DSP_FS2CLK_ENA);
+	wm8994_write(codec, WM8994_CLOCKING_1, val);
+
+	wm8994_write(codec, WM8994_POWER_MANAGEMENT_6, 0x0);
+
+	/* AIF1 & AIF2 Output is connected to DAC1 */
+	val = wm8994_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1L_TO_DAC1L_MASK |
+		WM8994_AIF2DACL_TO_DAC1L_MASK);
+	val |= (WM8994_AIF1DAC1L_TO_DAC1L | WM8994_AIF2DACL_TO_DAC1L);
+	wm8994_write(codec, WM8994_DAC1_LEFT_MIXER_ROUTING, val);
+
+	val = wm8994_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);
+	val &= ~(WM8994_AIF1DAC1R_TO_DAC1R_MASK |
+		WM8994_AIF2DACR_TO_DAC1R_MASK);
+	val |= (WM8994_AIF1DAC1R_TO_DAC1R | WM8994_AIF2DACR_TO_DAC1R);
+	wm8994_write(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING, val);
+
+	wm8994_write(codec, 0x6, 0x0);
+}
+
+#ifdef FEATURE_SS_AUDIO_CAL
+void wm8994_set_voicecall_receiver(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int val;
+
+	wm8994_write(codec, 0x0039, 0x0068);	// Anti Pop2
+	wm8994_write(codec, 0x0001, 0x0003);	// Power Management 1
+	msleep(50);
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0817, 0x0000);	// To remove the robotic sound
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0015, 0x0040);
+	wm8994_write(codec, 0x0702, 0x8100);	// GPIO 3. Speech PCM Clock
+	wm8994_write(codec, 0x0703, 0x8100);	// GPIO 4. Speech PCM Sync
+	wm8994_write(codec, 0x0704, 0x8100);	// GPIO 5. Speech PCM Data Out
+	wm8994_write(codec, 0x0706, 0x0100);	// GPIO 7. Speech PCM Data Input
+	wm8994_write(codec, 0x0244, 0x0C81);	// FLL2 Control 5
+	wm8994_write(codec, 0x0241, 0x0700);	// FLL2 Control 2
+	wm8994_write(codec, 0x0242, 0x0000);	// FLL2 Control 3
+	wm8994_write(codec, 0x0243, 0x0600);	// FLL2 Control 4
+	wm8994_write(codec, 0x0240, 0x0001);	// FLL2 Control 1
+	msleep(3);
+
+	/* Audio Interface & Clock Setting */
+	wm8994_write(codec, 0x0204, 0x0018);	// AIF2 Clocking 1. Clock Source Select
+	wm8994_write(codec, 0x0208, 0x000F);	// Clocking 1. '0x000A' is added for a playback. (original = 0x0007)
+	wm8994_write(codec, 0x0620, 0x0000);	// Oversampling
+	wm8994_write(codec, 0x0211, 0x0009);	// AIF2 Rate
+	wm8994_write(codec, 0x0302, 0x4000);	// AIF1 Master Slave Setting. To prevent that the music is played slowly.
+	wm8994_write(codec, 0x0312, 0x0000);	// AIF2 Master Slave Setting
+	wm8994_write(codec, 0x0310, 0x4118);	// AIF2 Control 1
+	wm8994_write(codec, 0x0311, 0x0000);	// AIF2 Control 2
+	wm8994_write(codec, 0x0520, 0x0080);	// AIF2 DAC Filter 1
+	wm8994_write(codec, 0x0204, 0x0019);	// AIF2 Clocking 1. AIF2 Clock Enable
+
+	/* Input Path Routing */
+	wm8994_write(codec, 0x0028, 0x0030);	// Input Mixer 2
+	wm8994_write(codec, 0x0002, 0x6240);	// Power Management 2
+	wm8994_write(codec, 0x0029, 0x0030);	// Input Mixer 3
+	wm8994_write(codec, 0x0004, 0x2002);	// Power Management 4
+	wm8994_write(codec, 0x0604, 0x0010);	// DAC2 Left Mixer Routing
+	
+	audio_ctrl_mic_bias_gpio(wm8994->pdata, 1);
+	
+	/* Output Path Routing */
+	wm8994_write(codec, 0x0005, 0x2303);	// Power Management 5. '0x0303' is added for a playback. (Original = 0x2002)
+	wm8994_write(codec, 0x0601, 0x0015);	// DAC1 Left Mixer Routing. '0x0001' is added for a playback. (Original = 0x0004)
+	wm8994_write(codec, 0x0602, 0x0001);	// DAC1 Right Mixer Routing(Playback)
+	wm8994_write(codec, 0x002D, 0x0001);	// Output Mixer 1
+	wm8994_write(codec, 0x002E, 0x0001);	// Output Mixer 2(Playback)
+	wm8994_write(codec, 0x0003, 0x00F0);	// Power Management 3. '0x00F0' is added for a playback. (Original = 0x00A0)
+	wm8994_write(codec, 0x0033, 0x0018);	// HPOUT2 Mixer. '0x0008' is added for a playback. (Original = 0x0010)
+	wm8994_write(codec, 0x0420, 0x0080);	// AIF1 DAC1 FIlter(Playback)
+
+	/* Input Path Volume */
+	if(loopback_mode == LOOPBACK_MODE_OFF)
+	{
+		wm8994_write(codec, 0x0018, 0x0116);	// Left Line Input 1&2 Volume
+		wm8994_write(codec, 0x0500, 0x01C0);	// AIF2 ADC Left Volume
+		wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+		wm8994_write(codec, 0x0603, 0x000C);	// DAC2 Mixer Volumes
+		wm8994_write(codec, 0x0621, 0x01C0);	// Sidetone
+	}
+	else
+	{
+		wm8994_write(codec, 0x0018, 0x0110);	// Left Line Input 1&2 Volume
+		wm8994_write(codec, 0x0500, 0x01C0);	// AIF2 ADC Left Volume
+		wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+		wm8994_write(codec, 0x0603, 0x000C);	// DAC2 Mixer Volumes
+
+		DEBUG_LOG("=====================================> Loopback Mode");
+	}
+
+	/* Output Path Volume */
+	if(loopback_mode == LOOPBACK_MODE_OFF)
+	{
+		wm8994_write(codec, 0x0031, 0x0000);	// Output Mixer 5
+		wm8994_write(codec, 0x0032, 0x0000);	// Output Mixer 6
+		wm8994_write(codec, 0x0020, 0x017D);	// Left OPGA Volume
+		wm8994_write(codec, 0x0021, 0x017D);	// Right OPGA Volume
+		wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+		wm8994_write(codec, 0x0611, 0x01C0);	// DAC1 Right Volume
+#if 1
+		wm8994_write(codec, 0x001F, 0x0000);	// HPOUT2 Volume
+#else
+		if(wm8994->codec_state & CALL_ACTIVE)
+		{
+			wm8994_write(codec, 0x001F, 0x0000);	// HPOUT2 Volume
+		}
+		else
+		{
+			wm8994_write(codec, 0x001F, 0x0020);	// HPOUT2 Volume
+		}
+#endif
+	}
+	else
+	{
+		wm8994_write(codec, 0x0031, 0x0000);	// Output Mixer 5
+		wm8994_write(codec, 0x0032, 0x0000);	// Output Mixer 6
+		wm8994_write(codec, 0x0020, 0x0179);	// Left OPGA Volume
+		wm8994_write(codec, 0x0021, 0x0179);	// Right OPGA Volume
+		wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+		wm8994_write(codec, 0x0611, 0x01C0);	// DAC1 Right Volume
+		wm8994_write(codec, 0x001F, 0x0000);	// HPOUT2 Volume
+	}
+
+	wm8994_write(codec, 0x0015, 0x0000);	
+	wm8994_write(codec, 0x0038, 0x0040);	// Anti Pop 1
+	wm8994_write(codec, 0x0006, 0x0000);	// Power Management 6. Prevent the mute when the audio transfer is executed from the bluetooth.
+
+	/* Sidetone */
+	wm8994_write(codec, 0x0600, 0x0003);	// DAC1 Mixer Volume
+	if(!(wm8994->codec_state & CALL_ACTIVE))
+	{
+		msleep(300);
+	}
+	wm8994_write(codec, 0x0001, 0x0803);	// Power Management 1
+//	  msleep(50);
+	wm8994_write(codec, 0x0224, 0x0C98);	// FLL1 Control(5). To set again the sampling rate for a AP sound.
+
+	DEBUG_LOG("");
+}
+
+void wm8994_set_voicecall_headset(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int upper_value = 0;
+	int lower_value = 0;
+	int value = 0;
+
+	wm8994_write(codec, 0x0039, 0x006C);	// Anti Pop 2
+	wm8994_write(codec, 0x0001, 0x0003);	// Power Management 1
+	msleep(50);
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0817, 0x0000);	// To remove the robotic sound
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x004C, 0x9F25);	// Charge Pump 1
+
+	wm8994_write(codec, 0x0702, 0x8100);	// GPIO 3. Speech PCM Clock
+	wm8994_write(codec, 0x0703, 0x8100);	// GPIO 4. Speech PCM Sync
+	wm8994_write(codec, 0x0704, 0x8100);	// GPIO 5. Speech PCM Data Out
+	wm8994_write(codec, 0x0706, 0x0100);	// GPIO 7. Speech PCM Data Input
+
+	wm8994_write(codec, 0x0244, 0x0C81);	// FLL2 Control 5
+	wm8994_write(codec, 0x0241, 0x0700);	// FLL2 Control 2
+	wm8994_write(codec, 0x0242, 0x0000);	// FLL2 Control 3
+	wm8994_write(codec, 0x0243, 0x0600);	// FLL2 Control 4
+	wm8994_write(codec, 0x0240, 0x0001);	// FLL2 Control 1
+	msleep(3);
+
+	/* Audio Interface & Clock Setting */
+	wm8994_write(codec, 0x0204, 0x0018);	// AIF2 Clocking 1
+	wm8994_write(codec, 0x0208, 0x000F);	// Clocking 1. '0x000A' is added for a playback. (original = 0x0007)
+	wm8994_write(codec, 0x0620, 0x0000);	// Oversampling
+	wm8994_write(codec, 0x0211, 0x0009);	// AIF2 Rate
+	wm8994_write(codec, 0x0302, 0x4000);	// AIF1 Master Slave Setting. To prevent that the music is played slowly.
+	wm8994_write(codec, 0x0312, 0x0000);	// AIF2 Master Slave Setting
+
+	if(tty_mode == TTY_MODE_VCO)
+	{
+		wm8994_write(codec, 0x0310, 0x4118);	// AIF2 Control 1
+	}
+	else
+	{
+		wm8994_write(codec, 0x0310, 0xC118);	// AIF2 Control 1
+	}
+	wm8994_write(codec, 0x0311, 0x0000);	// AIF2 Control 2
+	wm8994_write(codec, 0x0520, 0x0080);	// AIF2 DAC Filter1
+	wm8994_write(codec, 0x0204, 0x0019);	// AIF2 Clocking 1
+
+	/* Input Path Routing */
+	if(tty_mode == TTY_MODE_VCO)
+	{
+		wm8994_write(codec, 0x0028, 0x0030);	// Input Mixer 2
+		wm8994_write(codec, 0x0002, 0x6240);	// Power Management 2
+		wm8994_write(codec, 0x0029, 0x0030);	// Input Mixer 
+		wm8994_write(codec, 0x0004, 0x2002);	// Power Management 4
+	}
+	else if(tty_mode == TTY_MODE_HCO || tty_mode == TTY_MODE_FULL)
+	{
+		wm8994_write(codec, 0x0028, 0x0001);	// Input Mixer 2
+		wm8994_write(codec, 0x0002, 0x6130);	// Power Management 2
+		wm8994_write(codec, 0x002A, 0x0030);	// Input Mixer 4
+		wm8994_write(codec, 0x0004, 0x1001);	// Power Management 4
+	}
+	else
+	{
+		wm8994_write(codec, 0x0028, 0x0001);	// Input Mixer 2
+		wm8994_write(codec, 0x0002, 0x6130);	// Power Management 2
+		wm8994_write(codec, 0x002A, 0x0020);	// Input Mixer 4
+		wm8994_write(codec, 0x0004, 0x1001);	// Power Management 4
+	}
+	wm8994_write(codec, 0x0604, 0x0030);	// DAC2 Left Mixer Routing
+	wm8994_write(codec, 0x0605, 0x0030);	// DAC2 Right Mixer Routing
+
+	wm8994_earsel_control(wm8994->pdata, 1);
+
+	/* Output Path Routing */
+	wm8994_write(codec, 0x0005, 0x3303);	// Power Management 5
+
+	if(tty_mode == TTY_MODE_HCO)
+	{
+		wm8994_write(codec, 0x0601, 0x0005);	// DAC1 Left Mixer Routing
+		wm8994_write(codec, 0x0602, 0x0005);	// DAC1 Right Mixer Routing
+		wm8994_write(codec, 0x002D, 0x0001);	// Output Mixer 1
+		wm8994_write(codec, 0x002E, 0x0001);	// Output Mixer 2
+		wm8994_write(codec, 0x0003, 0x00F0);	// Power Management 3
+		wm8994_write(codec, 0x0033, 0x0018);	// HPOUT2 Mixer
+		wm8994_write(codec, 0x0420, 0x0080);	// AIF1 DAC1 Filter1
+	}
+	else
+	{
+		wm8994_write(codec, 0x0601, 0x0005);	// DAC1 Left Mixer Routing
+		wm8994_write(codec, 0x0602, 0x0005);	// DAC1 Right Mixer Routing
+		wm8994_write(codec, 0x002D, 0x0100);	// Output Mixer 1
+		wm8994_write(codec, 0x002E, 0x0100);	// Output Mixer 2
+		wm8994_write(codec, 0x0003, 0x00F0);	// Power Management 3(Playback)
+		wm8994_write(codec, 0x0060, 0x00EE);	// Analogue HP 1
+		wm8994_write(codec, 0x0420, 0x0080);	// AIF1 DAC1 Filter1
+	}
+
+	/* Input Path Volume */
+	if(tty_mode == TTY_MODE_VCO)
+	{
+		wm8994_write(codec, 0x0018, 0x0116);	// Left Line Input 1&2 Volume
+		wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+	}
+	else if(tty_mode == TTY_MODE_HCO || tty_mode == TTY_MODE_FULL)
+	{
+		wm8994_write(codec, 0x001A, 0x011F/*0x0112*/);	  // Right Line Input 1&2 Volume
+		wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+	}
+	else if(loopback_mode == PBA_LOOPBACK_MODE_ON)
+	{
+		wm8994_write(codec, 0x001A, 0x0116);	// Right Line Input 1&2 Volume
+		wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+		wm8994_write(codec, 0x0501, 0x01C0);	// AIF2 Right ADC Volume
+
+		DEBUG_LOG("===================================================> Loopback Mode = %d.", loopback_mode);
+	}
+	else if(loopback_mode == SIMPLETEST_LOOPBACK_MODE_ON)
+	{
+		wm8994_write(codec, 0x001A, 0x0116);	// Right Line Input 1&2 Volume
+		wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+		wm8994_write(codec, 0x0501, 0x01EF);	// AIF2 Right ADC Volume
+
+		DEBUG_LOG("===================================================> Loopback Mode = %d.", loopback_mode);
+	}
+	else
+	{
+		wm8994_write(codec, 0x001A, 0x0117);	// Right Line Input 1&2 Volume
+		wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+		wm8994_write(codec, 0x0501, 0x01EF);	// AIF2 Right ADC Volume
+	}
+	wm8994_write(codec, 0x0603, 0x018C);	// DAC2 Mixer Volumes
+
+	/* Output Path Volume */
+	if(tty_mode == TTY_MODE_HCO)
+	{
+		wm8994_write(codec, 0x0031, 0x0000);	// Output Mixer 5
+		wm8994_write(codec, 0x0032, 0x0000);	// Output Mixer 6
+		wm8994_write(codec, 0x0020, 0x017D);	// Left OPGA Volume
+		wm8994_write(codec, 0x0021, 0x017D);	// Right OPGA Volume
+		wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+		wm8994_write(codec, 0x0611, 0x01C0);	// DAC1 Right Volume
+#if 0
+		wm8994_write(codec, 0x001F, 0x0000);	// HPOUT2 Volume
+#else
+		if(wm8994->codec_state & CALL_ACTIVE)
+		{
+			wm8994_write(codec, 0x001F, 0x0000);	// HPOUT2 Volume
+		}
+		else
+		{
+			wm8994_write(codec, 0x001F, 0x0020);	// HPOUT2 Volume
+		}
+#endif
+	}
+	else
+	{
+		wm8994_write(codec, 0x0031, 0x0000);	// Output Mixer 5
+		wm8994_write(codec, 0x0032, 0x0000);	// Outupt Mixer 6
+		wm8994_write(codec, 0x0020, 0x0179);	// Left OPGA Volume
+		wm8994_write(codec, 0x0021, 0x0179);	// Right OPGA Volume
+#if 1
+		if(tty_mode == TTY_MODE_FULL || tty_mode == TTY_MODE_VCO)
+		{
+			wm8994_write(codec, 0x001C, 0x0179);	// Left Output Volume
+			wm8994_write(codec, 0x001D, 0x0179);	// Right Output Volume
+		}
+		else
+		{
+			wm8994_write(codec, 0x001C, 0x0170);	// Left Output Volume
+			wm8994_write(codec, 0x001D, 0x0170);	// Right Output Volume
+		}
+#else
+		if(wm8994->codec_state & CALL_ACTIVE)
+		{
+			if(tty_mode == TTY_MODE_FULL || tty_mode == TTY_MODE_VCO)
+			{
+				wm8994_write(codec, 0x001C, 0x0179);	// Left Output Volume
+				wm8994_write(codec, 0x001D, 0x0179);	// Right Output Volume
+			}
+			else
+			{
+				wm8994_write(codec, 0x001C, 0x0170);	// Left Output Volume
+				wm8994_write(codec, 0x001D, 0x0170);	// Right Output Volume
+			}
+		}
+		else
+		{
+			wm8994_write(codec, 0x001C, 0x0100);	// Left Output Volume
+			wm8994_write(codec, 0x001D, 0x0100);	// Right Output Volume
+		}
+#endif
+		wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+		wm8994_write(codec, 0x0611, 0x01C0);	// DAC1 Right Volume
+	}
+	wm8994_write(codec, 0x0006, 0x0000);	// Power Management 6. Prevent the mute when the audio transfer is executed from the bluetooth.
+	
+	if(tty_mode == TTY_MODE_HCO)
+	{
+		wm8994_write(codec, 0x0038, 0x0040);	// Anti Pop 1
+	}			 
+	wm8994_write(codec, 0x0621, 0x01C0);	// Sidetone
+	if(!(wm8994->codec_state & CALL_ACTIVE))
+	{
+		msleep(300);
+	}
+	if(tty_mode == TTY_MODE_HCO)
+	{
+		wm8994_write(codec, 0x0001, 0x0833);	// Power Management 1
+	}
+	else
+	{
+		wm8994_write(codec, 0x0001, 0x0303);	// Power Management 1
+	}
+	wm8994_write(codec, 0x0224, 0x0C98);	// FLL1 Control(5). To set again the sampling rate for a AP sound.
+
+	DEBUG_LOG("");
+	DEBUG_LOG("============================> TTY Mode = %d.", tty_mode);
+}
+
+void wm8994_set_voicecall_headphone(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int upper_value = 0;
+	int lower_value = 0;
+	int value = 0;
+
+	wm8994_write(codec, 0x0039, 0x006C);	// Anti Pop 2
+	wm8994_write(codec, 0x0001, 0x0003);	// Power Management 1
+	msleep(50);
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0817, 0x0000);	// To remove the robotic sound
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x004C, 0x9F25);	// Charge Pump 1
+
+	wm8994_write(codec, 0x0702, 0x8100);	// GPIO 3. Speech PCM Clock
+	wm8994_write(codec, 0x0703, 0x8100);	// GPIO 4. Speech PCM Sync
+	wm8994_write(codec, 0x0704, 0x8100);	// GPIO 5. Speech PCM Data Out
+	wm8994_write(codec, 0x0706, 0x0100);	// GPIO 7. Speech PCM Data Input
+
+	wm8994_write(codec, 0x0244, 0x0C81);	// FLL2 Control 5
+	wm8994_write(codec, 0x0241, 0x0700);	// FLL2 Control 2
+	wm8994_write(codec, 0x0242, 0x0000);	// FLL2 Control 3
+	wm8994_write(codec, 0x0243, 0x0600);	// FLL2 Control 4
+	wm8994_write(codec, 0x0240, 0x0001);	// FLL2 Control 1
+	msleep(3);
+
+	/* Audio Interface & Clock Setting */
+	wm8994_write(codec, 0x0204, 0x0018);	// AIF2 Clocking 1
+	wm8994_write(codec, 0x0208, 0x000F);	// Clocking 1. '0x000A' is added for a playback. (original = 0x0007)
+	wm8994_write(codec, 0x0620, 0x0000);	// Oversampling
+	wm8994_write(codec, 0x0211, 0x0009);	// AIF2 Rate
+	wm8994_write(codec, 0x0302, 0x4000);	// AIF1 Master Slave Setting. To prevent that the music is played slowly.
+	wm8994_write(codec, 0x0312, 0x0000);	// AIF2 Master Slave Setting
+	wm8994_write(codec, 0x0310, 0x4118);	// AIF2 Control 1
+	wm8994_write(codec, 0x0311, 0x0000);	// AIF2 Control 2
+	wm8994_write(codec, 0x0520, 0x0080);	// AIF2 DAC Filter1
+	wm8994_write(codec, 0x0204, 0x0019);	// AIF2 Clocking 1
+
+	/* Input Path Routing */
+	wm8994_write(codec, 0x0028, 0x0030);	// Input Mixer 2
+	wm8994_write(codec, 0x0002, 0x6240);	// Power Management 2
+	wm8994_write(codec, 0x0029, 0x0030);	// Input Mixer 
+	wm8994_write(codec, 0x0004, 0x2002);	// Power Management 4
+	wm8994_write(codec, 0x0604, 0x0030);	// DAC2 Left Mixer Routing
+	wm8994_write(codec, 0x0605, 0x0030);	// DAC2 Right Mixer Routing
+
+	audio_ctrl_mic_bias_gpio(wm8994->pdata, 1);
+
+	/* Output Path Routing */
+	wm8994_write(codec, 0x0005, 0x3303);	// Power Management 5
+	wm8994_write(codec, 0x0601, 0x0005);	// DAC1 Left Mixer Routing
+	wm8994_write(codec, 0x0602, 0x0005);	// DAC1 Right Mixer Routing
+	wm8994_write(codec, 0x002D, 0x0100);	// Output Mixer 1
+	wm8994_write(codec, 0x002E, 0x0100);	// Output Mixer 2
+	wm8994_write(codec, 0x0003, 0x00F0);	// Power Management 3(Playback)
+	wm8994_write(codec, 0x0060, 0x00EE);	// Analogue HP 1
+	wm8994_write(codec, 0x0420, 0x0080);	// AIF1 DAC1 Filter1
+
+	/* Input Path Volume */
+	wm8994_write(codec, 0x0018, 0x0116);	// Left Line Input 1&2 Volume
+	wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+	wm8994_write(codec, 0x0603, 0x018C);	// DAC2 Mixer Volumes
+
+	/* Output Path Volume */
+	wm8994_write(codec, 0x0031, 0x0000);	// Output Mixer 5
+	wm8994_write(codec, 0x0032, 0x0000);	// Outupt Mixer 6
+	wm8994_write(codec, 0x0020, 0x0179);	// Left OPGA Volume
+	wm8994_write(codec, 0x0021, 0x0179);	// Right OPGA Volume
+#if 1
+	if(tty_mode == TTY_MODE_FULL || tty_mode == TTY_MODE_VCO)
+	{
+		wm8994_write(codec, 0x001C, 0x0179);	// Left Output Volume
+		wm8994_write(codec, 0x001D, 0x0179);	// Right Output Volume
+	}
+	else
+	{
+		wm8994_write(codec, 0x001C, 0x0170);	// Left Output Volume
+		wm8994_write(codec, 0x001D, 0x0170);	// Right Output Volume
+	}
+#else
+	if(wm8994->codec_state & CALL_ACTIVE)
+	{
+		if(tty_mode == TTY_MODE_FULL || tty_mode == TTY_MODE_VCO)
+		{
+			wm8994_write(codec, 0x001C, 0x0179);	// Left Output Volume
+			wm8994_write(codec, 0x001D, 0x0179);	// Right Output Volume
+		}
+		else
+		{
+			wm8994_write(codec, 0x001C, 0x0170);	// Left Output Volume
+			wm8994_write(codec, 0x001D, 0x0170);	// Right Output Volume
+		}
+	}
+	else
+	{
+		wm8994_write(codec, 0x001C, 0x0100);	// Left Output Volume
+		wm8994_write(codec, 0x001D, 0x0100);	// Right Output Volume
+	}
+#endif
+	wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+	wm8994_write(codec, 0x0611, 0x01C0);	// DAC1 Right Volume
+	
+	wm8994_write(codec, 0x0006, 0x0000);	// Power Management 6. Prevent the mute when the audio transfer is executed from the bluetooth.	
+	wm8994_write(codec, 0x0621, 0x01C0);	// Sidetone
+	if(!(wm8994->codec_state & CALL_ACTIVE))
+	{
+		msleep(300);
+	}
+	wm8994_write(codec, 0x0001, 0x0303);	// Power Management 1
+	wm8994_write(codec, 0x0224, 0x0C98);	// FLL1 Control(5). To set again the sampling rate for a AP sound.
+
+	DEBUG_LOG("");
+	DEBUG_LOG("============================> TTY Mode = %d.", tty_mode);
+}
+
+
+void wm8994_set_voicecall_speaker(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int val;
+
+	wm8994_write(codec, 0x0039, 0x006C);	// Anti Pop 2
+	wm8994_write(codec, 0x0001, 0x0003);	// Power Management 1
+	msleep(50);
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0817, 0x0000);	// To remove the robotic sound
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+
+	wm8994_write(codec, 0x0702, 0x8100);	// GPIO 3. Speech PCM Clock
+	wm8994_write(codec, 0x0703, 0x8100);	// GPIO 4. Speech PCM Sync
+	wm8994_write(codec, 0x0704, 0x8100);	// GPIO 5. Speech PCM Data Out
+	wm8994_write(codec, 0x0706, 0x0100);	// GPIO 7. Speech PCM Data Input
+
+	wm8994_write(codec, 0x0244, 0x0C81);	// FLL2 Control 5
+	wm8994_write(codec, 0x0241, 0x0700);	// FLL2 Control 2
+	wm8994_write(codec, 0x0242, 0x0000);	// FLL2 Control 3
+	wm8994_write(codec, 0x0243, 0x0600);	// FLL2 Control 4
+	wm8994_write(codec, 0x0240, 0x0001);	// FLL2 Control 1
+	msleep(3);
+
+	/* Audio Interface & Clock Setting */
+	wm8994_write(codec, 0x0204, 0x0018);	// AIF2 Clocking 1
+	wm8994_write(codec, 0x0208, 0x000F);	// Clocking 1. '0x000A' is added for a playback. (original = 0x0007)
+	wm8994_write(codec, 0x0620, 0x0000);	// Oversampling
+	wm8994_write(codec, 0x0211, 0x0009);	// AIF2 Rate
+	wm8994_write(codec, 0x0300, 0x0010);	// AIF1 Control 1
+	wm8994_write(codec, 0x0302, 0x4000);	// AIF1 Master Slave Setting. To prevent that the music is played slowly.
+	wm8994_write(codec, 0x0312, 0x0000);	// AIF2 Master Slave Setting
+	wm8994_write(codec, 0x0310, 0x4118);	// AIF2 Control 1
+	wm8994_write(codec, 0x0311, 0x0000);	// AIF2 Control 2
+	wm8994_write(codec, 0x0520, 0x0080);	// AIF2 DAC Filter1
+	wm8994_write(codec, 0x0204, 0x0019);	// AIF2 Clocking 1
+
+	/* Input Path Routing */
+	wm8994_write(codec, 0x0028, 0x0040);	// Input Mixer 2. SPK Mic using the IN2NL | DM1CDAT1
+	wm8994_write(codec, 0x0002, 0x6280);	// SPK Mic using the IN2NL | DM1CDAT1
+
+	wm8994_write(codec, 0x0029, 0x0100);	// Input Mixer 3. SPK Mic using the IN2NL | DM1CDAT1
+	wm8994_write(codec, 0x0004, 0x2002);	// Power Management 4
+	wm8994_write(codec, 0x0604, 0x0010);	// DAC2 Left Mixer Routing
+	wm8994_write(codec, 0x0605, 0x0010);	// DAC2 Right Mixer Routing
+
+	audio_ctrl_mic_bias_gpio(wm8994->pdata, 1);
+
+	/* Output Path Routing */
+	wm8994_write(codec, 0x0005, 0x3303);	// Power Management 5
+	wm8994_write(codec, 0x0003, 0x0300);	// Power Management 3
+	wm8994_write(codec, 0x0601, 0x0005);	// DAC1 Left Mixer Routing. '0x0001' is added for a playback. (Original = 0x0004)
+	wm8994_write(codec, 0x0602, 0x0001);	// DAC1 Right Mixer Routing(Playback)
+#ifdef STEREO_SPEAKER_SUPPORT
+	wm8994_write(codec, 0x0024, 0x0011);	// SPKOUT Mixers
+#else
+	wm8994_write(codec, 0x0024, 0x0010);	// SPKOUT Mixers
+#endif
+	wm8994_write(codec, 0x0420, 0x0080);	// AIF2 DAC Filter1(Playback)
+
+	/* Input Path Volume */
+	wm8994_write(codec, 0x0019, 0x0112);	// Left Line Input 3&4 Volume. SPK Mic using the IN2NL | DM1CDAT1
+	wm8994_write(codec, 0x0603, 0x000C);	// DAC2 Mixer Volumes
+	wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+	wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+	wm8994_write(codec, 0x0500, 0x01EF);	// AIF2 ADC Left Volume
+
+	/* Output Path Volume */
+	wm8994_write(codec, 0x0022, 0x0000);	// SPKMIXL Attenuation
+#if 1
+	wm8994_write(codec, 0x0026, 0x017E);	// Speaker Volume Left
+#else
+	if(wm8994->codec_state & CALL_ACTIVE)
+	{
+		wm8994_write(codec, 0x0026, 0x017E);	// Speaker Volume Left
+	}
+	else
+	{
+		wm8994_write(codec, 0x0026, 0x0100);	// Speaker Volume Left
+	}
+#endif
+#ifdef STEREO_SPEAKER_SUPPORT
+	wm8994_write(codec, 0x0025, ((0x0007 << 0x0003) | (0x0007 << 0x0000)));    // SPKOUT Boost
+#else
+	wm8994_write(codec, 0x0025, (0x0007 << 0x0003));	// SPKOUT Boost
+#endif
+	wm8994_write(codec, 0x0610, 0x01C0);	// DAC1 Left Volume
+
+	wm8994_write(codec, 0x0006, 0x0000);	// Power Management 6. Prevent the mute when the audio transfer is executed from the bluetooth.
+	wm8994_write(codec, 0x0621, 0x01C0);	// Sidetone
+	wm8994_write(codec, 0x0036, 0x0003);
+	if(!(wm8994->codec_state & CALL_ACTIVE))
+	{
+		msleep(300);
+	}
+	
+#ifdef STEREO_SPEAKER_SUPPORT
+	wm8994_write(codec, 0x0001, 0x3003);	// Power Management 1
+#else
+	wm8994_write(codec, 0x0001, 0x1003);	// Power Management 1
+#endif
+//	  msleep(50);
+	wm8994_write(codec, 0x0224, 0x0C98);	// FLL1 Control(5). To set again the sampling rate for a AP sound.
+
+	DEBUG_LOG("");
+}
+
+
+void wm8994_set_voicecall_bluetooth(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	wm8994_write(codec, 0x0039, 0x0068);	// Anti Pop2
+	wm8994_write(codec, 0x0001, 0x0003);	// Power Management 1
+	msleep(50);
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+	wm8994_write(codec, 0x0817, 0x0000);	// To remove the robotic sound
+	wm8994_write(codec, 0x0102, 0x0003);	// To remove the robotic sound
+
+	wm8994_write(codec, 0x0704, 0x8100);	// GPIO 5. Speech PCM OUT
+	wm8994_write(codec, 0x0706, 0x0100);	// GPIO 7. Speech PCM IN
+	wm8994_write(codec, 0x0702, 0x8100);	// GPIO 3. Speech PCM CLK
+	wm8994_write(codec, 0x0703, 0x8100);	// GPIO 4. Speech PCM SYNC
+	wm8994_write(codec, 0x0707, 0x8100);	// GPIO 8. BT PCM DOUT
+	wm8994_write(codec, 0x0708, 0x0100);	// GPIO 9. BT PCM DIN
+	wm8994_write(codec, 0x0709, 0x0100);	// GPIO 10. BT PCM SYNC
+	wm8994_write(codec, 0x070A, 0x0100);	// GPIO 11. BT PCM CLK
+
+	wm8994_write(codec, 0x0244, 0x0C81);	// FLL2 Control 5
+	wm8994_write(codec, 0x0241, 0x0700);	// FLL2 Control 2
+	wm8994_write(codec, 0x0242, 0x0000);	// FLL2 Control 3
+	wm8994_write(codec, 0x0243, 0x0600);	// FLL2 Control 4
+	wm8994_write(codec, 0x0240, 0x0001);	// FLL2 Cotnrol 1
+	msleep(3);
+	
+	/* Audio Interface & Clock Setting */
+	wm8994_write(codec, 0x0204, 0x0018);	// AIF2 Clocking 1. Clock Source Select
+	wm8994_write(codec, 0x0208, 0x000F);	// Clocking 1. '0x000A' is added for a playback. (original = 0x0007)
+	wm8994_write(codec, 0x0620, 0x0000);	// Oversampling
+	wm8994_write(codec, 0x0211, 0x0009);	// AIF2 Rate
+	wm8994_write(codec, 0x0302, 0x4000);	// AIF1 Master Slave Setting. To prevent that the music is played slowly.
+	wm8994_write(codec, 0x0312, 0x0000);	// AIF2 Master Slave Setting
+	wm8994_write(codec, 0x0310, 0x4118);	// AIF2 Control 1
+	wm8994_write(codec, 0x0311, 0x0000);	// AIF2 Control 2
+	wm8994_write(codec, 0x0520, 0x0080);	// AIF2 DAC Filter 1
+	wm8994_write(codec, 0x0204, 0x0019);	// AIF2 Clocking 1. AIF2 Clock Enable
+
+	/* Input Path Routing */
+	wm8994_write(codec, 0x0002, 0x4000);	// Power Management 2
+	wm8994_write(codec, 0x0004, 0x3000);	// Power Management 4
+	wm8994_write(codec, 0x0604, 0x0007);	// DAC2 Left Mixer Routing(Playback)
+	wm8994_write(codec, 0x0605, 0x0007);	// DAC2 Right Mixer(Playback)
+	wm8994_write(codec, 0x0015, 0x0040);	
+
+	/* Output Path Routing */
+	wm8994_write(codec, 0x004C, 0x1F25);	// Charge Pump 1
+	wm8994_write(codec, 0x0006, 0x000C);	// Power Management 6. Input = GPIO8, Output = AIF2
+	wm8994_write(codec, 0x0003, 0x0000);	// Power Management 3
+	wm8994_write(codec, 0x0005, 0x3303);	// Power Management 5. '0x3300' is added for a playback. (Original = 0x0003)
+	wm8994_write(codec, 0x0420, 0x0080);	// AIF1 DAC1 FIlter(Playback)
+
+	/* Output Path Volume */
+	wm8994_write(codec, 0x0402, 0x01C0);	// AIF1 DAC1 Left Volume(Playback)
+
+#if 1
+	wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+	wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+#else
+	if(wm8994->codec_state & CALL_ACTIVE)
+	{
+		wm8994_write(codec, 0x0612, 0x01C0);	// DAC2 Left Volume
+		wm8994_write(codec, 0x0613, 0x01C0);	// DAC2 Right Volume
+	}
+	else
+	{
+		wm8994_write(codec, 0x0612, 0x0100);	// DAC2 Left Volume(Playback)
+		wm8994_write(codec, 0x0613, 0x0100);	// DAC2 Right Volume(Playback)
+	}
+#endif
+	wm8994_write(codec, 0x0015, 0x0000);
+	wm8994_write(codec, 0x0224, 0x0C98);	// FLL1 Control(5). To set again the sampling rate for a AP sound.
+	
+	DEBUG_LOG("");
+}
+
+void wm8994_mute_voicecall_path(struct snd_soc_codec *codec, int path)
+{
+    if(path == RCV)
+    {
+        /* Output Path Volume */
+        wm8994_write(codec, 0x0610, 0x0100);    // DAC1 Left Volume
+        wm8994_write(codec, 0x0611, 0x0100);    // DAC1 Right Volume
+        wm8994_write(codec, 0x0020, 0x0040);    // Left OPGA Volume
+        wm8994_write(codec, 0x0021, 0x0040);    // Right OPGA Volume
+        wm8994_write(codec, 0x001F, 0x0020);    // HPOUT2 Volume
+
+        /* Output Path Routing */
+        wm8994_write(codec, 0x0033, 0x0000);    // HPOUT2 Mixer. '0x0008' is added for a playback. (Original = 0x0010)
+        wm8994_write(codec, 0x0420, 0x0200);    // AIF1 DAC1 FIlter(Playback)
+
+        /* Input Path Volume */
+        wm8994_write(codec, 0x0018, 0x008B);    // Left Line Input 1&2 Volume
+        wm8994_write(codec, 0x0612, 0x0100);    // DAC2 Left Volume
+        wm8994_write(codec, 0x0603, 0x0000);    // DAC2 Mixer Volumes
+    
+        DEBUG_LOG("===========================> The receiver voice path is muted.");
+    }
+    else if(path == HP)
+    {
+        /* Output Path Volume */
+        if(tty_mode == TTY_MODE_HCO)
+        {
+            wm8994_write(codec, 0x0020, 0x0000);    // Left OPGA Volume
+            wm8994_write(codec, 0x0021, 0x0000);    // Right OPGA Volume
+            wm8994_write(codec, 0x001F, 0x0020);    // HPOUT2 Volume
+            wm8994_write(codec, 0x0610, 0x0100);    // DAC1 Left Volume
+            wm8994_write(codec, 0x0611, 0x0100);    // DAC1 Right Volume
+            wm8994_write(codec, 0x0033, 0x0000);    // HPOUT2 Mixer
+        }
+        else
+        {
+            wm8994_write(codec, 0x001C, 0x0100);    // Left Output Volume
+            wm8994_write(codec, 0x001D, 0x0100);    // Right Output Volume
+            wm8994_write(codec, 0x0020, 0x0000);    // Left OPGA Volume
+            wm8994_write(codec, 0x0021, 0x0000);    // Right OPGA Volume
+            wm8994_write(codec, 0x0610, 0x0100);    // DAC1 Left Volume
+            wm8994_write(codec, 0x0611, 0x0100);    // DAC1 Right Volume
+            wm8994_write(codec, 0x0060, 0x0000);    // Analogue HP 1
+        }
+
+        /* Output Path Routing */
+        if(tty_mode == TTY_MODE_HCO)
+        {
+            wm8994_write(codec, 0x0033, 0x0000);    // HPOUT2 Mixer
+            wm8994_write(codec, 0x0420, 0x0200);    // AIF1 DAC1 Filter1
+        }
+        else
+        {
+            wm8994_write(codec, 0x0060, 0x0000);    // Analogue HP 1
+            wm8994_write(codec, 0x0420, 0x0200);    // AIF1 DAC1 Filter1
+        }
+
+        /* Input Path Volume */
+        if(tty_mode == TTY_MODE_VCO)
+        {
+            wm8994_write(codec, 0x0018, 0x008B);    // Left Line Input 1&2 Volume
+        }
+        else
+        {
+            wm8994_write(codec, 0x001A, 0x008B);    // Right Line Input 1&2 Volume
+        }
+        wm8994_write(codec, 0x0612, 0x0100);    // DAC2 Left Volume
+        wm8994_write(codec, 0x0613, 0x0100);    // DAC2 Right Volume
+        wm8994_write(codec, 0x0603, 0x0000);    // DAC2 Mixer Volumes
+        DEBUG_LOG("===========================> The headset voice path is muted.");
+    }
+    else if(path == SPK)
+    {
+        /* Output Path Volume */
+        wm8994_write(codec, 0x0025, 0x0000);    // SPKOUT Boost
+		wm8994_write(codec, 0x0026, 0x0100);    // Speaker Volume Left
+		wm8994_write(codec, 0x0027, 0x0000);    // Speaker Volume Right 
+      	wm8994_write(codec, 0x0613, 0x0100);    // DAC2 Right Volume
+
+        /* Output Path Routing */
+        wm8994_write(codec, 0x0024, 0x0000);    // SPKOUT Mixers
+        wm8994_write(codec, 0x0420, 0x0200);    // AIF2 DAC Filter1(Playback)
+
+        /* Input Path Volume */
+        wm8994_write(codec, 0x0019, 0x008B);    // Left Line Input 3&4 Volume. SPK Mic using the IN2NL | DM1CDAT1
+        wm8994_write(codec, 0x0604, 0x0000);    // DAC2 Left Mixer Routing
+    	wm8994_write(codec, 0x0605, 0x0000);    // DAC2 Right Mixer Routing
+
+        DEBUG_LOG("===========================> The speaker voice path is muted.");
+    }
+    else if(path == BT)
+    {
+        /* Output Path Volume */
+        wm8994_write(codec, 0x0420, 0x0200);    // AIF1 DAC1 FIlter(Playback)
+        
+        /* Input Path Routing */
+        wm8994_write(codec, 0x0604, 0x0007);    // DAC2 Left Mixer Routing(Playback)
+        wm8994_write(codec, 0x0605, 0x0007);    // DAC2 Right Mixer(Playback)
+    
+        wm8994_write(codec, 0x0707, 0x8000);    // GPIO 8. BT PCM DOUT
+        wm8994_write(codec, 0x0708, 0x0000);    // GPIO 9. BT PCM DIN
+        wm8994_write(codec, 0x0709, 0x0000);    // GPIO 10. BT PCM SYNC
+        wm8994_write(codec, 0x070A, 0x0000);    // GPIO 11. BT PCM CLK
+
+        /* Input Path Volume */
+    	wm8994_write(codec, 0x0612, 0x0100);    // DAC2 Left Volume(Playback)
+    	wm8994_write(codec, 0x0613, 0x0100);    // DAC2 Right Volume(Playback)
+    	wm8994_write(codec, 0x0402, (WM8994_AIF1DAC1_VU | 0x0000));    // AIF1 DAC1 Left Volume(Playback)
+
+        DEBUG_LOG("===========================> The bluetooth voice path is muted.");
+    }
+}
+
+void wm8994_set_end_point_volume(struct snd_soc_codec *codec, int path)
+{
+    switch(path)
+    {
+        case RCV :
+        {
+            wm8994_write(codec, 0x001F, 0x0000);    // HPOUT2 Volume
+
+            DEBUG_LOG("===========================> The end point volume for a receiver is set.");
+            break;
+        }
+        case HP :
+        {
+            if(tty_mode == TTY_MODE_HCO)
+            {
+                wm8994_write(codec, 0x001F, 0x0000);    // HPOUT2 Volume
+            }
+            else if(tty_mode == TTY_MODE_FULL || tty_mode == TTY_MODE_VCO)
+            {
+                wm8994_write(codec, 0x001C, 0x0179);    // Left Output Volume
+                wm8994_write(codec, 0x001D, 0x0179);    // Right Output Volume
+            }
+            else
+            {
+                wm8994_write(codec, 0x001C, 0x0170);    // Left Output Volume
+                wm8994_write(codec, 0x001D, 0x0170);    // Right Output Volume
+            }
+            DEBUG_LOG("===========================> The end point volume for a headset is set.");
+            break;
+        }
+		case HP_NO_MIC:
+		{
+			wm8994_write(codec, 0x001C, 0x0179);    // Left Output Volume
+            wm8994_write(codec, 0x001D, 0x0179);    // Right Output Volume
+
+			DEBUG_LOG("===========================> The end point volume for a 3 polar headset is set.");
+			break;
+		}
+        case SPK :
+        {
+            wm8994_write(codec, 0x0026, 0x017E);    // Speaker Volume Left
+
+            DEBUG_LOG("===========================> The end point volume for a speaker is set.");
+            break;
+        }
+        case BT :
+        {
+            wm8994_write(codec, 0x0612, 0x01C0);    // DAC2 Left Volume(Playback)
+	        wm8994_write(codec, 0x0613, 0x01C0);    // DAC2 Right Volume(Playback)
+
+            DEBUG_LOG("===========================> The end point volume for a bluetooth is set.");
+            break;
+        }
+        default :
+        {
+            break;
+        }
+    }
+}
+
+#endif
+
+int wm8994_set_codec_gain(struct snd_soc_codec *codec, u16 mode, u16 device)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int i;
+	u32 gain_set_bits = COMMON_SET_BIT;
+	u16 val;
+	struct gain_info_t *default_gain_table_p = NULL;
+	int table_num = 0;
+
+	if (mode == PLAYBACK_MODE) {
+		default_gain_table_p = playback_gain_table;
+		table_num = PLAYBACK_GAIN_NUM;
+
+		switch (device) {
+		case PLAYBACK_RCV:
+			gain_set_bits |= PLAYBACK_RCV;
+			break;
+		case PLAYBACK_SPK:
+			gain_set_bits |= PLAYBACK_SPK;
+			break;
+		case PLAYBACK_HP:
+			gain_set_bits |= PLAYBACK_HP;
+			break;
+		case PLAYBACK_BT:
+			gain_set_bits |= PLAYBACK_BT;
+			break;
+		case PLAYBACK_SPK_HP:
+			gain_set_bits |= PLAYBACK_SPK_HP;
+			break;
+		case PLAYBACK_RING_SPK:
+			gain_set_bits |= (PLAYBACK_SPK | PLAYBACK_RING_SPK);
+			break;
+		case PLAYBACK_RING_HP:
+			gain_set_bits |= (PLAYBACK_HP | PLAYBACK_RING_HP);
+			break;
+		case PLAYBACK_RING_SPK_HP:
+			gain_set_bits |= (PLAYBACK_SPK_HP |
+					PLAYBACK_RING_SPK_HP);
+			break;
+		case PLAYBACK_HP_NO_MIC:
+			gain_set_bits |= PLAYBACK_HP_NO_MIC;
+			break;
+		default:
+			pr_err("playback modo gain flag is wrong\n");
+			break;
+		}
+	} else if (mode == VOICECALL_MODE) {
+		default_gain_table_p = voicecall_gain_table;
+		table_num = VOICECALL_GAIN_NUM;
+
+		switch (device) {
+		case VOICECALL_RCV:
+			gain_set_bits |= VOICECALL_RCV;
+			break;
+		case VOICECALL_SPK:
+			gain_set_bits |= VOICECALL_SPK;
+			break;
+		case VOICECALL_HP:
+			gain_set_bits |= VOICECALL_HP;
+			break;
+		case VOICECALL_HP_NO_MIC:
+			gain_set_bits |= VOICECALL_HP_NO_MIC;
+			break;
+		case VOICECALL_BT:
+			gain_set_bits |= VOICECALL_BT;
+			break;
+		default:
+			pr_err("voicemode gain flag is wrong\n");
+		}
+	} else if (mode  == RECORDING_MODE) {
+		default_gain_table_p = recording_gain_table;
+		table_num = RECORDING_GAIN_NUM;
+
+		switch (device) {
+		case RECORDING_MAIN:
+			gain_set_bits |= RECORDING_MAIN;
+			break;
+		case RECORDING_HP:
+			gain_set_bits |= RECORDING_HP;
+			break;
+		case RECORDING_BT:
+			gain_set_bits |= RECORDING_BT;
+			break;
+		case RECORDING_REC_MAIN:
+			gain_set_bits |= RECORDING_REC_MAIN;
+			break;
+		case RECORDING_REC_HP:
+			gain_set_bits |= RECORDING_REC_HP;
+			break;
+		case RECORDING_REC_BT:
+			gain_set_bits |= RECORDING_REC_BT;
+			break;
+		case RECORDING_CAM_MAIN:
+			gain_set_bits |= RECORDING_CAM_MAIN;
+			break;
+		case RECORDING_CAM_HP:
+			gain_set_bits |= RECORDING_CAM_HP;
+			break;
+		case RECORDING_CAM_BT:
+			gain_set_bits |= RECORDING_CAM_BT;
+			break;
+		default:
+			pr_err("recording gain flag is wrong\n");
+		}
+
+	}
+
+	DEBUG_LOG("Set gain mode = 0x%x, device = 0x%x, gain_bits = 0x%x,\
+		table_num=%d, gain_code = %d\n",
+		mode, device, gain_set_bits, table_num, wm8994->gain_code);
+
+	/* default gain table setting */
+	for (i = 0; i < table_num; i++) {
+		if ((default_gain_table_p + i)->mode & gain_set_bits) {
+			val = wm8994_read(codec, (default_gain_table_p + i)->reg);
+			val &= ~((default_gain_table_p + i)->mask);
+			val |= (default_gain_table_p + i)->gain;
+			wm8994_write(codec, (default_gain_table_p + i)->reg, val);
+		}
+	}
+
+	if (wm8994->gain_code) {
+		gain_set_bits &= ~(COMMON_SET_BIT);
+		gain_set_bits |= (mode | GAIN_DIVISION_BIT);
+		default_gain_table_p = gain_code_table;
+		table_num = GAIN_CODE_NUM;
+
+		for (i = 0; i < table_num; i++) {
+			if ((default_gain_table_p + i)->mode == gain_set_bits) {
+				val = wm8994_read(codec, (default_gain_table_p + i)->reg);
+				val &= ~((default_gain_table_p + i)->mask);
+				val |= (default_gain_table_p + i)->gain;
+				wm8994_write(codec, (default_gain_table_p + i)->reg, val);
+			}
+		}
+
+	}
+	return 0;
+
+}
+
diff --git a/Kernel/sound/soc/codecs/wm8994_samsung.c.orig b/Kernel/sound/soc/codecs/wm8994_samsung.c.orig
new file mode 100644
index 0000000..261c95d
--- /dev/null
+++ b/Kernel/sound/soc/codecs/wm8994_samsung.c.orig
@@ -0,0 +1,3556 @@
+/*
+ * wm8994_samsung.c  --  WM8994 ALSA Soc Audio driver
+ *
+ * Copyright 2010 Wolfson Microelectronics PLC.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ * Notes:
+ *  The WM8994 is a multichannel codec with S/PDIF support, featuring six
+ *  DAC channels and two ADC channels.
+ *
+ *  Currently only the primary audio interface is supported - S/PDIF and
+ *  the secondary audio interfaces are not.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <asm/div64.h>
+#include <linux/io.h>
+#include <plat/map-base.h>
+#include <linux/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/regs-clock.h>
+#include "wm8994_samsung.h"
+#ifdef CONFIG_SND_VOODOO
+#include "wm8994_voodoo.h"
+#endif
+
+#ifdef FEATURE_SS_AUDIO_CAL
+#include <linux/proc_fs.h>
+#include <linux/sec_jack.h>
+#include <linux/param.h>
+#endif
+
+#define WM8994_VERSION "0.1"
+#define SUBJECT "wm8994_samsung.c"
+
+#if defined(CONFIG_VIDEO_TV20) && defined(CONFIG_SND_S5P_WM8994_MASTER)
+#define HDMI_USE_AUDIO
+#endif
+
+/*
+ *Definitions of clock related.
+*/
+
+static struct {
+	int ratio;
+	int clk_sys_rate;
+} clk_sys_rates[] = {
+	{ 64,   0 },
+	{ 128,  1 },
+	{ 192,  2 },
+	{ 256,  3 },
+	{ 384,  4 },
+	{ 512,  5 },
+	{ 768,  6 },
+	{ 1024, 7 },
+	{ 1408, 8 },
+	{ 1536, 9 },
+};
+
+static struct {
+	int rate;
+	int sample_rate;
+} sample_rates[] = {
+	{ 8000,  0  },
+	{ 11025, 1  },
+	{ 12000, 2  },
+	{ 16000, 3  },
+	{ 22050, 4  },
+	{ 24000, 5  },
+	{ 32000, 6  },
+	{ 44100, 7  },
+	{ 48000, 8  },
+	{ 88200, 9  },
+	{ 96000, 10  },
+};
+
+static struct {
+	int div;
+	int bclk_div;
+} bclk_divs[] = {
+	{ 1,   0  },
+	{ 2,   1  },
+	{ 4,   2  },
+	{ 6,   3  },
+	{ 8,   4  },
+	{ 12,  5  },
+	{ 16,  6  },
+	{ 24,  7  },
+	{ 32,  8  },
+	{ 48,  9  },
+};
+
+struct snd_soc_dai wm8994_dai;
+EXPORT_SYMBOL_GPL(wm8994_dai);
+
+struct snd_soc_codec_device soc_codec_dev_pcm_wm8994;
+EXPORT_SYMBOL_GPL(soc_codec_dev_pcm_wm8994);
+
+struct snd_soc_codec_device soc_codec_dev_wm8994;
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8994);
+
+/*
+ * Definitions of sound path
+ */
+select_route universal_wm8994_playback_paths[] = {
+	wm8994_disable_path, wm8994_set_playback_receiver,
+	wm8994_set_playback_speaker, wm8994_set_playback_headset,
+	wm8994_set_playback_headset, wm8994_set_playback_bluetooth,
+	wm8994_set_playback_speaker_headset
+};
+
+select_route universal_wm8994_voicecall_paths[] = {
+	wm8994_disable_path, wm8994_set_voicecall_receiver,
+	wm8994_set_voicecall_speaker, wm8994_set_voicecall_headset,
+	wm8994_set_voicecall_headphone, wm8994_set_voicecall_bluetooth
+};
+
+select_mic_route universal_wm8994_mic_paths[] = {
+	wm8994_record_main_mic,
+	wm8994_record_headset_mic,
+	wm8994_record_bluetooth,
+};
+
+select_clock_control universal_clock_controls = wm8994_configure_clock;
+
+int gain_code;
+
+#ifdef FEATURE_SS_AUDIO_CAL
+unsigned int tty_mode = TTY_MODE_OFF;
+static struct proc_dir_entry *tty_procfs_dir, *ttymode_file;
+unsigned int loopback_mode = LOOPBACK_MODE_OFF;
+static struct proc_dir_entry *pba_loopback_mode_file, *simpletest_loopback_mode_file;
+static struct snd_soc_codec *saved_codec = NULL;
+static struct timer_list pop_noise_delete_timer;
+static struct timer_list override_timer;
+static int timer_on = 0;
+static int override_timer_on = 0;
+static struct snd_kcontrol *snd_saved_kcontrol = NULL;
+static struct snd_ctl_elem_value *snd_saved_ctl_elem_value = NULL;
+#define TTY_DIR_NAME "sound_tty"
+#define POP_NOISE_DELETE_DELAY_TIME get_jiffies_64() + (1 * HZ)    // 10s
+#define POP_NOISE_DELETE_DELAY_TIME_IN_CALL get_jiffies_64() + (HZ/10)    // 0.1s
+#define OVERRIDE_TIME get_jiffies_64() + (1 * HZ)    // 1s
+
+static int wm8994_set_voice_path(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+static int configure_clock(struct snd_soc_codec *codec);
+
+static int proc_read_ttymode(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    if((tty_mode != TTY_MODE_FULL) && (tty_mode != TTY_MODE_HCO) && (tty_mode != TTY_MODE_VCO))
+    {
+        tty_mode = TTY_MODE_OFF;
+    }
+    
+    return snprintf(page, count, "%d\n", tty_mode);
+}
+
+
+static int proc_write_ttymode(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+    char buf[] = "0x00000000\n";
+    unsigned long len = min((unsigned long)sizeof(buf) - 1, count);
+    unsigned long val;
+    
+    if (copy_from_user(buf, buffer, len))
+    return count;
+    
+    buf[len] = 0;
+    if (sscanf(buf, "%li", &val) != 1)
+    {
+        printk(KERN_INFO TTY_DIR_NAME ": %s is not in hex or decimal form.\n", buf); 
+    }
+    else
+    {
+        tty_mode = val;
+        
+        if((tty_mode != TTY_MODE_FULL) && (tty_mode != TTY_MODE_HCO) && (tty_mode != TTY_MODE_VCO))
+        {
+            tty_mode = TTY_MODE_OFF;			
+        }
+    }
+
+    return strnlen(buf, len);
+}
+
+/*    tty_mode   */
+static int init_tty_mode_procfs(void)
+{
+    int ret = 0;
+    
+    /* create directory */
+    tty_procfs_dir = proc_mkdir(TTY_DIR_NAME, NULL);
+    if(tty_procfs_dir == NULL) 
+    {
+        ret = -ENOMEM;
+        goto out;
+    }
+    
+//    tty_procfs_dir->owner = THIS_MODULE;
+    
+    /* create tty_mode files */
+    ttymode_file = create_proc_entry("tty_mode", 0666, tty_procfs_dir);
+    if(ttymode_file == NULL) 
+    {
+        ret = -ENOMEM;
+        goto no_ttymode;
+    }
+    
+    ttymode_file->data = &tty_mode;
+    ttymode_file->read_proc = proc_read_ttymode;
+    ttymode_file->write_proc = proc_write_ttymode;
+//    ttymode_file->owner = THIS_MODULE;
+    
+    /* everything OK */
+    printk(KERN_INFO "%s procfs initialised\n", TTY_DIR_NAME);
+    
+    return 0;
+    
+    no_ttymode:
+    remove_proc_entry("tty_mode", tty_procfs_dir);
+    remove_proc_entry(TTY_DIR_NAME, NULL);
+    out:
+    return ret;
+}
+
+/*   tty_mode   */
+static void cleanup_tty_mode_procfs(void)
+{
+    remove_proc_entry("tty_mode", tty_procfs_dir);
+    remove_proc_entry(TTY_DIR_NAME, NULL);
+    
+    printk(KERN_INFO "%s procfs removed\n", TTY_DIR_NAME);
+}
+
+static int pop_noise_delete_timer_work_func(struct work_struct *ignored)
+{
+    if(snd_saved_kcontrol && snd_saved_ctl_elem_value)
+    {
+        struct snd_soc_codec *codec = snd_kcontrol_chip(snd_saved_kcontrol);
+        struct wm8994_priv *wm8994 = codec->drvdata;
+    
+        timer_on = 0;
+        del_timer(&pop_noise_delete_timer);
+//        wm8994_set_call_path(snd_saved_kcontrol, snd_saved_ctl_elem_value);
+//       wm8994_set_end_point_volume(codec, wm8994->cur_path);
+    }
+}
+
+static DECLARE_WORK(pop_noise_delete_timer_work, pop_noise_delete_timer_work_func);
+
+static void pop_noise_delete_timer_handler(unsigned long arg)
+{
+	schedule_work(&pop_noise_delete_timer_work);
+}
+
+static int override_timer_work_func(struct work_struct *ignored)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(snd_saved_kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+    if(wm8994->codec_state == DEACTIVE)
+    {
+        override_timer_on = 0;
+        snd_saved_ctl_elem_value = NULL;
+        snd_saved_kcontrol = NULL;
+    
+        del_timer(&override_timer);
+        wm8994_mute_voicecall_path(codec, wm8994->cur_path);
+        wm8994_write(codec, WM8994_SOFTWARE_RESET, 0x0000);
+    }
+}
+
+static DECLARE_WORK(override_timer_work, override_timer_work_func);
+
+static void override_timer_handler(unsigned long arg)
+{
+	schedule_work(&override_timer_work);
+}
+
+static int proc_read_loopback_mode(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    return snprintf(page, count, "%d\n", loopback_mode);
+}
+
+static int proc_write_pba_loopback_mode(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+    char buf[] = "0x00000000\n";
+    unsigned long len = min((unsigned long)sizeof(buf) - 1, count);
+    unsigned long val;
+
+    if (copy_from_user(buf, buffer, len))
+    {
+        return count;
+    }
+    
+    buf[len] = 0;
+    
+    if (sscanf(buf, "%li", &val) != 1)
+    {
+        printk(KERN_INFO TTY_DIR_NAME ": %s is not in hex or decimal form.\n", buf); 
+    }
+    else
+    {
+        loopback_mode = PBA_LOOPBACK_MODE_ON;
+    }
+
+    DEBUG_LOG("Loopback Mode = %d.", loopback_mode);
+    
+    return strnlen(buf, len);
+}
+
+static int proc_write_simpletest_loopback_mode(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+    char buf[] = "0x00000000\n";
+    unsigned long len = min((unsigned long)sizeof(buf) - 1, count);
+    unsigned long val;
+
+    if (copy_from_user(buf, buffer, len))
+    {
+        return count;
+    }
+    
+    buf[len] = 0;
+    
+    if (sscanf(buf, "%li", &val) != 1)
+    {
+        printk(KERN_INFO TTY_DIR_NAME ": %s is not in hex or decimal form.\n", buf); 
+    }
+    else if(loopback_mode != PBA_LOOPBACK_MODE_ON)
+    {
+        loopback_mode = SIMPLETEST_LOOPBACK_MODE_ON;
+    }
+
+    DEBUG_LOG("Loopback Mode = %d.", loopback_mode);
+    
+    return strnlen(buf, len);
+}
+
+/*    tty_mode   */
+static int init_loopback_mode_procfs(void)
+{
+    int ret = 0;
+    
+    /* create loopback_mode files */
+    pba_loopback_mode_file = create_proc_entry("loopback_mode", 0666, tty_procfs_dir);
+    simpletest_loopback_mode_file = create_proc_entry("loopback_15", 0666, tty_procfs_dir);
+    
+    if(!pba_loopback_mode_file || !simpletest_loopback_mode_file)
+    {
+        ret = -ENOMEM;
+        goto no_ttymode;
+    }
+    
+    pba_loopback_mode_file->data = &loopback_mode;
+    pba_loopback_mode_file->read_proc = proc_read_loopback_mode;
+    pba_loopback_mode_file->write_proc = proc_write_pba_loopback_mode;
+//    pba_loopback_mode_file->owner = THIS_MODULE;
+
+    simpletest_loopback_mode_file->data = &loopback_mode;
+    simpletest_loopback_mode_file->read_proc = proc_read_loopback_mode;
+    simpletest_loopback_mode_file->write_proc = proc_write_simpletest_loopback_mode;
+//    simpletest_loopback_mode_file->owner = THIS_MODULE;
+    
+    /* everything OK */
+    printk(KERN_INFO "%s procfs initialised\n", TTY_DIR_NAME);
+    
+    return 0;
+    
+    no_ttymode:
+    remove_proc_entry("loopback_mode", tty_procfs_dir);
+    remove_proc_entry(TTY_DIR_NAME, NULL);
+    out:
+    return ret;
+}
+
+static int wm8994_ready_call_path(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    struct wm8994_priv *wm8994 = codec->drvdata;
+
+    if(wm8994->codec_state & CALL_ACTIVE)
+    {
+        wm8994_set_voice_path(kcontrol, ucontrol);
+    }
+    else
+    {
+        if(override_timer_on)
+        {
+            override_timer_on = 0;
+            snd_saved_ctl_elem_value = NULL;
+            snd_saved_kcontrol = NULL;
+        
+            del_timer(&override_timer);
+            wm8994_mute_voicecall_path(codec, wm8994->cur_path);
+            wm8994_write(codec, WM8994_SOFTWARE_RESET, 0x0000);
+        
+            msleep(50);
+            DEBUG_LOG("The override timer is deleted.");
+        }
+        snd_saved_kcontrol = kcontrol;
+        snd_saved_ctl_elem_value = ucontrol;
+        timer_on = 1;
+
+        wm8994_set_voice_path(kcontrol, ucontrol);
+        mod_timer(&pop_noise_delete_timer, POP_NOISE_DELETE_DELAY_TIME);
+        DEBUG_LOG("pop_noise_delete_timer is called.");
+    }
+
+    return 0;
+}
+#endif
+
+/*
+ * Implementation of I2C functions
+ */
+static unsigned int wm8994_read_hw(struct snd_soc_codec *codec, u16 reg)
+{
+	struct i2c_msg xfer[2];
+	u16 data;
+	int ret;
+	struct i2c_client *i2c = codec->control_data;
+
+	data = ((reg & 0xff00) >> 8) | ((reg & 0xff) << 8);
+
+	xfer[0].addr = i2c->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 2;
+	xfer[0].buf = (void *)&data;
+
+	xfer[1].addr = i2c->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = 2;
+	xfer[1].buf = (u8 *)&data;
+	ret = i2c_transfer(i2c->adapter, xfer, 2);
+	if (ret != 2) {
+		dev_err(codec->dev, "Failed to read 0x%x: %d\n", reg, ret);
+		return 0;
+	}
+
+	return (data >> 8) | ((data & 0xff) << 8);
+}
+
+int wm8994_write(struct snd_soc_codec *codec, unsigned int reg,
+		 unsigned int value)
+{
+	u8 data[4];
+	int ret;
+
+#ifdef CONFIG_SND_VOODOO
+  value = voodoo_hook_wm8994_write(codec, reg, value);
+#endif
+
+	/* data is
+	 * D15..D9 WM8993 register offset
+	 * D8...D0 register data
+	 */
+	data[0] = (reg & 0xff00) >> 8;
+	data[1] = reg & 0x00ff;
+	data[2] = value >> 8;
+	data[3] = value & 0x00ff;
+	ret = codec->hw_write(codec->control_data, data, 4);
+
+	if (ret == 4)
+		return 0;
+	else {
+		pr_err("i2c write problem occured\n");
+		return ret;
+	}
+}
+
+unsigned int wm8994_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	return wm8994_read_hw(codec, reg);
+}
+
+static int wm8994_ldo_control(struct wm8994_platform_data *pdata, int en)
+{
+
+	if (!pdata) {
+		pr_err("failed to control wm8994 ldo\n");
+		return -EINVAL;
+	}
+
+	gpio_set_value(pdata->ldo, en);
+
+	if (en)
+		msleep(10);
+	else
+		msleep(125);
+
+	return 0;
+
+}
+
+/*
+ * Functions related volume.
+ */
+static const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);
+
+static int wm899x_outpga_put_volsw_vu(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	u16 val;
+
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("");
+
+	ret = snd_soc_put_volsw_2r(kcontrol, ucontrol);
+	if (ret < 0)
+		return ret;
+
+	/* Volume changes in the headphone path mean we need to
+	 * recallibrate DC servo */
+	if (strcmp(kcontrol->id.name, "Playback Spkr Volume") == 0 ||
+	    strcmp(kcontrol->id.name, "Playback Volume") == 0)
+		memset(wm8994->dc_servo, 0, sizeof(wm8994->dc_servo));
+
+	val = wm8994_read(codec, reg);
+
+	return wm8994_write(codec, reg, val | 0x0100);
+}
+
+static int wm899x_inpga_put_volsw_vu(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_mixer_control *mc =
+	    (struct soc_mixer_control *)kcontrol->private_value;
+	int reg = mc->reg;
+	int ret;
+	u16 val;
+
+	ret = snd_soc_put_volsw(kcontrol, ucontrol);
+
+	if (ret < 0)
+		return ret;
+
+	val = wm8994_read(codec, reg);
+
+	return wm8994_write(codec, reg, val | 0x0100);
+
+}
+
+/*
+ * Implementation of sound path
+ */
+#define MAX_PLAYBACK_PATHS 10
+#define MAX_VOICECALL_PATH 5
+static const char *playback_path[] = {
+	"OFF", "RCV", "SPK", "HP", "HP_NO_MIC", "BT", "SPK_HP",
+	"RING_SPK", "RING_HP", "RING_NO_MIC", "RING_SPK_HP"
+};
+static const char *voicecall_path[] = { "OFF", "RCV", "SPK", "HP",
+					"HP_NO_MIC", "BT" };
+static const char *mic_path[] = { "Main Mic", "Hands Free Mic",
+					"BT Sco Mic", "MIC OFF" };
+static const char *input_source_state[] = { "Default", "Voice Recognition",
+					"Camcorder" };
+
+static int wm8994_get_mic_path(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	ucontrol->value.integer.value[0] = wm8994->rec_path;
+
+	return 0;
+}
+
+static int wm8994_set_mic_path(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("");
+
+	wm8994->codec_state |= CAPTURE_ACTIVE;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		wm8994->rec_path = MAIN;
+		break;
+	case 1:
+		wm8994->rec_path = SUB;
+		break;
+	case 2:
+		wm8994->rec_path = BT_REC;
+		break;
+	case 3:
+		wm8994_disable_rec_path(codec);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	wm8994->universal_mic_path[wm8994->rec_path] (codec);
+
+	return 0;
+}
+
+static int wm8994_get_path(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	ucontrol->value.integer.value[0] = wm8994->cur_path;
+
+	return 0;
+}
+
+static int wm8994_set_path(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	struct soc_enum *mc = (struct soc_enum *)kcontrol->private_value;
+	int val;
+	int path_num = ucontrol->value.integer.value[0];
+
+	if (strcmp(mc->texts[path_num], playback_path[path_num])) {
+		DEBUG_LOG_ERR("Unknown path %s\n", mc->texts[path_num]);
+		return -ENODEV;
+	}
+
+	if (path_num > MAX_PLAYBACK_PATHS) {
+		DEBUG_LOG_ERR("Unknown Path\n");
+		return -ENODEV;
+	}
+
+	switch (path_num) {
+	case OFF:
+		DEBUG_LOG("Switching off output path\n");
+		break;
+	case RCV:
+	case SPK:
+	case HP:
+	case HP_NO_MIC:
+	case BT:
+	case SPK_HP:
+		DEBUG_LOG("routing to %s\n", mc->texts[path_num]);
+		wm8994->ringtone_active = RING_OFF;
+		break;
+	case RING_SPK:
+	case RING_HP:
+	case RING_NO_MIC:
+		DEBUG_LOG("routing to %s\n", mc->texts[path_num]);
+		wm8994->ringtone_active = RING_ON;
+		path_num -= 5;
+		break;
+	case RING_SPK_HP:
+		DEBUG_LOG("routing to %s\n", mc->texts[path_num]);
+		wm8994->ringtone_active = RING_ON;
+		path_num -= 4;
+		break;
+	default:
+		DEBUG_LOG_ERR("audio path[%d] does not exists!!\n", path_num);
+		return -ENODEV;
+		break;
+	}
+
+	wm8994->codec_state |= PLAYBACK_ACTIVE;
+
+	if (wm8994->codec_state & CALL_ACTIVE) 
+	{
+#ifdef FEATURE_SS_AUDIO_CAL
+		snd_saved_ctl_elem_value = NULL;
+		snd_saved_kcontrol = NULL;
+		timer_on = 0;
+//			  override_timer_on = 1;
+		del_timer(&pop_noise_delete_timer);
+//			  mod_timer(&override_timer, OVERRIDE_TIME);
+		wm8994->codec_state &= ~(CALL_ACTIVE);
+		wm8994_mute_voicecall_path(codec, wm8994->cur_path);
+
+//			  DEBUG_LOG("The pop_noise_delete_timer is deleted. And, the override timer is setup.");
+		DEBUG_LOG("Call Flag is clear!!");
+#endif
+		wm8994->codec_state &= ~(CALL_ACTIVE);
+
+		val = wm8994_read(codec, WM8994_CLOCKING_1);
+		val &= ~(WM8994_DSP_FS2CLK_ENA_MASK | WM8994_SYSCLK_SRC_MASK);
+		wm8994_write(codec, WM8994_CLOCKING_1, val);
+	}
+
+	wm8994->cur_path = path_num;
+	wm8994->universal_playback_path[wm8994->cur_path] (codec);
+
+	return 0;
+}
+
+static int wm8994_get_voice_path(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	ucontrol->value.integer.value[0] = wm8994->cur_path;
+
+	return 0;
+}
+
+static int wm8994_set_voice_path(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	struct soc_enum *mc = (struct soc_enum *)kcontrol->private_value;
+
+	int path_num = ucontrol->value.integer.value[0];
+
+	if (strcmp(mc->texts[path_num], voicecall_path[path_num])) {
+		DEBUG_LOG_ERR("Unknown path %s\n", mc->texts[path_num]);
+		return -ENODEV;
+	}
+
+	switch (path_num) {
+	case OFF:
+		DEBUG_LOG("Switching off output path\n");
+		break;
+	case RCV:
+	case SPK:
+	case HP:
+	case HP_NO_MIC:
+	case BT:
+		DEBUG_LOG("routing  voice path to %s\n", mc->texts[path_num]);
+		break;
+	default:
+		DEBUG_LOG_ERR("path[%d] does not exists!\n", path_num);
+		return -ENODEV;
+		break;
+	}
+
+	if (wm8994->cur_path != path_num || !(wm8994->codec_state & CALL_ACTIVE)) 
+	{
+#ifdef FEATURE_SS_AUDIO_CAL
+				if(wm8994->cur_path != path_num && (wm8994->codec_state & CALL_ACTIVE))
+				{
+					wm8994_mute_voicecall_path(codec, wm8994->cur_path);
+					//msleep(50);
+				}
+				saved_codec = codec;	// for later using.
+		
+#if 0
+				if(vps_enable)
+				{
+					wm8994_set_voicecall_vps(codec);
+				}
+				else
+#endif
+				{
+					wm8994->cur_path = path_num;
+					wm8994->universal_voicecall_path[wm8994->cur_path](codec);
+					wm8994->codec_state |= CALL_ACTIVE;
+					configure_clock(codec); 	   
+				}
+#else
+				wm8994->codec_state |= CALL_ACTIVE;
+				wm8994->cur_path = path_num;
+				wm8994->universal_voicecall_path[wm8994->cur_path](codec);
+#endif
+	} 
+	else {
+		int val;
+		val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+		val &= ~(WM8994_AIF1DAC1_MUTE_MASK);
+		val |= (WM8994_AIF1DAC1_UNMUTE);
+		wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+	}
+
+	return 0;
+}
+
+static int wm8994_get_input_source(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("input_source_state = [%d]", wm8994->input_source);
+
+	return wm8994->input_source;
+}
+
+static int wm8994_set_input_source(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	int control_flag = ucontrol->value.integer.value[0];
+
+	DEBUG_LOG("Changed input_source state [%d] => [%d]",
+			wm8994->input_source, control_flag);
+
+	wm8994->input_source = control_flag;
+
+	return 0;
+}
+
+#define  SOC_WM899X_OUTPGA_DOUBLE_R_TLV(xname, reg_left, reg_right,\
+		xshift, xmax, xinvert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw_2r, \
+	.get = snd_soc_get_volsw_2r, .put = wm899x_outpga_put_volsw_vu, \
+	.private_value = (unsigned long)&(struct soc_mixer_control) \
+		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
+		.max = xmax, .invert = xinvert} }
+
+#define SOC_WM899X_OUTPGA_SINGLE_R_TLV(xname, reg, shift, max, invert,\
+		tlv_array) {\
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+		.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+				SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+		.tlv.p = (tlv_array), \
+		.info = snd_soc_info_volsw, \
+		.get = snd_soc_get_volsw, .put = wm899x_inpga_put_volsw_vu, \
+		.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert) }
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -7162, 37, 1);
+static const DECLARE_TLV_DB_LINEAR(digital_tlv_spkr, -5700, 600);
+static const DECLARE_TLV_DB_LINEAR(digital_tlv_rcv, -5700, 600);
+static const DECLARE_TLV_DB_LINEAR(digital_tlv_headphone, -5700, 600);
+static const DECLARE_TLV_DB_LINEAR(digital_tlv_mic, -7162, 7162);
+
+static const struct soc_enum path_control_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(playback_path), playback_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(voicecall_path), voicecall_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mic_path), mic_path),
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(input_source_state), input_source_state),
+};
+
+static const struct snd_kcontrol_new wm8994_snd_controls[] = {
+	SOC_WM899X_OUTPGA_DOUBLE_R_TLV("Playback Volume",
+				       WM8994_LEFT_OPGA_VOLUME,
+				       WM8994_RIGHT_OPGA_VOLUME, 0, 0x3F, 0,
+				       digital_tlv_rcv),
+	SOC_WM899X_OUTPGA_DOUBLE_R_TLV("Playback Spkr Volume",
+				       WM8994_SPEAKER_VOLUME_LEFT,
+				       WM8994_SPEAKER_VOLUME_RIGHT, 1, 0x3F, 0,
+				       digital_tlv_spkr),
+	SOC_WM899X_OUTPGA_DOUBLE_R_TLV("Playback Headset Volume",
+				       WM8994_LEFT_OUTPUT_VOLUME,
+				       WM8994_RIGHT_OUTPUT_VOLUME, 1, 0x3F, 0,
+				       digital_tlv_headphone),
+	SOC_WM899X_OUTPGA_SINGLE_R_TLV("Capture Volume",
+				       WM8994_AIF1_ADC1_LEFT_VOLUME,
+				       0, 0xEF, 0, digital_tlv_mic),
+	/* Path Control */
+	SOC_ENUM_EXT("Playback Path", path_control_enum[0],
+		     wm8994_get_path, wm8994_set_path),
+
+#ifdef FEATURE_SS_AUDIO_CAL
+		SOC_ENUM_EXT("Voice Call Path", path_control_enum[1],
+					wm8994_get_voice_path, wm8994_ready_call_path),
+#else
+		SOC_ENUM_EXT("Voice Call Path", path_control_enum[1],
+					wm8994_get_voice_path, wm8994_set_voice_path),
+#endif
+
+	SOC_ENUM_EXT("Capture MIC Path", path_control_enum[2],
+		     wm8994_get_mic_path, wm8994_set_mic_path),
+
+#if defined USE_INFINIEON_EC_FOR_VT
+	SOC_ENUM_EXT("Clock Control", clock_control_enum[0],
+		     s3c_pcmdev_get_clock, s3c_pcmdev_set_clock),
+#endif
+	SOC_ENUM_EXT("Input Source", path_control_enum[3],
+		     wm8994_get_input_source, wm8994_set_input_source),
+
+};
+
+/* Add non-DAPM controls */
+static int wm8994_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(wm8994_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&wm8994_snd_controls[i],
+					       codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+static const struct snd_soc_dapm_widget wm8994_dapm_widgets[] = {
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+};
+
+static int wm8994_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, wm8994_dapm_widgets,
+			ARRAY_SIZE(wm8994_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static int configure_clock(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	unsigned int reg;
+
+	DEBUG_LOG("");
+
+#ifdef FEATURE_SS_AUDIO_CAL
+		if(!(wm8994->codec_state & CALL_ACTIVE) && (wm8994->codec_state != DEACTIVE))
+		{
+			DEBUG_LOG("Codec is already actvied. Skip clock setting.");
+			return 0;
+		}
+	
+		if(wm8994->codec_state & CALL_ACTIVE)
+		{
+			if(wm8994_read(codec, 0x0224) == 0x0C88)
+			{
+				DEBUG_LOG("Codec is already actvied. Skip clock setting.");
+				
+				return 0;
+			}
+		}
+#else
+		if(wm8994->codec_state != DEACTIVE)
+		{
+			DEBUG_LOG("Codec is already actvied. Skip clock setting.");
+			return 0;
+		}
+#endif
+
+	reg = wm8994_read(codec, WM8994_AIF1_CLOCKING_1);
+	reg &= ~WM8994_AIF1CLK_ENA;
+	reg &= ~WM8994_AIF1CLK_SRC_MASK;
+	wm8994_write(codec, WM8994_AIF1_CLOCKING_1, reg);
+
+	switch (wm8994->sysclk_source) {
+	case WM8994_SYSCLK_MCLK:
+		dev_dbg(codec->dev, "Using %dHz MCLK\n", wm8994->mclk_rate);
+
+		reg = wm8994_read(codec, WM8994_AIF1_CLOCKING_1);
+		reg &= ~WM8994_AIF1CLK_ENA;
+		wm8994_write(codec, WM8994_AIF1_CLOCKING_1, reg);
+
+		reg = wm8994_read(codec, WM8994_AIF1_CLOCKING_1);
+		reg &= 0x07;
+
+		if (wm8994->mclk_rate > 13500000) {
+			reg |= WM8994_AIF1CLK_DIV;
+			wm8994->sysclk_rate = wm8994->mclk_rate / 2;
+		} else {
+			reg &= ~WM8994_AIF1CLK_DIV;
+			wm8994->sysclk_rate = wm8994->mclk_rate;
+		}
+		reg |= WM8994_AIF1CLK_ENA;
+		wm8994_write(codec, WM8994_AIF1_CLOCKING_1, reg);
+
+		/* Enable clocks to the Audio core and sysclk of wm8994 */
+		reg = wm8994_read(codec, WM8994_CLOCKING_1);
+		reg &= ~(WM8994_SYSCLK_SRC_MASK | WM8994_DSP_FSINTCLK_ENA_MASK
+				| WM8994_DSP_FS1CLK_ENA_MASK);
+		reg |= (WM8994_DSP_FS1CLK_ENA | WM8994_DSP_FSINTCLK_ENA);
+		wm8994_write(codec, WM8994_CLOCKING_1, reg);
+		break;
+
+	case WM8994_SYSCLK_FLL:
+		switch (wm8994->fs) {
+		case 8000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x2F00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x3126);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 11025:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x1F00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x86C2);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x00e0);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 12000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x1F00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x3126);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 16000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x1900);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0xE23E);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 22050:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x0F00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x86C2);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x00E0);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 24000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x0F00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x3126);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 32000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x0C00);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0xE23E);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 44100:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x0700);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x86C2);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x00E0);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		case 48000:
+			wm8994_write(codec, WM8994_FLL1_CONTROL_2, 0x0700);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_3, 0x3126);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_5, 0x0C88);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_4, 0x0100);
+			wm8994_write(codec, WM8994_FLL1_CONTROL_1,
+				WM8994_FLL1_FRACN_ENA | WM8994_FLL1_ENA);
+			break;
+
+		default:
+			DEBUG_LOG_ERR("Unsupported Frequency\n");
+			break;
+		}
+
+		reg = wm8994_read(codec, WM8994_AIF1_CLOCKING_1);
+		reg |= WM8994_AIF1CLK_ENA;
+		reg |= WM8994_AIF1CLK_SRC_FLL1;
+		wm8994_write(codec, WM8994_AIF1_CLOCKING_1, reg);
+
+		/* Enable clocks to the Audio core and sysclk of wm8994*/
+		reg = wm8994_read(codec, WM8994_CLOCKING_1);
+		reg &= ~(WM8994_SYSCLK_SRC_MASK | WM8994_DSP_FSINTCLK_ENA_MASK |
+				WM8994_DSP_FS1CLK_ENA_MASK);
+		reg |= (WM8994_DSP_FS1CLK_ENA | WM8994_DSP_FSINTCLK_ENA);
+		wm8994_write(codec, WM8994_CLOCKING_1, reg);
+		break;
+
+	default:
+		dev_err(codec->dev, "System clock not configured\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(codec->dev, "CLK_SYS is %dHz\n", wm8994->sysclk_rate);
+
+	return 0;
+}
+
+static int wm8994_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	DEBUG_LOG("");
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		/* VMID=2*40k */
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
+				    WM8994_VMID_SEL_MASK, 0x2);
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,
+				    WM8994_TSHUT_ENA, WM8994_TSHUT_ENA);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (codec->bias_level == SND_SOC_BIAS_OFF) {
+			/* Bring up VMID with fast soft start */
+			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
+					    WM8994_STARTUP_BIAS_ENA |
+					    WM8994_VMID_BUF_ENA |
+					    WM8994_VMID_RAMP_MASK |
+					    WM8994_BIAS_SRC,
+					    WM8994_STARTUP_BIAS_ENA |
+					    WM8994_VMID_BUF_ENA |
+					    WM8994_VMID_RAMP_MASK |
+					    WM8994_BIAS_SRC);
+			/* VMID=2*40k */
+			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
+					    WM8994_VMID_SEL_MASK |
+					    WM8994_BIAS_ENA,
+					    WM8994_BIAS_ENA | 0x2);
+
+			/* Switch to normal bias */
+			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
+					    WM8994_BIAS_SRC |
+					    WM8994_STARTUP_BIAS_ENA, 0);
+		}
+
+		/* VMID=2*240k */
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
+				    WM8994_VMID_SEL_MASK, 0x4);
+
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,
+				    WM8994_TSHUT_ENA, 0);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_update_bits(codec, WM8994_ANTIPOP_1,
+				    WM8994_LINEOUT_VMID_BUF_ENA, 0);
+
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
+				    WM8994_VMID_SEL_MASK | WM8994_BIAS_ENA, 0);
+		break;
+	}
+
+	codec->bias_level = level;
+
+	return 0;
+}
+
+static int wm8994_set_sysclk(struct snd_soc_dai *codec_dai,
+			     int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("clk_id =%d ", clk_id);
+
+	switch (clk_id) {
+	case WM8994_SYSCLK_MCLK:
+		wm8994->mclk_rate = freq;
+		wm8994->sysclk_source = clk_id;
+		break;
+	case WM8994_SYSCLK_FLL:
+		wm8994->sysclk_rate = freq;
+		wm8994->sysclk_source = clk_id;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	unsigned int aif1 = wm8994_read(codec, WM8994_AIF1_CONTROL_1);
+	unsigned int aif2 = wm8994_read(codec, WM8994_AIF1_MASTER_SLAVE);
+
+	DEBUG_LOG("");
+
+	aif1 &= ~(WM8994_AIF1_LRCLK_INV | WM8994_AIF1_BCLK_INV |
+			WM8994_AIF1_WL_MASK | WM8994_AIF1_FMT_MASK);
+
+	aif2 &= ~(WM8994_AIF1_LRCLK_FRC_MASK |
+			WM8994_AIF1_CLK_FRC | WM8994_AIF1_MSTR);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		wm8994->master = 0;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		aif2 |= (WM8994_AIF1_MSTR | WM8994_AIF1_LRCLK_FRC);
+		wm8994->master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		aif2 |= (WM8994_AIF1_MSTR | WM8994_AIF1_CLK_FRC);
+		wm8994->master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		aif2 |= (WM8994_AIF1_MSTR | WM8994_AIF1_CLK_FRC |
+				WM8994_AIF1_LRCLK_FRC);
+		wm8994->master = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_B:
+		aif1 |= WM8994_AIF1_LRCLK_INV;
+	case SND_SOC_DAIFMT_DSP_A:
+		aif1 |= 0x18;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		aif1 |= 0x10;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		aif1 |= 0x8;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+	case SND_SOC_DAIFMT_DSP_B:
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			aif1 |= WM8994_AIF1_BCLK_INV;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_RIGHT_J:
+	case SND_SOC_DAIFMT_LEFT_J:
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+		case SND_SOC_DAIFMT_IB_IF:
+			aif1 |= WM8994_AIF1_BCLK_INV | WM8994_AIF1_LRCLK_INV;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			aif1 |= WM8994_AIF1_BCLK_INV;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			aif1 |= WM8994_AIF1_LRCLK_INV;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	aif1 |= 0x4000;
+	wm8994_write(codec, WM8994_AIF1_CONTROL_1, aif1);
+	wm8994_write(codec, WM8994_AIF1_MASTER_SLAVE, aif2);
+	wm8994_write(codec, WM8994_AIF1_CONTROL_2, 0x4000);
+
+	return 0;
+}
+
+static int wm8994_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+	int ret, i, best, best_val, cur_val;
+	unsigned int clocking1, clocking3, aif1, aif4, aif5;
+
+	DEBUG_LOG("");
+
+	clocking1 = wm8994_read(codec, WM8994_AIF1_BCLK);
+	clocking1 &= ~WM8994_AIF1_BCLK_DIV_MASK;
+
+	clocking3 = wm8994_read(codec, WM8994_AIF1_RATE);
+	clocking3 &= ~(WM8994_AIF1_SR_MASK | WM8994_AIF1CLK_RATE_MASK);
+
+	aif1 = wm8994_read(codec, WM8994_AIF1_CONTROL_1);
+	aif1 &= ~WM8994_AIF1_WL_MASK;
+	aif4 = wm8994_read(codec, WM8994_AIF1ADC_LRCLK);
+	aif4 &= ~WM8994_AIF1ADC_LRCLK_DIR;
+	aif5 = wm8994_read(codec, WM8994_AIF1DAC_LRCLK);
+	aif5 &= ~WM8994_AIF1DAC_LRCLK_DIR_MASK;
+
+	wm8994->fs = params_rate(params);
+	wm8994->bclk = 2 * wm8994->fs;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		wm8994->bclk *= 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		wm8994->bclk *= 20;
+		aif1 |= (0x01 << WM8994_AIF1_WL_SHIFT);
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		wm8994->bclk *= 24;
+		aif1 |= (0x10 << WM8994_AIF1_WL_SHIFT);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		wm8994->bclk *= 32;
+		aif1 |= (0x11 << WM8994_AIF1_WL_SHIFT);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	ret = configure_clock(codec);
+	if (ret != 0)
+		return ret;
+
+	dev_dbg(codec->dev, "Target BCLK is %dHz\n", wm8994->bclk);
+
+	/* Select nearest CLK_SYS_RATE */
+	if (wm8994->fs == 8000)
+		best = 3;
+	else {
+		best = 0;
+		best_val = abs((wm8994->sysclk_rate / clk_sys_rates[0].ratio)
+				- wm8994->fs);
+
+		for (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {
+			cur_val = abs((wm8994->sysclk_rate /
+					clk_sys_rates[i].ratio)	- wm8994->fs);
+
+			if (cur_val < best_val) {
+				best = i;
+				best_val = cur_val;
+			}
+		}
+		dev_dbg(codec->dev, "Selected CLK_SYS_RATIO of %d\n",
+				clk_sys_rates[best].ratio);
+	}
+
+	clocking3 |= (clk_sys_rates[best].clk_sys_rate
+			<< WM8994_AIF1CLK_RATE_SHIFT);
+
+	/* Sampling rate */
+	best = 0;
+	best_val = abs(wm8994->fs - sample_rates[0].rate);
+	for (i = 1; i < ARRAY_SIZE(sample_rates); i++) {
+		cur_val = abs(wm8994->fs - sample_rates[i].rate);
+		if (cur_val < best_val) {
+			best = i;
+			best_val = cur_val;
+		}
+	}
+	dev_dbg(codec->dev, "Selected SAMPLE_RATE of %dHz\n",
+			sample_rates[best].rate);
+
+	clocking3 |= (sample_rates[best].sample_rate << WM8994_AIF1_SR_SHIFT);
+
+	/* BCLK_DIV */
+	best = 0;
+	best_val = INT_MAX;
+	for (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {
+		cur_val = ((wm8994->sysclk_rate) / bclk_divs[i].div)
+				  - wm8994->bclk;
+		if (cur_val < 0)
+			break;
+		if (cur_val < best_val) {
+			best = i;
+			best_val = cur_val;
+		}
+	}
+	wm8994->bclk = (wm8994->sysclk_rate) / bclk_divs[best].div;
+
+	dev_dbg(codec->dev, "Selected BCLK_DIV of %d for %dHz BCLK\n",
+			bclk_divs[best].div, wm8994->bclk);
+
+	clocking1 |= bclk_divs[best].bclk_div << WM8994_AIF1_BCLK_DIV_SHIFT;
+
+	/* LRCLK is a simple fraction of BCLK */
+	dev_dbg(codec->dev, "LRCLK_RATE is %d\n", wm8994->bclk / wm8994->fs);
+
+	aif4 |= wm8994->bclk / wm8994->fs;
+	aif5 |= wm8994->bclk / wm8994->fs;
+
+#ifdef HDMI_USE_AUDIO
+	/* set bclk to 32fs for 44.1kHz 16 bit playback.*/
+	if (wm8994->fs == 44100)
+		wm8994_write(codec, WM8994_AIF1_BCLK, 0x70);
+#endif
+
+	wm8994_write(codec, WM8994_AIF1_RATE, clocking3);
+	wm8994_write(codec, WM8994_AIF1_CONTROL_1, aif1);
+
+	return 0;
+}
+
+static int wm8994_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	int mute_reg;
+	int reg;
+
+	switch (codec_dai->id) {
+	case 1:
+		mute_reg = WM8994_AIF1_DAC1_FILTERS_1;
+		break;
+	case 2:
+		mute_reg = WM8994_AIF2_DAC_FILTERS_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (mute)
+		reg = WM8994_AIF1DAC1_MUTE;
+	else
+		reg = 0;
+
+	snd_soc_update_bits(codec, mute_reg, WM8994_AIF1DAC1_MUTE, reg);
+
+	return 0;
+}
+
+static int wm8994_startup(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		wm8994->stream_state |=  PCM_STREAM_PLAYBACK;
+	else
+		wm8994->stream_state |= PCM_STREAM_CAPTURE;
+
+
+	if (wm8994->power_state == CODEC_OFF) {
+		wm8994->power_state = CODEC_ON;
+		DEBUG_LOG("Turn on codec!! Power state =[%d]",
+				wm8994->power_state);
+
+		/* For initialize codec */
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_1,
+				0x3 << WM8994_VMID_SEL_SHIFT | WM8994_BIAS_ENA);
+		msleep(50);
+		wm8994_write(codec, WM8994_POWER_MANAGEMENT_1,
+				WM8994_VMID_SEL_NORMAL | WM8994_BIAS_ENA);
+		wm8994_write(codec, WM8994_OVERSAMPLING, 0x0000);
+	} else
+		DEBUG_LOG("Already turned on codec!!");
+
+	return 0;
+}
+
+static void wm8994_shutdown(struct snd_pcm_substream *substream,
+			    struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("Stream_state = [0x%X],  Codec State = [0x%X]",
+			wm8994->stream_state, wm8994->codec_state);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		wm8994->stream_state &=  ~(PCM_STREAM_CAPTURE);
+		wm8994->codec_state &= ~(CAPTURE_ACTIVE);
+	} else {
+		wm8994->codec_state &= ~(PLAYBACK_ACTIVE);
+		wm8994->stream_state &= ~(PCM_STREAM_PLAYBACK);
+	}
+
+	if ((wm8994->codec_state == DEACTIVE) &&
+			(wm8994->stream_state == PCM_STREAM_DEACTIVE)) {
+		DEBUG_LOG("Turn off Codec!!");
+		wm8994->pdata->set_mic_bias(false);
+		wm8994->power_state = CODEC_OFF;
+		wm8994->cur_path = OFF;
+		wm8994->rec_path = MIC_OFF;
+		wm8994->ringtone_active = RING_OFF;
+		wm8994_write(codec, WM8994_SOFTWARE_RESET, 0x0000);
+		return;
+	}
+
+	DEBUG_LOG("Preserve codec state = [0x%X], Stream State = [0x%X]",
+			wm8994->codec_state, wm8994->stream_state);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) 
+	{
+#ifdef FEATURE_SS_AUDIO_CAL
+		if(!(wm8994->codec_state & CALL_ACTIVE))
+		{
+			wm8994_disable_rec_path(codec);
+			wm8994->codec_state &= ~(CAPTURE_ACTIVE);
+			wm8994->rec_path = MIC_OFF;
+		}
+#else
+		wm8994_disable_rec_path(codec);
+		wm8994->codec_state &= ~(CAPTURE_ACTIVE);
+#endif
+	} else {
+		if (wm8994->codec_state & CALL_ACTIVE) {
+			int val;
+
+			val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_1);
+			val &= ~(WM8994_AIF1DAC1_MUTE_MASK);
+			val |= (WM8994_AIF1DAC1_MUTE);
+			wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val);
+		} else
+			wm8994_disable_path(codec);
+	}
+}
+
+static struct snd_soc_device *wm8994_socdev;
+static struct snd_soc_codec *wm8994_codec;
+
+#define WM8994_RATES SNDRV_PCM_RATE_44100
+#define WM8994_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+static struct snd_soc_dai_ops wm8994_ops = {
+	.startup = wm8994_startup,
+	.shutdown = wm8994_shutdown,
+	.set_sysclk = wm8994_set_sysclk,
+	.set_fmt = wm8994_set_dai_fmt,
+	.hw_params = wm8994_hw_params,
+	.digital_mute = NULL,
+};
+
+struct snd_soc_dai wm8994_dai = {
+
+	.name = "WM8994 PAIFRX",
+	.playback = {
+		     .stream_name = "Playback",
+		     .channels_min = 1,
+		     .channels_max = 6,
+		     .rates = WM8994_RATES,
+		     .formats = WM8994_FORMATS,
+		     },
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = WM8994_RATES,
+		    .formats = WM8994_FORMATS,
+		    },
+
+	.ops = &wm8994_ops,
+};
+
+static int __init gain_code_setup(char *str)
+{
+
+	gain_code = 0;
+
+	if (!strcmp(str, "")) {
+		pr_info("gain_code field is empty. use default value\n");
+		return 0;
+	}
+
+	if (!strcmp(str, "1"))
+		gain_code = 1;
+
+	return 0;
+}
+__setup("gain_code=", gain_code_setup);
+
+int gain_code_check(void)
+{
+	return gain_code;
+}
+
+static const struct {
+	unsigned short readable;   /* Mask of readable bits */
+	unsigned short writable;   /* Mask of writable bits */
+} access_masks[] = {
+	{ 0xFFFF, 0xFFFF }, /* R0     - Software Reset */
+	{ 0x3B37, 0x3B37 }, /* R1     - Power Management (1) */
+	{ 0x6BF0, 0x6BF0 }, /* R2     - Power Management (2) */
+	{ 0x3FF0, 0x3FF0 }, /* R3     - Power Management (3) */
+	{ 0x3F3F, 0x3F3F }, /* R4     - Power Management (4) */
+	{ 0x3F0F, 0x3F0F }, /* R5     - Power Management (5) */
+	{ 0x003F, 0x003F }, /* R6     - Power Management (6) */
+	{ 0x0000, 0x0000 }, /* R7 */
+	{ 0x0000, 0x0000 }, /* R8 */
+	{ 0x0000, 0x0000 }, /* R9 */
+	{ 0x0000, 0x0000 }, /* R10 */
+	{ 0x0000, 0x0000 }, /* R11 */
+	{ 0x0000, 0x0000 }, /* R12 */
+	{ 0x0000, 0x0000 }, /* R13 */
+	{ 0x0000, 0x0000 }, /* R14 */
+	{ 0x0000, 0x0000 }, /* R15 */
+	{ 0x0000, 0x0000 }, /* R16 */
+	{ 0x0000, 0x0000 }, /* R17 */
+	{ 0x0000, 0x0000 }, /* R18 */
+	{ 0x0000, 0x0000 }, /* R19 */
+	{ 0x0000, 0x0000 }, /* R20 */
+	{ 0x01C0, 0x01C0 }, /* R21    - Input Mixer (1) */
+	{ 0x0000, 0x0000 }, /* R22 */
+	{ 0x0000, 0x0000 }, /* R23 */
+	{ 0x00DF, 0x01DF }, /* R24    - Left Line Input 1&2 Volume */
+	{ 0x00DF, 0x01DF }, /* R25    - Left Line Input 3&4 Volume */
+	{ 0x00DF, 0x01DF }, /* R26    - Right Line Input 1&2 Volume */
+	{ 0x00DF, 0x01DF }, /* R27    - Right Line Input 3&4 Volume */
+	{ 0x00FF, 0x01FF }, /* R28    - Left Output Volume */
+	{ 0x00FF, 0x01FF }, /* R29    - Right Output Volume */
+	{ 0x0077, 0x0077 }, /* R30    - Line Outputs Volume */
+	{ 0x0030, 0x0030 }, /* R31    - HPOUT2 Volume */
+	{ 0x00FF, 0x01FF }, /* R32    - Left OPGA Volume */
+	{ 0x00FF, 0x01FF }, /* R33    - Right OPGA Volume */
+	{ 0x007F, 0x007F }, /* R34    - SPKMIXL Attenuation */
+	{ 0x017F, 0x017F }, /* R35    - SPKMIXR Attenuation */
+	{ 0x003F, 0x003F }, /* R36    - SPKOUT Mixers */
+	{ 0x003F, 0x003F }, /* R37    - ClassD */
+	{ 0x00FF, 0x01FF }, /* R38    - Speaker Volume Left */
+	{ 0x00FF, 0x01FF }, /* R39    - Speaker Volume Right */
+	{ 0x00FF, 0x00FF }, /* R40    - Input Mixer (2) */
+	{ 0x01B7, 0x01B7 }, /* R41    - Input Mixer (3) */
+	{ 0x01B7, 0x01B7 }, /* R42    - Input Mixer (4) */
+	{ 0x01C7, 0x01C7 }, /* R43    - Input Mixer (5) */
+	{ 0x01C7, 0x01C7 }, /* R44    - Input Mixer (6) */
+	{ 0x01FF, 0x01FF }, /* R45    - Output Mixer (1) */
+	{ 0x01FF, 0x01FF }, /* R46    - Output Mixer (2) */
+	{ 0x0FFF, 0x0FFF }, /* R47    - Output Mixer (3) */
+	{ 0x0FFF, 0x0FFF }, /* R48    - Output Mixer (4) */
+	{ 0x0FFF, 0x0FFF }, /* R49    - Output Mixer (5) */
+	{ 0x0FFF, 0x0FFF }, /* R50    - Output Mixer (6) */
+	{ 0x0038, 0x0038 }, /* R51    - HPOUT2 Mixer */
+	{ 0x0077, 0x0077 }, /* R52    - Line Mixer (1) */
+	{ 0x0077, 0x0077 }, /* R53    - Line Mixer (2) */
+	{ 0x03FF, 0x03FF }, /* R54    - Speaker Mixer */
+	{ 0x00C1, 0x00C1 }, /* R55    - Additional Control */
+	{ 0x00F0, 0x00F0 }, /* R56    - AntiPOP (1) */
+	{ 0x01EF, 0x01EF }, /* R57    - AntiPOP (2) */
+	{ 0x00FF, 0x00FF }, /* R58    - MICBIAS */
+	{ 0x000F, 0x000F }, /* R59    - LDO 1 */
+	{ 0x0007, 0x0007 }, /* R60    - LDO 2 */
+	{ 0x0000, 0x0000 }, /* R61 */
+	{ 0x0000, 0x0000 }, /* R62 */
+	{ 0x0000, 0x0000 }, /* R63 */
+	{ 0x0000, 0x0000 }, /* R64 */
+	{ 0x0000, 0x0000 }, /* R65 */
+	{ 0x0000, 0x0000 }, /* R66 */
+	{ 0x0000, 0x0000 }, /* R67 */
+	{ 0x0000, 0x0000 }, /* R68 */
+	{ 0x0000, 0x0000 }, /* R69 */
+	{ 0x0000, 0x0000 }, /* R70 */
+	{ 0x0000, 0x0000 }, /* R71 */
+	{ 0x0000, 0x0000 }, /* R72 */
+	{ 0x0000, 0x0000 }, /* R73 */
+	{ 0x0000, 0x0000 }, /* R74 */
+	{ 0x0000, 0x0000 }, /* R75 */
+	{ 0x8000, 0x8000 }, /* R76    - Charge Pump (1) */
+	{ 0x0000, 0x0000 }, /* R77 */
+	{ 0x0000, 0x0000 }, /* R78 */
+	{ 0x0000, 0x0000 }, /* R79 */
+	{ 0x0000, 0x0000 }, /* R80 */
+	{ 0x0301, 0x0301 }, /* R81    - Class W (1) */
+	{ 0x0000, 0x0000 }, /* R82 */
+	{ 0x0000, 0x0000 }, /* R83 */
+	{ 0x333F, 0x333F }, /* R84    - DC Servo (1) */
+	{ 0x0FEF, 0x0FEF }, /* R85    - DC Servo (2) */
+	{ 0x0000, 0x0000 }, /* R86 */
+	{ 0xFFFF, 0xFFFF }, /* R87    - DC Servo (4) */
+	{ 0x0333, 0x0000 }, /* R88    - DC Servo Readback */
+	{ 0x0000, 0x0000 }, /* R89 */
+	{ 0x0000, 0x0000 }, /* R90 */
+	{ 0x0000, 0x0000 }, /* R91 */
+	{ 0x0000, 0x0000 }, /* R92 */
+	{ 0x0000, 0x0000 }, /* R93 */
+	{ 0x0000, 0x0000 }, /* R94 */
+	{ 0x0000, 0x0000 }, /* R95 */
+	{ 0x00EE, 0x00EE }, /* R96    - Analogue HP (1) */
+	{ 0x0000, 0x0000 }, /* R97 */
+	{ 0x0000, 0x0000 }, /* R98 */
+	{ 0x0000, 0x0000 }, /* R99 */
+	{ 0x0000, 0x0000 }, /* R100 */
+	{ 0x0000, 0x0000 }, /* R101 */
+	{ 0x0000, 0x0000 }, /* R102 */
+	{ 0x0000, 0x0000 }, /* R103 */
+	{ 0x0000, 0x0000 }, /* R104 */
+	{ 0x0000, 0x0000 }, /* R105 */
+	{ 0x0000, 0x0000 }, /* R106 */
+	{ 0x0000, 0x0000 }, /* R107 */
+	{ 0x0000, 0x0000 }, /* R108 */
+	{ 0x0000, 0x0000 }, /* R109 */
+	{ 0x0000, 0x0000 }, /* R110 */
+	{ 0x0000, 0x0000 }, /* R111 */
+	{ 0x0000, 0x0000 }, /* R112 */
+	{ 0x0000, 0x0000 }, /* R113 */
+	{ 0x0000, 0x0000 }, /* R114 */
+	{ 0x0000, 0x0000 }, /* R115 */
+	{ 0x0000, 0x0000 }, /* R116 */
+	{ 0x0000, 0x0000 }, /* R117 */
+	{ 0x0000, 0x0000 }, /* R118 */
+	{ 0x0000, 0x0000 }, /* R119 */
+	{ 0x0000, 0x0000 }, /* R120 */
+	{ 0x0000, 0x0000 }, /* R121 */
+	{ 0x0000, 0x0000 }, /* R122 */
+	{ 0x0000, 0x0000 }, /* R123 */
+	{ 0x0000, 0x0000 }, /* R124 */
+	{ 0x0000, 0x0000 }, /* R125 */
+	{ 0x0000, 0x0000 }, /* R126 */
+	{ 0x0000, 0x0000 }, /* R127 */
+	{ 0x0000, 0x0000 }, /* R128 */
+	{ 0x0000, 0x0000 }, /* R129 */
+	{ 0x0000, 0x0000 }, /* R130 */
+	{ 0x0000, 0x0000 }, /* R131 */
+	{ 0x0000, 0x0000 }, /* R132 */
+	{ 0x0000, 0x0000 }, /* R133 */
+	{ 0x0000, 0x0000 }, /* R134 */
+	{ 0x0000, 0x0000 }, /* R135 */
+	{ 0x0000, 0x0000 }, /* R136 */
+	{ 0x0000, 0x0000 }, /* R137 */
+	{ 0x0000, 0x0000 }, /* R138 */
+	{ 0x0000, 0x0000 }, /* R139 */
+	{ 0x0000, 0x0000 }, /* R140 */
+	{ 0x0000, 0x0000 }, /* R141 */
+	{ 0x0000, 0x0000 }, /* R142 */
+	{ 0x0000, 0x0000 }, /* R143 */
+	{ 0x0000, 0x0000 }, /* R144 */
+	{ 0x0000, 0x0000 }, /* R145 */
+	{ 0x0000, 0x0000 }, /* R146 */
+	{ 0x0000, 0x0000 }, /* R147 */
+	{ 0x0000, 0x0000 }, /* R148 */
+	{ 0x0000, 0x0000 }, /* R149 */
+	{ 0x0000, 0x0000 }, /* R150 */
+	{ 0x0000, 0x0000 }, /* R151 */
+	{ 0x0000, 0x0000 }, /* R152 */
+	{ 0x0000, 0x0000 }, /* R153 */
+	{ 0x0000, 0x0000 }, /* R154 */
+	{ 0x0000, 0x0000 }, /* R155 */
+	{ 0x0000, 0x0000 }, /* R156 */
+	{ 0x0000, 0x0000 }, /* R157 */
+	{ 0x0000, 0x0000 }, /* R158 */
+	{ 0x0000, 0x0000 }, /* R159 */
+	{ 0x0000, 0x0000 }, /* R160 */
+	{ 0x0000, 0x0000 }, /* R161 */
+	{ 0x0000, 0x0000 }, /* R162 */
+	{ 0x0000, 0x0000 }, /* R163 */
+	{ 0x0000, 0x0000 }, /* R164 */
+	{ 0x0000, 0x0000 }, /* R165 */
+	{ 0x0000, 0x0000 }, /* R166 */
+	{ 0x0000, 0x0000 }, /* R167 */
+	{ 0x0000, 0x0000 }, /* R168 */
+	{ 0x0000, 0x0000 }, /* R169 */
+	{ 0x0000, 0x0000 }, /* R170 */
+	{ 0x0000, 0x0000 }, /* R171 */
+	{ 0x0000, 0x0000 }, /* R172 */
+	{ 0x0000, 0x0000 }, /* R173 */
+	{ 0x0000, 0x0000 }, /* R174 */
+	{ 0x0000, 0x0000 }, /* R175 */
+	{ 0x0000, 0x0000 }, /* R176 */
+	{ 0x0000, 0x0000 }, /* R177 */
+	{ 0x0000, 0x0000 }, /* R178 */
+	{ 0x0000, 0x0000 }, /* R179 */
+	{ 0x0000, 0x0000 }, /* R180 */
+	{ 0x0000, 0x0000 }, /* R181 */
+	{ 0x0000, 0x0000 }, /* R182 */
+	{ 0x0000, 0x0000 }, /* R183 */
+	{ 0x0000, 0x0000 }, /* R184 */
+	{ 0x0000, 0x0000 }, /* R185 */
+	{ 0x0000, 0x0000 }, /* R186 */
+	{ 0x0000, 0x0000 }, /* R187 */
+	{ 0x0000, 0x0000 }, /* R188 */
+	{ 0x0000, 0x0000 }, /* R189 */
+	{ 0x0000, 0x0000 }, /* R190 */
+	{ 0x0000, 0x0000 }, /* R191 */
+	{ 0x0000, 0x0000 }, /* R192 */
+	{ 0x0000, 0x0000 }, /* R193 */
+	{ 0x0000, 0x0000 }, /* R194 */
+	{ 0x0000, 0x0000 }, /* R195 */
+	{ 0x0000, 0x0000 }, /* R196 */
+	{ 0x0000, 0x0000 }, /* R197 */
+	{ 0x0000, 0x0000 }, /* R198 */
+	{ 0x0000, 0x0000 }, /* R199 */
+	{ 0x0000, 0x0000 }, /* R200 */
+	{ 0x0000, 0x0000 }, /* R201 */
+	{ 0x0000, 0x0000 }, /* R202 */
+	{ 0x0000, 0x0000 }, /* R203 */
+	{ 0x0000, 0x0000 }, /* R204 */
+	{ 0x0000, 0x0000 }, /* R205 */
+	{ 0x0000, 0x0000 }, /* R206 */
+	{ 0x0000, 0x0000 }, /* R207 */
+	{ 0x0000, 0x0000 }, /* R208 */
+	{ 0x0000, 0x0000 }, /* R209 */
+	{ 0x0000, 0x0000 }, /* R210 */
+	{ 0x0000, 0x0000 }, /* R211 */
+	{ 0x0000, 0x0000 }, /* R212 */
+	{ 0x0000, 0x0000 }, /* R213 */
+	{ 0x0000, 0x0000 }, /* R214 */
+	{ 0x0000, 0x0000 }, /* R215 */
+	{ 0x0000, 0x0000 }, /* R216 */
+	{ 0x0000, 0x0000 }, /* R217 */
+	{ 0x0000, 0x0000 }, /* R218 */
+	{ 0x0000, 0x0000 }, /* R219 */
+	{ 0x0000, 0x0000 }, /* R220 */
+	{ 0x0000, 0x0000 }, /* R221 */
+	{ 0x0000, 0x0000 }, /* R222 */
+	{ 0x0000, 0x0000 }, /* R223 */
+	{ 0x0000, 0x0000 }, /* R224 */
+	{ 0x0000, 0x0000 }, /* R225 */
+	{ 0x0000, 0x0000 }, /* R226 */
+	{ 0x0000, 0x0000 }, /* R227 */
+	{ 0x0000, 0x0000 }, /* R228 */
+	{ 0x0000, 0x0000 }, /* R229 */
+	{ 0x0000, 0x0000 }, /* R230 */
+	{ 0x0000, 0x0000 }, /* R231 */
+	{ 0x0000, 0x0000 }, /* R232 */
+	{ 0x0000, 0x0000 }, /* R233 */
+	{ 0x0000, 0x0000 }, /* R234 */
+	{ 0x0000, 0x0000 }, /* R235 */
+	{ 0x0000, 0x0000 }, /* R236 */
+	{ 0x0000, 0x0000 }, /* R237 */
+	{ 0x0000, 0x0000 }, /* R238 */
+	{ 0x0000, 0x0000 }, /* R239 */
+	{ 0x0000, 0x0000 }, /* R240 */
+	{ 0x0000, 0x0000 }, /* R241 */
+	{ 0x0000, 0x0000 }, /* R242 */
+	{ 0x0000, 0x0000 }, /* R243 */
+	{ 0x0000, 0x0000 }, /* R244 */
+	{ 0x0000, 0x0000 }, /* R245 */
+	{ 0x0000, 0x0000 }, /* R246 */
+	{ 0x0000, 0x0000 }, /* R247 */
+	{ 0x0000, 0x0000 }, /* R248 */
+	{ 0x0000, 0x0000 }, /* R249 */
+	{ 0x0000, 0x0000 }, /* R250 */
+	{ 0x0000, 0x0000 }, /* R251 */
+	{ 0x0000, 0x0000 }, /* R252 */
+	{ 0x0000, 0x0000 }, /* R253 */
+	{ 0x0000, 0x0000 }, /* R254 */
+	{ 0x0000, 0x0000 }, /* R255 */
+	{ 0x000F, 0x0000 }, /* R256   - Chip Revision */
+	{ 0x0074, 0x0074 }, /* R257   - Control Interface */
+	{ 0x0000, 0x0000 }, /* R258 */
+	{ 0x0000, 0x0000 }, /* R259 */
+	{ 0x0000, 0x0000 }, /* R260 */
+	{ 0x0000, 0x0000 }, /* R261 */
+	{ 0x0000, 0x0000 }, /* R262 */
+	{ 0x0000, 0x0000 }, /* R263 */
+	{ 0x0000, 0x0000 }, /* R264 */
+	{ 0x0000, 0x0000 }, /* R265 */
+	{ 0x0000, 0x0000 }, /* R266 */
+	{ 0x0000, 0x0000 }, /* R267 */
+	{ 0x0000, 0x0000 }, /* R268 */
+	{ 0x0000, 0x0000 }, /* R269 */
+	{ 0x0000, 0x0000 }, /* R270 */
+	{ 0x0000, 0x0000 }, /* R271 */
+	{ 0x807F, 0x837F }, /* R272   - Write Sequencer Ctrl (1) */
+	{ 0x017F, 0x0000 }, /* R273   - Write Sequencer Ctrl (2) */
+	{ 0x0000, 0x0000 }, /* R274 */
+	{ 0x0000, 0x0000 }, /* R275 */
+	{ 0x0000, 0x0000 }, /* R276 */
+	{ 0x0000, 0x0000 }, /* R277 */
+	{ 0x0000, 0x0000 }, /* R278 */
+	{ 0x0000, 0x0000 }, /* R279 */
+	{ 0x0000, 0x0000 }, /* R280 */
+	{ 0x0000, 0x0000 }, /* R281 */
+	{ 0x0000, 0x0000 }, /* R282 */
+	{ 0x0000, 0x0000 }, /* R283 */
+	{ 0x0000, 0x0000 }, /* R284 */
+	{ 0x0000, 0x0000 }, /* R285 */
+	{ 0x0000, 0x0000 }, /* R286 */
+	{ 0x0000, 0x0000 }, /* R287 */
+	{ 0x0000, 0x0000 }, /* R288 */
+	{ 0x0000, 0x0000 }, /* R289 */
+	{ 0x0000, 0x0000 }, /* R290 */
+	{ 0x0000, 0x0000 }, /* R291 */
+	{ 0x0000, 0x0000 }, /* R292 */
+	{ 0x0000, 0x0000 }, /* R293 */
+	{ 0x0000, 0x0000 }, /* R294 */
+	{ 0x0000, 0x0000 }, /* R295 */
+	{ 0x0000, 0x0000 }, /* R296 */
+	{ 0x0000, 0x0000 }, /* R297 */
+	{ 0x0000, 0x0000 }, /* R298 */
+	{ 0x0000, 0x0000 }, /* R299 */
+	{ 0x0000, 0x0000 }, /* R300 */
+	{ 0x0000, 0x0000 }, /* R301 */
+	{ 0x0000, 0x0000 }, /* R302 */
+	{ 0x0000, 0x0000 }, /* R303 */
+	{ 0x0000, 0x0000 }, /* R304 */
+	{ 0x0000, 0x0000 }, /* R305 */
+	{ 0x0000, 0x0000 }, /* R306 */
+	{ 0x0000, 0x0000 }, /* R307 */
+	{ 0x0000, 0x0000 }, /* R308 */
+	{ 0x0000, 0x0000 }, /* R309 */
+	{ 0x0000, 0x0000 }, /* R310 */
+	{ 0x0000, 0x0000 }, /* R311 */
+	{ 0x0000, 0x0000 }, /* R312 */
+	{ 0x0000, 0x0000 }, /* R313 */
+	{ 0x0000, 0x0000 }, /* R314 */
+	{ 0x0000, 0x0000 }, /* R315 */
+	{ 0x0000, 0x0000 }, /* R316 */
+	{ 0x0000, 0x0000 }, /* R317 */
+	{ 0x0000, 0x0000 }, /* R318 */
+	{ 0x0000, 0x0000 }, /* R319 */
+	{ 0x0000, 0x0000 }, /* R320 */
+	{ 0x0000, 0x0000 }, /* R321 */
+	{ 0x0000, 0x0000 }, /* R322 */
+	{ 0x0000, 0x0000 }, /* R323 */
+	{ 0x0000, 0x0000 }, /* R324 */
+	{ 0x0000, 0x0000 }, /* R325 */
+	{ 0x0000, 0x0000 }, /* R326 */
+	{ 0x0000, 0x0000 }, /* R327 */
+	{ 0x0000, 0x0000 }, /* R328 */
+	{ 0x0000, 0x0000 }, /* R329 */
+	{ 0x0000, 0x0000 }, /* R330 */
+	{ 0x0000, 0x0000 }, /* R331 */
+	{ 0x0000, 0x0000 }, /* R332 */
+	{ 0x0000, 0x0000 }, /* R333 */
+	{ 0x0000, 0x0000 }, /* R334 */
+	{ 0x0000, 0x0000 }, /* R335 */
+	{ 0x0000, 0x0000 }, /* R336 */
+	{ 0x0000, 0x0000 }, /* R337 */
+	{ 0x0000, 0x0000 }, /* R338 */
+	{ 0x0000, 0x0000 }, /* R339 */
+	{ 0x0000, 0x0000 }, /* R340 */
+	{ 0x0000, 0x0000 }, /* R341 */
+	{ 0x0000, 0x0000 }, /* R342 */
+	{ 0x0000, 0x0000 }, /* R343 */
+	{ 0x0000, 0x0000 }, /* R344 */
+	{ 0x0000, 0x0000 }, /* R345 */
+	{ 0x0000, 0x0000 }, /* R346 */
+	{ 0x0000, 0x0000 }, /* R347 */
+	{ 0x0000, 0x0000 }, /* R348 */
+	{ 0x0000, 0x0000 }, /* R349 */
+	{ 0x0000, 0x0000 }, /* R350 */
+	{ 0x0000, 0x0000 }, /* R351 */
+	{ 0x0000, 0x0000 }, /* R352 */
+	{ 0x0000, 0x0000 }, /* R353 */
+	{ 0x0000, 0x0000 }, /* R354 */
+	{ 0x0000, 0x0000 }, /* R355 */
+	{ 0x0000, 0x0000 }, /* R356 */
+	{ 0x0000, 0x0000 }, /* R357 */
+	{ 0x0000, 0x0000 }, /* R358 */
+	{ 0x0000, 0x0000 }, /* R359 */
+	{ 0x0000, 0x0000 }, /* R360 */
+	{ 0x0000, 0x0000 }, /* R361 */
+	{ 0x0000, 0x0000 }, /* R362 */
+	{ 0x0000, 0x0000 }, /* R363 */
+	{ 0x0000, 0x0000 }, /* R364 */
+	{ 0x0000, 0x0000 }, /* R365 */
+	{ 0x0000, 0x0000 }, /* R366 */
+	{ 0x0000, 0x0000 }, /* R367 */
+	{ 0x0000, 0x0000 }, /* R368 */
+	{ 0x0000, 0x0000 }, /* R369 */
+	{ 0x0000, 0x0000 }, /* R370 */
+	{ 0x0000, 0x0000 }, /* R371 */
+	{ 0x0000, 0x0000 }, /* R372 */
+	{ 0x0000, 0x0000 }, /* R373 */
+	{ 0x0000, 0x0000 }, /* R374 */
+	{ 0x0000, 0x0000 }, /* R375 */
+	{ 0x0000, 0x0000 }, /* R376 */
+	{ 0x0000, 0x0000 }, /* R377 */
+	{ 0x0000, 0x0000 }, /* R378 */
+	{ 0x0000, 0x0000 }, /* R379 */
+	{ 0x0000, 0x0000 }, /* R380 */
+	{ 0x0000, 0x0000 }, /* R381 */
+	{ 0x0000, 0x0000 }, /* R382 */
+	{ 0x0000, 0x0000 }, /* R383 */
+	{ 0x0000, 0x0000 }, /* R384 */
+	{ 0x0000, 0x0000 }, /* R385 */
+	{ 0x0000, 0x0000 }, /* R386 */
+	{ 0x0000, 0x0000 }, /* R387 */
+	{ 0x0000, 0x0000 }, /* R388 */
+	{ 0x0000, 0x0000 }, /* R389 */
+	{ 0x0000, 0x0000 }, /* R390 */
+	{ 0x0000, 0x0000 }, /* R391 */
+	{ 0x0000, 0x0000 }, /* R392 */
+	{ 0x0000, 0x0000 }, /* R393 */
+	{ 0x0000, 0x0000 }, /* R394 */
+	{ 0x0000, 0x0000 }, /* R395 */
+	{ 0x0000, 0x0000 }, /* R396 */
+	{ 0x0000, 0x0000 }, /* R397 */
+	{ 0x0000, 0x0000 }, /* R398 */
+	{ 0x0000, 0x0000 }, /* R399 */
+	{ 0x0000, 0x0000 }, /* R400 */
+	{ 0x0000, 0x0000 }, /* R401 */
+	{ 0x0000, 0x0000 }, /* R402 */
+	{ 0x0000, 0x0000 }, /* R403 */
+	{ 0x0000, 0x0000 }, /* R404 */
+	{ 0x0000, 0x0000 }, /* R405 */
+	{ 0x0000, 0x0000 }, /* R406 */
+	{ 0x0000, 0x0000 }, /* R407 */
+	{ 0x0000, 0x0000 }, /* R408 */
+	{ 0x0000, 0x0000 }, /* R409 */
+	{ 0x0000, 0x0000 }, /* R410 */
+	{ 0x0000, 0x0000 }, /* R411 */
+	{ 0x0000, 0x0000 }, /* R412 */
+	{ 0x0000, 0x0000 }, /* R413 */
+	{ 0x0000, 0x0000 }, /* R414 */
+	{ 0x0000, 0x0000 }, /* R415 */
+	{ 0x0000, 0x0000 }, /* R416 */
+	{ 0x0000, 0x0000 }, /* R417 */
+	{ 0x0000, 0x0000 }, /* R418 */
+	{ 0x0000, 0x0000 }, /* R419 */
+	{ 0x0000, 0x0000 }, /* R420 */
+	{ 0x0000, 0x0000 }, /* R421 */
+	{ 0x0000, 0x0000 }, /* R422 */
+	{ 0x0000, 0x0000 }, /* R423 */
+	{ 0x0000, 0x0000 }, /* R424 */
+	{ 0x0000, 0x0000 }, /* R425 */
+	{ 0x0000, 0x0000 }, /* R426 */
+	{ 0x0000, 0x0000 }, /* R427 */
+	{ 0x0000, 0x0000 }, /* R428 */
+	{ 0x0000, 0x0000 }, /* R429 */
+	{ 0x0000, 0x0000 }, /* R430 */
+	{ 0x0000, 0x0000 }, /* R431 */
+	{ 0x0000, 0x0000 }, /* R432 */
+	{ 0x0000, 0x0000 }, /* R433 */
+	{ 0x0000, 0x0000 }, /* R434 */
+	{ 0x0000, 0x0000 }, /* R435 */
+	{ 0x0000, 0x0000 }, /* R436 */
+	{ 0x0000, 0x0000 }, /* R437 */
+	{ 0x0000, 0x0000 }, /* R438 */
+	{ 0x0000, 0x0000 }, /* R439 */
+	{ 0x0000, 0x0000 }, /* R440 */
+	{ 0x0000, 0x0000 }, /* R441 */
+	{ 0x0000, 0x0000 }, /* R442 */
+	{ 0x0000, 0x0000 }, /* R443 */
+	{ 0x0000, 0x0000 }, /* R444 */
+	{ 0x0000, 0x0000 }, /* R445 */
+	{ 0x0000, 0x0000 }, /* R446 */
+	{ 0x0000, 0x0000 }, /* R447 */
+	{ 0x0000, 0x0000 }, /* R448 */
+	{ 0x0000, 0x0000 }, /* R449 */
+	{ 0x0000, 0x0000 }, /* R450 */
+	{ 0x0000, 0x0000 }, /* R451 */
+	{ 0x0000, 0x0000 }, /* R452 */
+	{ 0x0000, 0x0000 }, /* R453 */
+	{ 0x0000, 0x0000 }, /* R454 */
+	{ 0x0000, 0x0000 }, /* R455 */
+	{ 0x0000, 0x0000 }, /* R456 */
+	{ 0x0000, 0x0000 }, /* R457 */
+	{ 0x0000, 0x0000 }, /* R458 */
+	{ 0x0000, 0x0000 }, /* R459 */
+	{ 0x0000, 0x0000 }, /* R460 */
+	{ 0x0000, 0x0000 }, /* R461 */
+	{ 0x0000, 0x0000 }, /* R462 */
+	{ 0x0000, 0x0000 }, /* R463 */
+	{ 0x0000, 0x0000 }, /* R464 */
+	{ 0x0000, 0x0000 }, /* R465 */
+	{ 0x0000, 0x0000 }, /* R466 */
+	{ 0x0000, 0x0000 }, /* R467 */
+	{ 0x0000, 0x0000 }, /* R468 */
+	{ 0x0000, 0x0000 }, /* R469 */
+	{ 0x0000, 0x0000 }, /* R470 */
+	{ 0x0000, 0x0000 }, /* R471 */
+	{ 0x0000, 0x0000 }, /* R472 */
+	{ 0x0000, 0x0000 }, /* R473 */
+	{ 0x0000, 0x0000 }, /* R474 */
+	{ 0x0000, 0x0000 }, /* R475 */
+	{ 0x0000, 0x0000 }, /* R476 */
+	{ 0x0000, 0x0000 }, /* R477 */
+	{ 0x0000, 0x0000 }, /* R478 */
+	{ 0x0000, 0x0000 }, /* R479 */
+	{ 0x0000, 0x0000 }, /* R480 */
+	{ 0x0000, 0x0000 }, /* R481 */
+	{ 0x0000, 0x0000 }, /* R482 */
+	{ 0x0000, 0x0000 }, /* R483 */
+	{ 0x0000, 0x0000 }, /* R484 */
+	{ 0x0000, 0x0000 }, /* R485 */
+	{ 0x0000, 0x0000 }, /* R486 */
+	{ 0x0000, 0x0000 }, /* R487 */
+	{ 0x0000, 0x0000 }, /* R488 */
+	{ 0x0000, 0x0000 }, /* R489 */
+	{ 0x0000, 0x0000 }, /* R490 */
+	{ 0x0000, 0x0000 }, /* R491 */
+	{ 0x0000, 0x0000 }, /* R492 */
+	{ 0x0000, 0x0000 }, /* R493 */
+	{ 0x0000, 0x0000 }, /* R494 */
+	{ 0x0000, 0x0000 }, /* R495 */
+	{ 0x0000, 0x0000 }, /* R496 */
+	{ 0x0000, 0x0000 }, /* R497 */
+	{ 0x0000, 0x0000 }, /* R498 */
+	{ 0x0000, 0x0000 }, /* R499 */
+	{ 0x0000, 0x0000 }, /* R500 */
+	{ 0x0000, 0x0000 }, /* R501 */
+	{ 0x0000, 0x0000 }, /* R502 */
+	{ 0x0000, 0x0000 }, /* R503 */
+	{ 0x0000, 0x0000 }, /* R504 */
+	{ 0x0000, 0x0000 }, /* R505 */
+	{ 0x0000, 0x0000 }, /* R506 */
+	{ 0x0000, 0x0000 }, /* R507 */
+	{ 0x0000, 0x0000 }, /* R508 */
+	{ 0x0000, 0x0000 }, /* R509 */
+	{ 0x0000, 0x0000 }, /* R510 */
+	{ 0x0000, 0x0000 }, /* R511 */
+	{ 0x001F, 0x001F }, /* R512   - AIF1 Clocking (1) */
+	{ 0x003F, 0x003F }, /* R513   - AIF1 Clocking (2) */
+	{ 0x0000, 0x0000 }, /* R514 */
+	{ 0x0000, 0x0000 }, /* R515 */
+	{ 0x001F, 0x001F }, /* R516   - AIF2 Clocking (1) */
+	{ 0x003F, 0x003F }, /* R517   - AIF2 Clocking (2) */
+	{ 0x0000, 0x0000 }, /* R518 */
+	{ 0x0000, 0x0000 }, /* R519 */
+	{ 0x001F, 0x001F }, /* R520   - Clocking (1) */
+	{ 0x0777, 0x0777 }, /* R521   - Clocking (2) */
+	{ 0x0000, 0x0000 }, /* R522 */
+	{ 0x0000, 0x0000 }, /* R523 */
+	{ 0x0000, 0x0000 }, /* R524 */
+	{ 0x0000, 0x0000 }, /* R525 */
+	{ 0x0000, 0x0000 }, /* R526 */
+	{ 0x0000, 0x0000 }, /* R527 */
+	{ 0x00FF, 0x00FF }, /* R528   - AIF1 Rate */
+	{ 0x00FF, 0x00FF }, /* R529   - AIF2 Rate */
+	{ 0x000F, 0x0000 }, /* R530   - Rate Status */
+	{ 0x0000, 0x0000 }, /* R531 */
+	{ 0x0000, 0x0000 }, /* R532 */
+	{ 0x0000, 0x0000 }, /* R533 */
+	{ 0x0000, 0x0000 }, /* R534 */
+	{ 0x0000, 0x0000 }, /* R535 */
+	{ 0x0000, 0x0000 }, /* R536 */
+	{ 0x0000, 0x0000 }, /* R537 */
+	{ 0x0000, 0x0000 }, /* R538 */
+	{ 0x0000, 0x0000 }, /* R539 */
+	{ 0x0000, 0x0000 }, /* R540 */
+	{ 0x0000, 0x0000 }, /* R541 */
+	{ 0x0000, 0x0000 }, /* R542 */
+	{ 0x0000, 0x0000 }, /* R543 */
+	{ 0x0007, 0x0007 }, /* R544   - FLL1 Control (1) */
+	{ 0x3F77, 0x3F77 }, /* R545   - FLL1 Control (2) */
+	{ 0xFFFF, 0xFFFF }, /* R546   - FLL1 Control (3) */
+	{ 0x7FEF, 0x7FEF }, /* R547   - FLL1 Control (4) */
+	{ 0x1FDB, 0x1FDB }, /* R548   - FLL1 Control (5) */
+	{ 0x0000, 0x0000 }, /* R549 */
+	{ 0x0000, 0x0000 }, /* R550 */
+	{ 0x0000, 0x0000 }, /* R551 */
+	{ 0x0000, 0x0000 }, /* R552 */
+	{ 0x0000, 0x0000 }, /* R553 */
+	{ 0x0000, 0x0000 }, /* R554 */
+	{ 0x0000, 0x0000 }, /* R555 */
+	{ 0x0000, 0x0000 }, /* R556 */
+	{ 0x0000, 0x0000 }, /* R557 */
+	{ 0x0000, 0x0000 }, /* R558 */
+	{ 0x0000, 0x0000 }, /* R559 */
+	{ 0x0000, 0x0000 }, /* R560 */
+	{ 0x0000, 0x0000 }, /* R561 */
+	{ 0x0000, 0x0000 }, /* R562 */
+	{ 0x0000, 0x0000 }, /* R563 */
+	{ 0x0000, 0x0000 }, /* R564 */
+	{ 0x0000, 0x0000 }, /* R565 */
+	{ 0x0000, 0x0000 }, /* R566 */
+	{ 0x0000, 0x0000 }, /* R567 */
+	{ 0x0000, 0x0000 }, /* R568 */
+	{ 0x0000, 0x0000 }, /* R569 */
+	{ 0x0000, 0x0000 }, /* R570 */
+	{ 0x0000, 0x0000 }, /* R571 */
+	{ 0x0000, 0x0000 }, /* R572 */
+	{ 0x0000, 0x0000 }, /* R573 */
+	{ 0x0000, 0x0000 }, /* R574 */
+	{ 0x0000, 0x0000 }, /* R575 */
+	{ 0x0007, 0x0007 }, /* R576   - FLL2 Control (1) */
+	{ 0x3F77, 0x3F77 }, /* R577   - FLL2 Control (2) */
+	{ 0xFFFF, 0xFFFF }, /* R578   - FLL2 Control (3) */
+	{ 0x7FEF, 0x7FEF }, /* R579   - FLL2 Control (4) */
+	{ 0x1FDB, 0x1FDB }, /* R580   - FLL2 Control (5) */
+	{ 0x0000, 0x0000 }, /* R581 */
+	{ 0x0000, 0x0000 }, /* R582 */
+	{ 0x0000, 0x0000 }, /* R583 */
+	{ 0x0000, 0x0000 }, /* R584 */
+	{ 0x0000, 0x0000 }, /* R585 */
+	{ 0x0000, 0x0000 }, /* R586 */
+	{ 0x0000, 0x0000 }, /* R587 */
+	{ 0x0000, 0x0000 }, /* R588 */
+	{ 0x0000, 0x0000 }, /* R589 */
+	{ 0x0000, 0x0000 }, /* R590 */
+	{ 0x0000, 0x0000 }, /* R591 */
+	{ 0x0000, 0x0000 }, /* R592 */
+	{ 0x0000, 0x0000 }, /* R593 */
+	{ 0x0000, 0x0000 }, /* R594 */
+	{ 0x0000, 0x0000 }, /* R595 */
+	{ 0x0000, 0x0000 }, /* R596 */
+	{ 0x0000, 0x0000 }, /* R597 */
+	{ 0x0000, 0x0000 }, /* R598 */
+	{ 0x0000, 0x0000 }, /* R599 */
+	{ 0x0000, 0x0000 }, /* R600 */
+	{ 0x0000, 0x0000 }, /* R601 */
+	{ 0x0000, 0x0000 }, /* R602 */
+	{ 0x0000, 0x0000 }, /* R603 */
+	{ 0x0000, 0x0000 }, /* R604 */
+	{ 0x0000, 0x0000 }, /* R605 */
+	{ 0x0000, 0x0000 }, /* R606 */
+	{ 0x0000, 0x0000 }, /* R607 */
+	{ 0x0000, 0x0000 }, /* R608 */
+	{ 0x0000, 0x0000 }, /* R609 */
+	{ 0x0000, 0x0000 }, /* R610 */
+	{ 0x0000, 0x0000 }, /* R611 */
+	{ 0x0000, 0x0000 }, /* R612 */
+	{ 0x0000, 0x0000 }, /* R613 */
+	{ 0x0000, 0x0000 }, /* R614 */
+	{ 0x0000, 0x0000 }, /* R615 */
+	{ 0x0000, 0x0000 }, /* R616 */
+	{ 0x0000, 0x0000 }, /* R617 */
+	{ 0x0000, 0x0000 }, /* R618 */
+	{ 0x0000, 0x0000 }, /* R619 */
+	{ 0x0000, 0x0000 }, /* R620 */
+	{ 0x0000, 0x0000 }, /* R621 */
+	{ 0x0000, 0x0000 }, /* R622 */
+	{ 0x0000, 0x0000 }, /* R623 */
+	{ 0x0000, 0x0000 }, /* R624 */
+	{ 0x0000, 0x0000 }, /* R625 */
+	{ 0x0000, 0x0000 }, /* R626 */
+	{ 0x0000, 0x0000 }, /* R627 */
+	{ 0x0000, 0x0000 }, /* R628 */
+	{ 0x0000, 0x0000 }, /* R629 */
+	{ 0x0000, 0x0000 }, /* R630 */
+	{ 0x0000, 0x0000 }, /* R631 */
+	{ 0x0000, 0x0000 }, /* R632 */
+	{ 0x0000, 0x0000 }, /* R633 */
+	{ 0x0000, 0x0000 }, /* R634 */
+	{ 0x0000, 0x0000 }, /* R635 */
+	{ 0x0000, 0x0000 }, /* R636 */
+	{ 0x0000, 0x0000 }, /* R637 */
+	{ 0x0000, 0x0000 }, /* R638 */
+	{ 0x0000, 0x0000 }, /* R639 */
+	{ 0x0000, 0x0000 }, /* R640 */
+	{ 0x0000, 0x0000 }, /* R641 */
+	{ 0x0000, 0x0000 }, /* R642 */
+	{ 0x0000, 0x0000 }, /* R643 */
+	{ 0x0000, 0x0000 }, /* R644 */
+	{ 0x0000, 0x0000 }, /* R645 */
+	{ 0x0000, 0x0000 }, /* R646 */
+	{ 0x0000, 0x0000 }, /* R647 */
+	{ 0x0000, 0x0000 }, /* R648 */
+	{ 0x0000, 0x0000 }, /* R649 */
+	{ 0x0000, 0x0000 }, /* R650 */
+	{ 0x0000, 0x0000 }, /* R651 */
+	{ 0x0000, 0x0000 }, /* R652 */
+	{ 0x0000, 0x0000 }, /* R653 */
+	{ 0x0000, 0x0000 }, /* R654 */
+	{ 0x0000, 0x0000 }, /* R655 */
+	{ 0x0000, 0x0000 }, /* R656 */
+	{ 0x0000, 0x0000 }, /* R657 */
+	{ 0x0000, 0x0000 }, /* R658 */
+	{ 0x0000, 0x0000 }, /* R659 */
+	{ 0x0000, 0x0000 }, /* R660 */
+	{ 0x0000, 0x0000 }, /* R661 */
+	{ 0x0000, 0x0000 }, /* R662 */
+	{ 0x0000, 0x0000 }, /* R663 */
+	{ 0x0000, 0x0000 }, /* R664 */
+	{ 0x0000, 0x0000 }, /* R665 */
+	{ 0x0000, 0x0000 }, /* R666 */
+	{ 0x0000, 0x0000 }, /* R667 */
+	{ 0x0000, 0x0000 }, /* R668 */
+	{ 0x0000, 0x0000 }, /* R669 */
+	{ 0x0000, 0x0000 }, /* R670 */
+	{ 0x0000, 0x0000 }, /* R671 */
+	{ 0x0000, 0x0000 }, /* R672 */
+	{ 0x0000, 0x0000 }, /* R673 */
+	{ 0x0000, 0x0000 }, /* R674 */
+	{ 0x0000, 0x0000 }, /* R675 */
+	{ 0x0000, 0x0000 }, /* R676 */
+	{ 0x0000, 0x0000 }, /* R677 */
+	{ 0x0000, 0x0000 }, /* R678 */
+	{ 0x0000, 0x0000 }, /* R679 */
+	{ 0x0000, 0x0000 }, /* R680 */
+	{ 0x0000, 0x0000 }, /* R681 */
+	{ 0x0000, 0x0000 }, /* R682 */
+	{ 0x0000, 0x0000 }, /* R683 */
+	{ 0x0000, 0x0000 }, /* R684 */
+	{ 0x0000, 0x0000 }, /* R685 */
+	{ 0x0000, 0x0000 }, /* R686 */
+	{ 0x0000, 0x0000 }, /* R687 */
+	{ 0x0000, 0x0000 }, /* R688 */
+	{ 0x0000, 0x0000 }, /* R689 */
+	{ 0x0000, 0x0000 }, /* R690 */
+	{ 0x0000, 0x0000 }, /* R691 */
+	{ 0x0000, 0x0000 }, /* R692 */
+	{ 0x0000, 0x0000 }, /* R693 */
+	{ 0x0000, 0x0000 }, /* R694 */
+	{ 0x0000, 0x0000 }, /* R695 */
+	{ 0x0000, 0x0000 }, /* R696 */
+	{ 0x0000, 0x0000 }, /* R697 */
+	{ 0x0000, 0x0000 }, /* R698 */
+	{ 0x0000, 0x0000 }, /* R699 */
+	{ 0x0000, 0x0000 }, /* R700 */
+	{ 0x0000, 0x0000 }, /* R701 */
+	{ 0x0000, 0x0000 }, /* R702 */
+	{ 0x0000, 0x0000 }, /* R703 */
+	{ 0x0000, 0x0000 }, /* R704 */
+	{ 0x0000, 0x0000 }, /* R705 */
+	{ 0x0000, 0x0000 }, /* R706 */
+	{ 0x0000, 0x0000 }, /* R707 */
+	{ 0x0000, 0x0000 }, /* R708 */
+	{ 0x0000, 0x0000 }, /* R709 */
+	{ 0x0000, 0x0000 }, /* R710 */
+	{ 0x0000, 0x0000 }, /* R711 */
+	{ 0x0000, 0x0000 }, /* R712 */
+	{ 0x0000, 0x0000 }, /* R713 */
+	{ 0x0000, 0x0000 }, /* R714 */
+	{ 0x0000, 0x0000 }, /* R715 */
+	{ 0x0000, 0x0000 }, /* R716 */
+	{ 0x0000, 0x0000 }, /* R717 */
+	{ 0x0000, 0x0000 }, /* R718 */
+	{ 0x0000, 0x0000 }, /* R719 */
+	{ 0x0000, 0x0000 }, /* R720 */
+	{ 0x0000, 0x0000 }, /* R721 */
+	{ 0x0000, 0x0000 }, /* R722 */
+	{ 0x0000, 0x0000 }, /* R723 */
+	{ 0x0000, 0x0000 }, /* R724 */
+	{ 0x0000, 0x0000 }, /* R725 */
+	{ 0x0000, 0x0000 }, /* R726 */
+	{ 0x0000, 0x0000 }, /* R727 */
+	{ 0x0000, 0x0000 }, /* R728 */
+	{ 0x0000, 0x0000 }, /* R729 */
+	{ 0x0000, 0x0000 }, /* R730 */
+	{ 0x0000, 0x0000 }, /* R731 */
+	{ 0x0000, 0x0000 }, /* R732 */
+	{ 0x0000, 0x0000 }, /* R733 */
+	{ 0x0000, 0x0000 }, /* R734 */
+	{ 0x0000, 0x0000 }, /* R735 */
+	{ 0x0000, 0x0000 }, /* R736 */
+	{ 0x0000, 0x0000 }, /* R737 */
+	{ 0x0000, 0x0000 }, /* R738 */
+	{ 0x0000, 0x0000 }, /* R739 */
+	{ 0x0000, 0x0000 }, /* R740 */
+	{ 0x0000, 0x0000 }, /* R741 */
+	{ 0x0000, 0x0000 }, /* R742 */
+	{ 0x0000, 0x0000 }, /* R743 */
+	{ 0x0000, 0x0000 }, /* R744 */
+	{ 0x0000, 0x0000 }, /* R745 */
+	{ 0x0000, 0x0000 }, /* R746 */
+	{ 0x0000, 0x0000 }, /* R747 */
+	{ 0x0000, 0x0000 }, /* R748 */
+	{ 0x0000, 0x0000 }, /* R749 */
+	{ 0x0000, 0x0000 }, /* R750 */
+	{ 0x0000, 0x0000 }, /* R751 */
+	{ 0x0000, 0x0000 }, /* R752 */
+	{ 0x0000, 0x0000 }, /* R753 */
+	{ 0x0000, 0x0000 }, /* R754 */
+	{ 0x0000, 0x0000 }, /* R755 */
+	{ 0x0000, 0x0000 }, /* R756 */
+	{ 0x0000, 0x0000 }, /* R757 */
+	{ 0x0000, 0x0000 }, /* R758 */
+	{ 0x0000, 0x0000 }, /* R759 */
+	{ 0x0000, 0x0000 }, /* R760 */
+	{ 0x0000, 0x0000 }, /* R761 */
+	{ 0x0000, 0x0000 }, /* R762 */
+	{ 0x0000, 0x0000 }, /* R763 */
+	{ 0x0000, 0x0000 }, /* R764 */
+	{ 0x0000, 0x0000 }, /* R765 */
+	{ 0x0000, 0x0000 }, /* R766 */
+	{ 0x0000, 0x0000 }, /* R767 */
+	{ 0xE1F8, 0xE1F8 }, /* R768   - AIF1 Control (1) */
+	{ 0xCD1F, 0xCD1F }, /* R769   - AIF1 Control (2) */
+	{ 0xF000, 0xF000 }, /* R770   - AIF1 Master/Slave */
+	{ 0x01F0, 0x01F0 }, /* R771   - AIF1 BCLK */
+	{ 0x0FFF, 0x0FFF }, /* R772   - AIF1ADC LRCLK */
+	{ 0x0FFF, 0x0FFF }, /* R773   - AIF1DAC LRCLK */
+	{ 0x0003, 0x0003 }, /* R774   - AIF1DAC Data */
+	{ 0x0003, 0x0003 }, /* R775   - AIF1ADC Data */
+	{ 0x0000, 0x0000 }, /* R776 */
+	{ 0x0000, 0x0000 }, /* R777 */
+	{ 0x0000, 0x0000 }, /* R778 */
+	{ 0x0000, 0x0000 }, /* R779 */
+	{ 0x0000, 0x0000 }, /* R780 */
+	{ 0x0000, 0x0000 }, /* R781 */
+	{ 0x0000, 0x0000 }, /* R782 */
+	{ 0x0000, 0x0000 }, /* R783 */
+	{ 0xF1F8, 0xF1F8 }, /* R784   - AIF2 Control (1) */
+	{ 0xFD1F, 0xFD1F }, /* R785   - AIF2 Control (2) */
+	{ 0xF000, 0xF000 }, /* R786   - AIF2 Master/Slave */
+	{ 0x01F0, 0x01F0 }, /* R787   - AIF2 BCLK */
+	{ 0x0FFF, 0x0FFF }, /* R788   - AIF2ADC LRCLK */
+	{ 0x0FFF, 0x0FFF }, /* R789   - AIF2DAC LRCLK */
+	{ 0x0003, 0x0003 }, /* R790   - AIF2DAC Data */
+	{ 0x0003, 0x0003 }, /* R791   - AIF2ADC Data */
+	{ 0x0000, 0x0000 }, /* R792 */
+	{ 0x0000, 0x0000 }, /* R793 */
+	{ 0x0000, 0x0000 }, /* R794 */
+	{ 0x0000, 0x0000 }, /* R795 */
+	{ 0x0000, 0x0000 }, /* R796 */
+	{ 0x0000, 0x0000 }, /* R797 */
+	{ 0x0000, 0x0000 }, /* R798 */
+	{ 0x0000, 0x0000 }, /* R799 */
+	{ 0x0000, 0x0000 }, /* R800 */
+	{ 0x0000, 0x0000 }, /* R801 */
+	{ 0x0000, 0x0000 }, /* R802 */
+	{ 0x0000, 0x0000 }, /* R803 */
+	{ 0x0000, 0x0000 }, /* R804 */
+	{ 0x0000, 0x0000 }, /* R805 */
+	{ 0x0000, 0x0000 }, /* R806 */
+	{ 0x0000, 0x0000 }, /* R807 */
+	{ 0x0000, 0x0000 }, /* R808 */
+	{ 0x0000, 0x0000 }, /* R809 */
+	{ 0x0000, 0x0000 }, /* R810 */
+	{ 0x0000, 0x0000 }, /* R811 */
+	{ 0x0000, 0x0000 }, /* R812 */
+	{ 0x0000, 0x0000 }, /* R813 */
+	{ 0x0000, 0x0000 }, /* R814 */
+	{ 0x0000, 0x0000 }, /* R815 */
+	{ 0x0000, 0x0000 }, /* R816 */
+	{ 0x0000, 0x0000 }, /* R817 */
+	{ 0x0000, 0x0000 }, /* R818 */
+	{ 0x0000, 0x0000 }, /* R819 */
+	{ 0x0000, 0x0000 }, /* R820 */
+	{ 0x0000, 0x0000 }, /* R821 */
+	{ 0x0000, 0x0000 }, /* R822 */
+	{ 0x0000, 0x0000 }, /* R823 */
+	{ 0x0000, 0x0000 }, /* R824 */
+	{ 0x0000, 0x0000 }, /* R825 */
+	{ 0x0000, 0x0000 }, /* R826 */
+	{ 0x0000, 0x0000 }, /* R827 */
+	{ 0x0000, 0x0000 }, /* R828 */
+	{ 0x0000, 0x0000 }, /* R829 */
+	{ 0x0000, 0x0000 }, /* R830 */
+	{ 0x0000, 0x0000 }, /* R831 */
+	{ 0x0000, 0x0000 }, /* R832 */
+	{ 0x0000, 0x0000 }, /* R833 */
+	{ 0x0000, 0x0000 }, /* R834 */
+	{ 0x0000, 0x0000 }, /* R835 */
+	{ 0x0000, 0x0000 }, /* R836 */
+	{ 0x0000, 0x0000 }, /* R837 */
+	{ 0x0000, 0x0000 }, /* R838 */
+	{ 0x0000, 0x0000 }, /* R839 */
+	{ 0x0000, 0x0000 }, /* R840 */
+	{ 0x0000, 0x0000 }, /* R841 */
+	{ 0x0000, 0x0000 }, /* R842 */
+	{ 0x0000, 0x0000 }, /* R843 */
+	{ 0x0000, 0x0000 }, /* R844 */
+	{ 0x0000, 0x0000 }, /* R845 */
+	{ 0x0000, 0x0000 }, /* R846 */
+	{ 0x0000, 0x0000 }, /* R847 */
+	{ 0x0000, 0x0000 }, /* R848 */
+	{ 0x0000, 0x0000 }, /* R849 */
+	{ 0x0000, 0x0000 }, /* R850 */
+	{ 0x0000, 0x0000 }, /* R851 */
+	{ 0x0000, 0x0000 }, /* R852 */
+	{ 0x0000, 0x0000 }, /* R853 */
+	{ 0x0000, 0x0000 }, /* R854 */
+	{ 0x0000, 0x0000 }, /* R855 */
+	{ 0x0000, 0x0000 }, /* R856 */
+	{ 0x0000, 0x0000 }, /* R857 */
+	{ 0x0000, 0x0000 }, /* R858 */
+	{ 0x0000, 0x0000 }, /* R859 */
+	{ 0x0000, 0x0000 }, /* R860 */
+	{ 0x0000, 0x0000 }, /* R861 */
+	{ 0x0000, 0x0000 }, /* R862 */
+	{ 0x0000, 0x0000 }, /* R863 */
+	{ 0x0000, 0x0000 }, /* R864 */
+	{ 0x0000, 0x0000 }, /* R865 */
+	{ 0x0000, 0x0000 }, /* R866 */
+	{ 0x0000, 0x0000 }, /* R867 */
+	{ 0x0000, 0x0000 }, /* R868 */
+	{ 0x0000, 0x0000 }, /* R869 */
+	{ 0x0000, 0x0000 }, /* R870 */
+	{ 0x0000, 0x0000 }, /* R871 */
+	{ 0x0000, 0x0000 }, /* R872 */
+	{ 0x0000, 0x0000 }, /* R873 */
+	{ 0x0000, 0x0000 }, /* R874 */
+	{ 0x0000, 0x0000 }, /* R875 */
+	{ 0x0000, 0x0000 }, /* R876 */
+	{ 0x0000, 0x0000 }, /* R877 */
+	{ 0x0000, 0x0000 }, /* R878 */
+	{ 0x0000, 0x0000 }, /* R879 */
+	{ 0x0000, 0x0000 }, /* R880 */
+	{ 0x0000, 0x0000 }, /* R881 */
+	{ 0x0000, 0x0000 }, /* R882 */
+	{ 0x0000, 0x0000 }, /* R883 */
+	{ 0x0000, 0x0000 }, /* R884 */
+	{ 0x0000, 0x0000 }, /* R885 */
+	{ 0x0000, 0x0000 }, /* R886 */
+	{ 0x0000, 0x0000 }, /* R887 */
+	{ 0x0000, 0x0000 }, /* R888 */
+	{ 0x0000, 0x0000 }, /* R889 */
+	{ 0x0000, 0x0000 }, /* R890 */
+	{ 0x0000, 0x0000 }, /* R891 */
+	{ 0x0000, 0x0000 }, /* R892 */
+	{ 0x0000, 0x0000 }, /* R893 */
+	{ 0x0000, 0x0000 }, /* R894 */
+	{ 0x0000, 0x0000 }, /* R895 */
+	{ 0x0000, 0x0000 }, /* R896 */
+	{ 0x0000, 0x0000 }, /* R897 */
+	{ 0x0000, 0x0000 }, /* R898 */
+	{ 0x0000, 0x0000 }, /* R899 */
+	{ 0x0000, 0x0000 }, /* R900 */
+	{ 0x0000, 0x0000 }, /* R901 */
+	{ 0x0000, 0x0000 }, /* R902 */
+	{ 0x0000, 0x0000 }, /* R903 */
+	{ 0x0000, 0x0000 }, /* R904 */
+	{ 0x0000, 0x0000 }, /* R905 */
+	{ 0x0000, 0x0000 }, /* R906 */
+	{ 0x0000, 0x0000 }, /* R907 */
+	{ 0x0000, 0x0000 }, /* R908 */
+	{ 0x0000, 0x0000 }, /* R909 */
+	{ 0x0000, 0x0000 }, /* R910 */
+	{ 0x0000, 0x0000 }, /* R911 */
+	{ 0x0000, 0x0000 }, /* R912 */
+	{ 0x0000, 0x0000 }, /* R913 */
+	{ 0x0000, 0x0000 }, /* R914 */
+	{ 0x0000, 0x0000 }, /* R915 */
+	{ 0x0000, 0x0000 }, /* R916 */
+	{ 0x0000, 0x0000 }, /* R917 */
+	{ 0x0000, 0x0000 }, /* R918 */
+	{ 0x0000, 0x0000 }, /* R919 */
+	{ 0x0000, 0x0000 }, /* R920 */
+	{ 0x0000, 0x0000 }, /* R921 */
+	{ 0x0000, 0x0000 }, /* R922 */
+	{ 0x0000, 0x0000 }, /* R923 */
+	{ 0x0000, 0x0000 }, /* R924 */
+	{ 0x0000, 0x0000 }, /* R925 */
+	{ 0x0000, 0x0000 }, /* R926 */
+	{ 0x0000, 0x0000 }, /* R927 */
+	{ 0x0000, 0x0000 }, /* R928 */
+	{ 0x0000, 0x0000 }, /* R929 */
+	{ 0x0000, 0x0000 }, /* R930 */
+	{ 0x0000, 0x0000 }, /* R931 */
+	{ 0x0000, 0x0000 }, /* R932 */
+	{ 0x0000, 0x0000 }, /* R933 */
+	{ 0x0000, 0x0000 }, /* R934 */
+	{ 0x0000, 0x0000 }, /* R935 */
+	{ 0x0000, 0x0000 }, /* R936 */
+	{ 0x0000, 0x0000 }, /* R937 */
+	{ 0x0000, 0x0000 }, /* R938 */
+	{ 0x0000, 0x0000 }, /* R939 */
+	{ 0x0000, 0x0000 }, /* R940 */
+	{ 0x0000, 0x0000 }, /* R941 */
+	{ 0x0000, 0x0000 }, /* R942 */
+	{ 0x0000, 0x0000 }, /* R943 */
+	{ 0x0000, 0x0000 }, /* R944 */
+	{ 0x0000, 0x0000 }, /* R945 */
+	{ 0x0000, 0x0000 }, /* R946 */
+	{ 0x0000, 0x0000 }, /* R947 */
+	{ 0x0000, 0x0000 }, /* R948 */
+	{ 0x0000, 0x0000 }, /* R949 */
+	{ 0x0000, 0x0000 }, /* R950 */
+	{ 0x0000, 0x0000 }, /* R951 */
+	{ 0x0000, 0x0000 }, /* R952 */
+	{ 0x0000, 0x0000 }, /* R953 */
+	{ 0x0000, 0x0000 }, /* R954 */
+	{ 0x0000, 0x0000 }, /* R955 */
+	{ 0x0000, 0x0000 }, /* R956 */
+	{ 0x0000, 0x0000 }, /* R957 */
+	{ 0x0000, 0x0000 }, /* R958 */
+	{ 0x0000, 0x0000 }, /* R959 */
+	{ 0x0000, 0x0000 }, /* R960 */
+	{ 0x0000, 0x0000 }, /* R961 */
+	{ 0x0000, 0x0000 }, /* R962 */
+	{ 0x0000, 0x0000 }, /* R963 */
+	{ 0x0000, 0x0000 }, /* R964 */
+	{ 0x0000, 0x0000 }, /* R965 */
+	{ 0x0000, 0x0000 }, /* R966 */
+	{ 0x0000, 0x0000 }, /* R967 */
+	{ 0x0000, 0x0000 }, /* R968 */
+	{ 0x0000, 0x0000 }, /* R969 */
+	{ 0x0000, 0x0000 }, /* R970 */
+	{ 0x0000, 0x0000 }, /* R971 */
+	{ 0x0000, 0x0000 }, /* R972 */
+	{ 0x0000, 0x0000 }, /* R973 */
+	{ 0x0000, 0x0000 }, /* R974 */
+	{ 0x0000, 0x0000 }, /* R975 */
+	{ 0x0000, 0x0000 }, /* R976 */
+	{ 0x0000, 0x0000 }, /* R977 */
+	{ 0x0000, 0x0000 }, /* R978 */
+	{ 0x0000, 0x0000 }, /* R979 */
+	{ 0x0000, 0x0000 }, /* R980 */
+	{ 0x0000, 0x0000 }, /* R981 */
+	{ 0x0000, 0x0000 }, /* R982 */
+	{ 0x0000, 0x0000 }, /* R983 */
+	{ 0x0000, 0x0000 }, /* R984 */
+	{ 0x0000, 0x0000 }, /* R985 */
+	{ 0x0000, 0x0000 }, /* R986 */
+	{ 0x0000, 0x0000 }, /* R987 */
+	{ 0x0000, 0x0000 }, /* R988 */
+	{ 0x0000, 0x0000 }, /* R989 */
+	{ 0x0000, 0x0000 }, /* R990 */
+	{ 0x0000, 0x0000 }, /* R991 */
+	{ 0x0000, 0x0000 }, /* R992 */
+	{ 0x0000, 0x0000 }, /* R993 */
+	{ 0x0000, 0x0000 }, /* R994 */
+	{ 0x0000, 0x0000 }, /* R995 */
+	{ 0x0000, 0x0000 }, /* R996 */
+	{ 0x0000, 0x0000 }, /* R997 */
+	{ 0x0000, 0x0000 }, /* R998 */
+	{ 0x0000, 0x0000 }, /* R999 */
+	{ 0x0000, 0x0000 }, /* R1000 */
+	{ 0x0000, 0x0000 }, /* R1001 */
+	{ 0x0000, 0x0000 }, /* R1002 */
+	{ 0x0000, 0x0000 }, /* R1003 */
+	{ 0x0000, 0x0000 }, /* R1004 */
+	{ 0x0000, 0x0000 }, /* R1005 */
+	{ 0x0000, 0x0000 }, /* R1006 */
+	{ 0x0000, 0x0000 }, /* R1007 */
+	{ 0x0000, 0x0000 }, /* R1008 */
+	{ 0x0000, 0x0000 }, /* R1009 */
+	{ 0x0000, 0x0000 }, /* R1010 */
+	{ 0x0000, 0x0000 }, /* R1011 */
+	{ 0x0000, 0x0000 }, /* R1012 */
+	{ 0x0000, 0x0000 }, /* R1013 */
+	{ 0x0000, 0x0000 }, /* R1014 */
+	{ 0x0000, 0x0000 }, /* R1015 */
+	{ 0x0000, 0x0000 }, /* R1016 */
+	{ 0x0000, 0x0000 }, /* R1017 */
+	{ 0x0000, 0x0000 }, /* R1018 */
+	{ 0x0000, 0x0000 }, /* R1019 */
+	{ 0x0000, 0x0000 }, /* R1020 */
+	{ 0x0000, 0x0000 }, /* R1021 */
+	{ 0x0000, 0x0000 }, /* R1022 */
+	{ 0x0000, 0x0000 }, /* R1023 */
+	{ 0x00FF, 0x01FF }, /* R1024  - AIF1 ADC1 Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1025  - AIF1 ADC1 Right Volume */
+	{ 0x00FF, 0x01FF }, /* R1026  - AIF1 DAC1 Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1027  - AIF1 DAC1 Right Volume */
+	{ 0x00FF, 0x01FF }, /* R1028  - AIF1 ADC2 Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1029  - AIF1 ADC2 Right Volume */
+	{ 0x00FF, 0x01FF }, /* R1030  - AIF1 DAC2 Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1031  - AIF1 DAC2 Right Volume */
+	{ 0x0000, 0x0000 }, /* R1032 */
+	{ 0x0000, 0x0000 }, /* R1033 */
+	{ 0x0000, 0x0000 }, /* R1034 */
+	{ 0x0000, 0x0000 }, /* R1035 */
+	{ 0x0000, 0x0000 }, /* R1036 */
+	{ 0x0000, 0x0000 }, /* R1037 */
+	{ 0x0000, 0x0000 }, /* R1038 */
+	{ 0x0000, 0x0000 }, /* R1039 */
+	{ 0xF800, 0xF800 }, /* R1040  - AIF1 ADC1 Filters */
+	{ 0x7800, 0x7800 }, /* R1041  - AIF1 ADC2 Filters */
+	{ 0x0000, 0x0000 }, /* R1042 */
+	{ 0x0000, 0x0000 }, /* R1043 */
+	{ 0x0000, 0x0000 }, /* R1044 */
+	{ 0x0000, 0x0000 }, /* R1045 */
+	{ 0x0000, 0x0000 }, /* R1046 */
+	{ 0x0000, 0x0000 }, /* R1047 */
+	{ 0x0000, 0x0000 }, /* R1048 */
+	{ 0x0000, 0x0000 }, /* R1049 */
+	{ 0x0000, 0x0000 }, /* R1050 */
+	{ 0x0000, 0x0000 }, /* R1051 */
+	{ 0x0000, 0x0000 }, /* R1052 */
+	{ 0x0000, 0x0000 }, /* R1053 */
+	{ 0x0000, 0x0000 }, /* R1054 */
+	{ 0x0000, 0x0000 }, /* R1055 */
+	{ 0x02B6, 0x02B6 }, /* R1056  - AIF1 DAC1 Filters (1) */
+	{ 0x3F00, 0x3F00 }, /* R1057  - AIF1 DAC1 Filters (2) */
+	{ 0x02B6, 0x02B6 }, /* R1058  - AIF1 DAC2 Filters (1) */
+	{ 0x3F00, 0x3F00 }, /* R1059  - AIF1 DAC2 Filters (2) */
+	{ 0x0000, 0x0000 }, /* R1060 */
+	{ 0x0000, 0x0000 }, /* R1061 */
+	{ 0x0000, 0x0000 }, /* R1062 */
+	{ 0x0000, 0x0000 }, /* R1063 */
+	{ 0x0000, 0x0000 }, /* R1064 */
+	{ 0x0000, 0x0000 }, /* R1065 */
+	{ 0x0000, 0x0000 }, /* R1066 */
+	{ 0x0000, 0x0000 }, /* R1067 */
+	{ 0x0000, 0x0000 }, /* R1068 */
+	{ 0x0000, 0x0000 }, /* R1069 */
+	{ 0x0000, 0x0000 }, /* R1070 */
+	{ 0x0000, 0x0000 }, /* R1071 */
+	{ 0x0000, 0x0000 }, /* R1072 */
+	{ 0x0000, 0x0000 }, /* R1073 */
+	{ 0x0000, 0x0000 }, /* R1074 */
+	{ 0x0000, 0x0000 }, /* R1075 */
+	{ 0x0000, 0x0000 }, /* R1076 */
+	{ 0x0000, 0x0000 }, /* R1077 */
+	{ 0x0000, 0x0000 }, /* R1078 */
+	{ 0x0000, 0x0000 }, /* R1079 */
+	{ 0x0000, 0x0000 }, /* R1080 */
+	{ 0x0000, 0x0000 }, /* R1081 */
+	{ 0x0000, 0x0000 }, /* R1082 */
+	{ 0x0000, 0x0000 }, /* R1083 */
+	{ 0x0000, 0x0000 }, /* R1084 */
+	{ 0x0000, 0x0000 }, /* R1085 */
+	{ 0x0000, 0x0000 }, /* R1086 */
+	{ 0x0000, 0x0000 }, /* R1087 */
+	{ 0xFFFF, 0xFFFF }, /* R1088  - AIF1 DRC1 (1) */
+	{ 0x1FFF, 0x1FFF }, /* R1089  - AIF1 DRC1 (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1090  - AIF1 DRC1 (3) */
+	{ 0x07FF, 0x07FF }, /* R1091  - AIF1 DRC1 (4) */
+	{ 0x03FF, 0x03FF }, /* R1092  - AIF1 DRC1 (5) */
+	{ 0x0000, 0x0000 }, /* R1093 */
+	{ 0x0000, 0x0000 }, /* R1094 */
+	{ 0x0000, 0x0000 }, /* R1095 */
+	{ 0x0000, 0x0000 }, /* R1096 */
+	{ 0x0000, 0x0000 }, /* R1097 */
+	{ 0x0000, 0x0000 }, /* R1098 */
+	{ 0x0000, 0x0000 }, /* R1099 */
+	{ 0x0000, 0x0000 }, /* R1100 */
+	{ 0x0000, 0x0000 }, /* R1101 */
+	{ 0x0000, 0x0000 }, /* R1102 */
+	{ 0x0000, 0x0000 }, /* R1103 */
+	{ 0xFFFF, 0xFFFF }, /* R1104  - AIF1 DRC2 (1) */
+	{ 0x1FFF, 0x1FFF }, /* R1105  - AIF1 DRC2 (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1106  - AIF1 DRC2 (3) */
+	{ 0x07FF, 0x07FF }, /* R1107  - AIF1 DRC2 (4) */
+	{ 0x03FF, 0x03FF }, /* R1108  - AIF1 DRC2 (5) */
+	{ 0x0000, 0x0000 }, /* R1109 */
+	{ 0x0000, 0x0000 }, /* R1110 */
+	{ 0x0000, 0x0000 }, /* R1111 */
+	{ 0x0000, 0x0000 }, /* R1112 */
+	{ 0x0000, 0x0000 }, /* R1113 */
+	{ 0x0000, 0x0000 }, /* R1114 */
+	{ 0x0000, 0x0000 }, /* R1115 */
+	{ 0x0000, 0x0000 }, /* R1116 */
+	{ 0x0000, 0x0000 }, /* R1117 */
+	{ 0x0000, 0x0000 }, /* R1118 */
+	{ 0x0000, 0x0000 }, /* R1119 */
+	{ 0x0000, 0x0000 }, /* R1120 */
+	{ 0x0000, 0x0000 }, /* R1121 */
+	{ 0x0000, 0x0000 }, /* R1122 */
+	{ 0x0000, 0x0000 }, /* R1123 */
+	{ 0x0000, 0x0000 }, /* R1124 */
+	{ 0x0000, 0x0000 }, /* R1125 */
+	{ 0x0000, 0x0000 }, /* R1126 */
+	{ 0x0000, 0x0000 }, /* R1127 */
+	{ 0x0000, 0x0000 }, /* R1128 */
+	{ 0x0000, 0x0000 }, /* R1129 */
+	{ 0x0000, 0x0000 }, /* R1130 */
+	{ 0x0000, 0x0000 }, /* R1131 */
+	{ 0x0000, 0x0000 }, /* R1132 */
+	{ 0x0000, 0x0000 }, /* R1133 */
+	{ 0x0000, 0x0000 }, /* R1134 */
+	{ 0x0000, 0x0000 }, /* R1135 */
+	{ 0x0000, 0x0000 }, /* R1136 */
+	{ 0x0000, 0x0000 }, /* R1137 */
+	{ 0x0000, 0x0000 }, /* R1138 */
+	{ 0x0000, 0x0000 }, /* R1139 */
+	{ 0x0000, 0x0000 }, /* R1140 */
+	{ 0x0000, 0x0000 }, /* R1141 */
+	{ 0x0000, 0x0000 }, /* R1142 */
+	{ 0x0000, 0x0000 }, /* R1143 */
+	{ 0x0000, 0x0000 }, /* R1144 */
+	{ 0x0000, 0x0000 }, /* R1145 */
+	{ 0x0000, 0x0000 }, /* R1146 */
+	{ 0x0000, 0x0000 }, /* R1147 */
+	{ 0x0000, 0x0000 }, /* R1148 */
+	{ 0x0000, 0x0000 }, /* R1149 */
+	{ 0x0000, 0x0000 }, /* R1150 */
+	{ 0x0000, 0x0000 }, /* R1151 */
+	{ 0xFFFF, 0xFFFF }, /* R1152  - AIF1 DAC1 EQ Gains (1) */
+	{ 0xFFC0, 0xFFC0 }, /* R1153  - AIF1 DAC1 EQ Gains (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1154  - AIF1 DAC1 EQ Band 1 A */
+	{ 0xFFFF, 0xFFFF }, /* R1155  - AIF1 DAC1 EQ Band 1 B */
+	{ 0xFFFF, 0xFFFF }, /* R1156  - AIF1 DAC1 EQ Band 1 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1157  - AIF1 DAC1 EQ Band 2 A */
+	{ 0xFFFF, 0xFFFF }, /* R1158  - AIF1 DAC1 EQ Band 2 B */
+	{ 0xFFFF, 0xFFFF }, /* R1159  - AIF1 DAC1 EQ Band 2 C */
+	{ 0xFFFF, 0xFFFF }, /* R1160  - AIF1 DAC1 EQ Band 2 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1161  - AIF1 DAC1 EQ Band 3 A */
+	{ 0xFFFF, 0xFFFF }, /* R1162  - AIF1 DAC1 EQ Band 3 B */
+	{ 0xFFFF, 0xFFFF }, /* R1163  - AIF1 DAC1 EQ Band 3 C */
+	{ 0xFFFF, 0xFFFF }, /* R1164  - AIF1 DAC1 EQ Band 3 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1165  - AIF1 DAC1 EQ Band 4 A */
+	{ 0xFFFF, 0xFFFF }, /* R1166  - AIF1 DAC1 EQ Band 4 B */
+	{ 0xFFFF, 0xFFFF }, /* R1167  - AIF1 DAC1 EQ Band 4 C */
+	{ 0xFFFF, 0xFFFF }, /* R1168  - AIF1 DAC1 EQ Band 4 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1169  - AIF1 DAC1 EQ Band 5 A */
+	{ 0xFFFF, 0xFFFF }, /* R1170  - AIF1 DAC1 EQ Band 5 B */
+	{ 0xFFFF, 0xFFFF }, /* R1171  - AIF1 DAC1 EQ Band 5 PG */
+	{ 0x0000, 0x0000 }, /* R1172 */
+	{ 0x0000, 0x0000 }, /* R1173 */
+	{ 0x0000, 0x0000 }, /* R1174 */
+	{ 0x0000, 0x0000 }, /* R1175 */
+	{ 0x0000, 0x0000 }, /* R1176 */
+	{ 0x0000, 0x0000 }, /* R1177 */
+	{ 0x0000, 0x0000 }, /* R1178 */
+	{ 0x0000, 0x0000 }, /* R1179 */
+	{ 0x0000, 0x0000 }, /* R1180 */
+	{ 0x0000, 0x0000 }, /* R1181 */
+	{ 0x0000, 0x0000 }, /* R1182 */
+	{ 0x0000, 0x0000 }, /* R1183 */
+	{ 0xFFFF, 0xFFFF }, /* R1184  - AIF1 DAC2 EQ Gains (1) */
+	{ 0xFFC0, 0xFFC0 }, /* R1185  - AIF1 DAC2 EQ Gains (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1186  - AIF1 DAC2 EQ Band 1 A */
+	{ 0xFFFF, 0xFFFF }, /* R1187  - AIF1 DAC2 EQ Band 1 B */
+	{ 0xFFFF, 0xFFFF }, /* R1188  - AIF1 DAC2 EQ Band 1 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1189  - AIF1 DAC2 EQ Band 2 A */
+	{ 0xFFFF, 0xFFFF }, /* R1190  - AIF1 DAC2 EQ Band 2 B */
+	{ 0xFFFF, 0xFFFF }, /* R1191  - AIF1 DAC2 EQ Band 2 C */
+	{ 0xFFFF, 0xFFFF }, /* R1192  - AIF1 DAC2 EQ Band 2 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1193  - AIF1 DAC2 EQ Band 3 A */
+	{ 0xFFFF, 0xFFFF }, /* R1194  - AIF1 DAC2 EQ Band 3 B */
+	{ 0xFFFF, 0xFFFF }, /* R1195  - AIF1 DAC2 EQ Band 3 C */
+	{ 0xFFFF, 0xFFFF }, /* R1196  - AIF1 DAC2 EQ Band 3 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1197  - AIF1 DAC2 EQ Band 4 A */
+	{ 0xFFFF, 0xFFFF }, /* R1198  - AIF1 DAC2 EQ Band 4 B */
+	{ 0xFFFF, 0xFFFF }, /* R1199  - AIF1 DAC2 EQ Band 4 C */
+	{ 0xFFFF, 0xFFFF }, /* R1200  - AIF1 DAC2 EQ Band 4 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1201  - AIF1 DAC2 EQ Band 5 A */
+	{ 0xFFFF, 0xFFFF }, /* R1202  - AIF1 DAC2 EQ Band 5 B */
+	{ 0xFFFF, 0xFFFF }, /* R1203  - AIF1 DAC2 EQ Band 5 PG */
+	{ 0x0000, 0x0000 }, /* R1204 */
+	{ 0x0000, 0x0000 }, /* R1205 */
+	{ 0x0000, 0x0000 }, /* R1206 */
+	{ 0x0000, 0x0000 }, /* R1207 */
+	{ 0x0000, 0x0000 }, /* R1208 */
+	{ 0x0000, 0x0000 }, /* R1209 */
+	{ 0x0000, 0x0000 }, /* R1210 */
+	{ 0x0000, 0x0000 }, /* R1211 */
+	{ 0x0000, 0x0000 }, /* R1212 */
+	{ 0x0000, 0x0000 }, /* R1213 */
+	{ 0x0000, 0x0000 }, /* R1214 */
+	{ 0x0000, 0x0000 }, /* R1215 */
+	{ 0x0000, 0x0000 }, /* R1216 */
+	{ 0x0000, 0x0000 }, /* R1217 */
+	{ 0x0000, 0x0000 }, /* R1218 */
+	{ 0x0000, 0x0000 }, /* R1219 */
+	{ 0x0000, 0x0000 }, /* R1220 */
+	{ 0x0000, 0x0000 }, /* R1221 */
+	{ 0x0000, 0x0000 }, /* R1222 */
+	{ 0x0000, 0x0000 }, /* R1223 */
+	{ 0x0000, 0x0000 }, /* R1224 */
+	{ 0x0000, 0x0000 }, /* R1225 */
+	{ 0x0000, 0x0000 }, /* R1226 */
+	{ 0x0000, 0x0000 }, /* R1227 */
+	{ 0x0000, 0x0000 }, /* R1228 */
+	{ 0x0000, 0x0000 }, /* R1229 */
+	{ 0x0000, 0x0000 }, /* R1230 */
+	{ 0x0000, 0x0000 }, /* R1231 */
+	{ 0x0000, 0x0000 }, /* R1232 */
+	{ 0x0000, 0x0000 }, /* R1233 */
+	{ 0x0000, 0x0000 }, /* R1234 */
+	{ 0x0000, 0x0000 }, /* R1235 */
+	{ 0x0000, 0x0000 }, /* R1236 */
+	{ 0x0000, 0x0000 }, /* R1237 */
+	{ 0x0000, 0x0000 }, /* R1238 */
+	{ 0x0000, 0x0000 }, /* R1239 */
+	{ 0x0000, 0x0000 }, /* R1240 */
+	{ 0x0000, 0x0000 }, /* R1241 */
+	{ 0x0000, 0x0000 }, /* R1242 */
+	{ 0x0000, 0x0000 }, /* R1243 */
+	{ 0x0000, 0x0000 }, /* R1244 */
+	{ 0x0000, 0x0000 }, /* R1245 */
+	{ 0x0000, 0x0000 }, /* R1246 */
+	{ 0x0000, 0x0000 }, /* R1247 */
+	{ 0x0000, 0x0000 }, /* R1248 */
+	{ 0x0000, 0x0000 }, /* R1249 */
+	{ 0x0000, 0x0000 }, /* R1250 */
+	{ 0x0000, 0x0000 }, /* R1251 */
+	{ 0x0000, 0x0000 }, /* R1252 */
+	{ 0x0000, 0x0000 }, /* R1253 */
+	{ 0x0000, 0x0000 }, /* R1254 */
+	{ 0x0000, 0x0000 }, /* R1255 */
+	{ 0x0000, 0x0000 }, /* R1256 */
+	{ 0x0000, 0x0000 }, /* R1257 */
+	{ 0x0000, 0x0000 }, /* R1258 */
+	{ 0x0000, 0x0000 }, /* R1259 */
+	{ 0x0000, 0x0000 }, /* R1260 */
+	{ 0x0000, 0x0000 }, /* R1261 */
+	{ 0x0000, 0x0000 }, /* R1262 */
+	{ 0x0000, 0x0000 }, /* R1263 */
+	{ 0x0000, 0x0000 }, /* R1264 */
+	{ 0x0000, 0x0000 }, /* R1265 */
+	{ 0x0000, 0x0000 }, /* R1266 */
+	{ 0x0000, 0x0000 }, /* R1267 */
+	{ 0x0000, 0x0000 }, /* R1268 */
+	{ 0x0000, 0x0000 }, /* R1269 */
+	{ 0x0000, 0x0000 }, /* R1270 */
+	{ 0x0000, 0x0000 }, /* R1271 */
+	{ 0x0000, 0x0000 }, /* R1272 */
+	{ 0x0000, 0x0000 }, /* R1273 */
+	{ 0x0000, 0x0000 }, /* R1274 */
+	{ 0x0000, 0x0000 }, /* R1275 */
+	{ 0x0000, 0x0000 }, /* R1276 */
+	{ 0x0000, 0x0000 }, /* R1277 */
+	{ 0x0000, 0x0000 }, /* R1278 */
+	{ 0x0000, 0x0000 }, /* R1279 */
+	{ 0x00FF, 0x01FF }, /* R1280  - AIF2 ADC Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1281  - AIF2 ADC Right Volume */
+	{ 0x00FF, 0x01FF }, /* R1282  - AIF2 DAC Left Volume */
+	{ 0x00FF, 0x01FF }, /* R1283  - AIF2 DAC Right Volume */
+	{ 0x0000, 0x0000 }, /* R1284 */
+	{ 0x0000, 0x0000 }, /* R1285 */
+	{ 0x0000, 0x0000 }, /* R1286 */
+	{ 0x0000, 0x0000 }, /* R1287 */
+	{ 0x0000, 0x0000 }, /* R1288 */
+	{ 0x0000, 0x0000 }, /* R1289 */
+	{ 0x0000, 0x0000 }, /* R1290 */
+	{ 0x0000, 0x0000 }, /* R1291 */
+	{ 0x0000, 0x0000 }, /* R1292 */
+	{ 0x0000, 0x0000 }, /* R1293 */
+	{ 0x0000, 0x0000 }, /* R1294 */
+	{ 0x0000, 0x0000 }, /* R1295 */
+	{ 0xF800, 0xF800 }, /* R1296  - AIF2 ADC Filters */
+	{ 0x0000, 0x0000 }, /* R1297 */
+	{ 0x0000, 0x0000 }, /* R1298 */
+	{ 0x0000, 0x0000 }, /* R1299 */
+	{ 0x0000, 0x0000 }, /* R1300 */
+	{ 0x0000, 0x0000 }, /* R1301 */
+	{ 0x0000, 0x0000 }, /* R1302 */
+	{ 0x0000, 0x0000 }, /* R1303 */
+	{ 0x0000, 0x0000 }, /* R1304 */
+	{ 0x0000, 0x0000 }, /* R1305 */
+	{ 0x0000, 0x0000 }, /* R1306 */
+	{ 0x0000, 0x0000 }, /* R1307 */
+	{ 0x0000, 0x0000 }, /* R1308 */
+	{ 0x0000, 0x0000 }, /* R1309 */
+	{ 0x0000, 0x0000 }, /* R1310 */
+	{ 0x0000, 0x0000 }, /* R1311 */
+	{ 0x02B6, 0x02B6 }, /* R1312  - AIF2 DAC Filters (1) */
+	{ 0x3F00, 0x3F00 }, /* R1313  - AIF2 DAC Filters (2) */
+	{ 0x0000, 0x0000 }, /* R1314 */
+	{ 0x0000, 0x0000 }, /* R1315 */
+	{ 0x0000, 0x0000 }, /* R1316 */
+	{ 0x0000, 0x0000 }, /* R1317 */
+	{ 0x0000, 0x0000 }, /* R1318 */
+	{ 0x0000, 0x0000 }, /* R1319 */
+	{ 0x0000, 0x0000 }, /* R1320 */
+	{ 0x0000, 0x0000 }, /* R1321 */
+	{ 0x0000, 0x0000 }, /* R1322 */
+	{ 0x0000, 0x0000 }, /* R1323 */
+	{ 0x0000, 0x0000 }, /* R1324 */
+	{ 0x0000, 0x0000 }, /* R1325 */
+	{ 0x0000, 0x0000 }, /* R1326 */
+	{ 0x0000, 0x0000 }, /* R1327 */
+	{ 0x0000, 0x0000 }, /* R1328 */
+	{ 0x0000, 0x0000 }, /* R1329 */
+	{ 0x0000, 0x0000 }, /* R1330 */
+	{ 0x0000, 0x0000 }, /* R1331 */
+	{ 0x0000, 0x0000 }, /* R1332 */
+	{ 0x0000, 0x0000 }, /* R1333 */
+	{ 0x0000, 0x0000 }, /* R1334 */
+	{ 0x0000, 0x0000 }, /* R1335 */
+	{ 0x0000, 0x0000 }, /* R1336 */
+	{ 0x0000, 0x0000 }, /* R1337 */
+	{ 0x0000, 0x0000 }, /* R1338 */
+	{ 0x0000, 0x0000 }, /* R1339 */
+	{ 0x0000, 0x0000 }, /* R1340 */
+	{ 0x0000, 0x0000 }, /* R1341 */
+	{ 0x0000, 0x0000 }, /* R1342 */
+	{ 0x0000, 0x0000 }, /* R1343 */
+	{ 0xFFFF, 0xFFFF }, /* R1344  - AIF2 DRC (1) */
+	{ 0x1FFF, 0x1FFF }, /* R1345  - AIF2 DRC (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1346  - AIF2 DRC (3) */
+	{ 0x07FF, 0x07FF }, /* R1347  - AIF2 DRC (4) */
+	{ 0x03FF, 0x03FF }, /* R1348  - AIF2 DRC (5) */
+	{ 0x0000, 0x0000 }, /* R1349 */
+	{ 0x0000, 0x0000 }, /* R1350 */
+	{ 0x0000, 0x0000 }, /* R1351 */
+	{ 0x0000, 0x0000 }, /* R1352 */
+	{ 0x0000, 0x0000 }, /* R1353 */
+	{ 0x0000, 0x0000 }, /* R1354 */
+	{ 0x0000, 0x0000 }, /* R1355 */
+	{ 0x0000, 0x0000 }, /* R1356 */
+	{ 0x0000, 0x0000 }, /* R1357 */
+	{ 0x0000, 0x0000 }, /* R1358 */
+	{ 0x0000, 0x0000 }, /* R1359 */
+	{ 0x0000, 0x0000 }, /* R1360 */
+	{ 0x0000, 0x0000 }, /* R1361 */
+	{ 0x0000, 0x0000 }, /* R1362 */
+	{ 0x0000, 0x0000 }, /* R1363 */
+	{ 0x0000, 0x0000 }, /* R1364 */
+	{ 0x0000, 0x0000 }, /* R1365 */
+	{ 0x0000, 0x0000 }, /* R1366 */
+	{ 0x0000, 0x0000 }, /* R1367 */
+	{ 0x0000, 0x0000 }, /* R1368 */
+	{ 0x0000, 0x0000 }, /* R1369 */
+	{ 0x0000, 0x0000 }, /* R1370 */
+	{ 0x0000, 0x0000 }, /* R1371 */
+	{ 0x0000, 0x0000 }, /* R1372 */
+	{ 0x0000, 0x0000 }, /* R1373 */
+	{ 0x0000, 0x0000 }, /* R1374 */
+	{ 0x0000, 0x0000 }, /* R1375 */
+	{ 0x0000, 0x0000 }, /* R1376 */
+	{ 0x0000, 0x0000 }, /* R1377 */
+	{ 0x0000, 0x0000 }, /* R1378 */
+	{ 0x0000, 0x0000 }, /* R1379 */
+	{ 0x0000, 0x0000 }, /* R1380 */
+	{ 0x0000, 0x0000 }, /* R1381 */
+	{ 0x0000, 0x0000 }, /* R1382 */
+	{ 0x0000, 0x0000 }, /* R1383 */
+	{ 0x0000, 0x0000 }, /* R1384 */
+	{ 0x0000, 0x0000 }, /* R1385 */
+	{ 0x0000, 0x0000 }, /* R1386 */
+	{ 0x0000, 0x0000 }, /* R1387 */
+	{ 0x0000, 0x0000 }, /* R1388 */
+	{ 0x0000, 0x0000 }, /* R1389 */
+	{ 0x0000, 0x0000 }, /* R1390 */
+	{ 0x0000, 0x0000 }, /* R1391 */
+	{ 0x0000, 0x0000 }, /* R1392 */
+	{ 0x0000, 0x0000 }, /* R1393 */
+	{ 0x0000, 0x0000 }, /* R1394 */
+	{ 0x0000, 0x0000 }, /* R1395 */
+	{ 0x0000, 0x0000 }, /* R1396 */
+	{ 0x0000, 0x0000 }, /* R1397 */
+	{ 0x0000, 0x0000 }, /* R1398 */
+	{ 0x0000, 0x0000 }, /* R1399 */
+	{ 0x0000, 0x0000 }, /* R1400 */
+	{ 0x0000, 0x0000 }, /* R1401 */
+	{ 0x0000, 0x0000 }, /* R1402 */
+	{ 0x0000, 0x0000 }, /* R1403 */
+	{ 0x0000, 0x0000 }, /* R1404 */
+	{ 0x0000, 0x0000 }, /* R1405 */
+	{ 0x0000, 0x0000 }, /* R1406 */
+	{ 0x0000, 0x0000 }, /* R1407 */
+	{ 0xFFFF, 0xFFFF }, /* R1408  - AIF2 EQ Gains (1) */
+	{ 0xFFC0, 0xFFC0 }, /* R1409  - AIF2 EQ Gains (2) */
+	{ 0xFFFF, 0xFFFF }, /* R1410  - AIF2 EQ Band 1 A */
+	{ 0xFFFF, 0xFFFF }, /* R1411  - AIF2 EQ Band 1 B */
+	{ 0xFFFF, 0xFFFF }, /* R1412  - AIF2 EQ Band 1 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1413  - AIF2 EQ Band 2 A */
+	{ 0xFFFF, 0xFFFF }, /* R1414  - AIF2 EQ Band 2 B */
+	{ 0xFFFF, 0xFFFF }, /* R1415  - AIF2 EQ Band 2 C */
+	{ 0xFFFF, 0xFFFF }, /* R1416  - AIF2 EQ Band 2 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1417  - AIF2 EQ Band 3 A */
+	{ 0xFFFF, 0xFFFF }, /* R1418  - AIF2 EQ Band 3 B */
+	{ 0xFFFF, 0xFFFF }, /* R1419  - AIF2 EQ Band 3 C */
+	{ 0xFFFF, 0xFFFF }, /* R1420  - AIF2 EQ Band 3 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1421  - AIF2 EQ Band 4 A */
+	{ 0xFFFF, 0xFFFF }, /* R1422  - AIF2 EQ Band 4 B */
+	{ 0xFFFF, 0xFFFF }, /* R1423  - AIF2 EQ Band 4 C */
+	{ 0xFFFF, 0xFFFF }, /* R1424  - AIF2 EQ Band 4 PG */
+	{ 0xFFFF, 0xFFFF }, /* R1425  - AIF2 EQ Band 5 A */
+	{ 0xFFFF, 0xFFFF }, /* R1426  - AIF2 EQ Band 5 B */
+	{ 0xFFFF, 0xFFFF }, /* R1427  - AIF2 EQ Band 5 PG */
+	{ 0x0000, 0x0000 }, /* R1428 */
+	{ 0x0000, 0x0000 }, /* R1429 */
+	{ 0x0000, 0x0000 }, /* R1430 */
+	{ 0x0000, 0x0000 }, /* R1431 */
+	{ 0x0000, 0x0000 }, /* R1432 */
+	{ 0x0000, 0x0000 }, /* R1433 */
+	{ 0x0000, 0x0000 }, /* R1434 */
+	{ 0x0000, 0x0000 }, /* R1435 */
+	{ 0x0000, 0x0000 }, /* R1436 */
+	{ 0x0000, 0x0000 }, /* R1437 */
+	{ 0x0000, 0x0000 }, /* R1438 */
+	{ 0x0000, 0x0000 }, /* R1439 */
+	{ 0x0000, 0x0000 }, /* R1440 */
+	{ 0x0000, 0x0000 }, /* R1441 */
+	{ 0x0000, 0x0000 }, /* R1442 */
+	{ 0x0000, 0x0000 }, /* R1443 */
+	{ 0x0000, 0x0000 }, /* R1444 */
+	{ 0x0000, 0x0000 }, /* R1445 */
+	{ 0x0000, 0x0000 }, /* R1446 */
+	{ 0x0000, 0x0000 }, /* R1447 */
+	{ 0x0000, 0x0000 }, /* R1448 */
+	{ 0x0000, 0x0000 }, /* R1449 */
+	{ 0x0000, 0x0000 }, /* R1450 */
+	{ 0x0000, 0x0000 }, /* R1451 */
+	{ 0x0000, 0x0000 }, /* R1452 */
+	{ 0x0000, 0x0000 }, /* R1453 */
+	{ 0x0000, 0x0000 }, /* R1454 */
+	{ 0x0000, 0x0000 }, /* R1455 */
+	{ 0x0000, 0x0000 }, /* R1456 */
+	{ 0x0000, 0x0000 }, /* R1457 */
+	{ 0x0000, 0x0000 }, /* R1458 */
+	{ 0x0000, 0x0000 }, /* R1459 */
+	{ 0x0000, 0x0000 }, /* R1460 */
+	{ 0x0000, 0x0000 }, /* R1461 */
+	{ 0x0000, 0x0000 }, /* R1462 */
+	{ 0x0000, 0x0000 }, /* R1463 */
+	{ 0x0000, 0x0000 }, /* R1464 */
+	{ 0x0000, 0x0000 }, /* R1465 */
+	{ 0x0000, 0x0000 }, /* R1466 */
+	{ 0x0000, 0x0000 }, /* R1467 */
+	{ 0x0000, 0x0000 }, /* R1468 */
+	{ 0x0000, 0x0000 }, /* R1469 */
+	{ 0x0000, 0x0000 }, /* R1470 */
+	{ 0x0000, 0x0000 }, /* R1471 */
+	{ 0x0000, 0x0000 }, /* R1472 */
+	{ 0x0000, 0x0000 }, /* R1473 */
+	{ 0x0000, 0x0000 }, /* R1474 */
+	{ 0x0000, 0x0000 }, /* R1475 */
+	{ 0x0000, 0x0000 }, /* R1476 */
+	{ 0x0000, 0x0000 }, /* R1477 */
+	{ 0x0000, 0x0000 }, /* R1478 */
+	{ 0x0000, 0x0000 }, /* R1479 */
+	{ 0x0000, 0x0000 }, /* R1480 */
+	{ 0x0000, 0x0000 }, /* R1481 */
+	{ 0x0000, 0x0000 }, /* R1482 */
+	{ 0x0000, 0x0000 }, /* R1483 */
+	{ 0x0000, 0x0000 }, /* R1484 */
+	{ 0x0000, 0x0000 }, /* R1485 */
+	{ 0x0000, 0x0000 }, /* R1486 */
+	{ 0x0000, 0x0000 }, /* R1487 */
+	{ 0x0000, 0x0000 }, /* R1488 */
+	{ 0x0000, 0x0000 }, /* R1489 */
+	{ 0x0000, 0x0000 }, /* R1490 */
+	{ 0x0000, 0x0000 }, /* R1491 */
+	{ 0x0000, 0x0000 }, /* R1492 */
+	{ 0x0000, 0x0000 }, /* R1493 */
+	{ 0x0000, 0x0000 }, /* R1494 */
+	{ 0x0000, 0x0000 }, /* R1495 */
+	{ 0x0000, 0x0000 }, /* R1496 */
+	{ 0x0000, 0x0000 }, /* R1497 */
+	{ 0x0000, 0x0000 }, /* R1498 */
+	{ 0x0000, 0x0000 }, /* R1499 */
+	{ 0x0000, 0x0000 }, /* R1500 */
+	{ 0x0000, 0x0000 }, /* R1501 */
+	{ 0x0000, 0x0000 }, /* R1502 */
+	{ 0x0000, 0x0000 }, /* R1503 */
+	{ 0x0000, 0x0000 }, /* R1504 */
+	{ 0x0000, 0x0000 }, /* R1505 */
+	{ 0x0000, 0x0000 }, /* R1506 */
+	{ 0x0000, 0x0000 }, /* R1507 */
+	{ 0x0000, 0x0000 }, /* R1508 */
+	{ 0x0000, 0x0000 }, /* R1509 */
+	{ 0x0000, 0x0000 }, /* R1510 */
+	{ 0x0000, 0x0000 }, /* R1511 */
+	{ 0x0000, 0x0000 }, /* R1512 */
+	{ 0x0000, 0x0000 }, /* R1513 */
+	{ 0x0000, 0x0000 }, /* R1514 */
+	{ 0x0000, 0x0000 }, /* R1515 */
+	{ 0x0000, 0x0000 }, /* R1516 */
+	{ 0x0000, 0x0000 }, /* R1517 */
+	{ 0x0000, 0x0000 }, /* R1518 */
+	{ 0x0000, 0x0000 }, /* R1519 */
+	{ 0x0000, 0x0000 }, /* R1520 */
+	{ 0x0000, 0x0000 }, /* R1521 */
+	{ 0x0000, 0x0000 }, /* R1522 */
+	{ 0x0000, 0x0000 }, /* R1523 */
+	{ 0x0000, 0x0000 }, /* R1524 */
+	{ 0x0000, 0x0000 }, /* R1525 */
+	{ 0x0000, 0x0000 }, /* R1526 */
+	{ 0x0000, 0x0000 }, /* R1527 */
+	{ 0x0000, 0x0000 }, /* R1528 */
+	{ 0x0000, 0x0000 }, /* R1529 */
+	{ 0x0000, 0x0000 }, /* R1530 */
+	{ 0x0000, 0x0000 }, /* R1531 */
+	{ 0x0000, 0x0000 }, /* R1532 */
+	{ 0x0000, 0x0000 }, /* R1533 */
+	{ 0x0000, 0x0000 }, /* R1534 */
+	{ 0x0000, 0x0000 }, /* R1535 */
+	{ 0x01EF, 0x01EF }, /* R1536  - DAC1 Mixer Volumes */
+	{ 0x0037, 0x0037 }, /* R1537  - DAC1 Left Mixer Routing */
+	{ 0x0037, 0x0037 }, /* R1538  - DAC1 Right Mixer Routing */
+	{ 0x01EF, 0x01EF }, /* R1539  - DAC2 Mixer Volumes */
+	{ 0x0037, 0x0037 }, /* R1540  - DAC2 Left Mixer Routing */
+	{ 0x0037, 0x0037 }, /* R1541  - DAC2 Right Mixer Routing */
+	{ 0x0003, 0x0003 }, /* R1542  - AIF1 ADC1 Left Mixer Routing */
+	{ 0x0003, 0x0003 }, /* R1543  - AIF1 ADC1 Right Mixer Routing */
+	{ 0x0003, 0x0003 }, /* R1544  - AIF1 ADC2 Left Mixer Routing */
+	{ 0x0003, 0x0003 }, /* R1545  - AIF1 ADC2 Right mixer Routing */
+	{ 0x0000, 0x0000 }, /* R1546 */
+	{ 0x0000, 0x0000 }, /* R1547 */
+	{ 0x0000, 0x0000 }, /* R1548 */
+	{ 0x0000, 0x0000 }, /* R1549 */
+	{ 0x0000, 0x0000 }, /* R1550 */
+	{ 0x0000, 0x0000 }, /* R1551 */
+	{ 0x02FF, 0x03FF }, /* R1552  - DAC1 Left Volume */
+	{ 0x02FF, 0x03FF }, /* R1553  - DAC1 Right Volume */
+	{ 0x02FF, 0x03FF }, /* R1554  - DAC2 Left Volume */
+	{ 0x02FF, 0x03FF }, /* R1555  - DAC2 Right Volume */
+	{ 0x0003, 0x0003 }, /* R1556  - DAC Softmute */
+	{ 0x0000, 0x0000 }, /* R1557 */
+	{ 0x0000, 0x0000 }, /* R1558 */
+	{ 0x0000, 0x0000 }, /* R1559 */
+	{ 0x0000, 0x0000 }, /* R1560 */
+	{ 0x0000, 0x0000 }, /* R1561 */
+	{ 0x0000, 0x0000 }, /* R1562 */
+	{ 0x0000, 0x0000 }, /* R1563 */
+	{ 0x0000, 0x0000 }, /* R1564 */
+	{ 0x0000, 0x0000 }, /* R1565 */
+	{ 0x0000, 0x0000 }, /* R1566 */
+	{ 0x0000, 0x0000 }, /* R1567 */
+	{ 0x0003, 0x0003 }, /* R1568  - Oversampling */
+	{ 0x03C3, 0x03C3 }, /* R1569  - Sidetone */
+};
+
+static int wm8994_readable_register(unsigned int reg)
+{
+	switch (reg) {
+	case WM8994_GPIO_1:
+	case WM8994_GPIO_2:
+	case WM8994_GPIO_3:
+	case WM8994_GPIO_4:
+	case WM8994_GPIO_5:
+	case WM8994_GPIO_6:
+	case WM8994_GPIO_7:
+	case WM8994_GPIO_8:
+	case WM8994_GPIO_9:
+	case WM8994_GPIO_10:
+	case WM8994_GPIO_11:
+	case WM8994_INTERRUPT_STATUS_1:
+	case WM8994_INTERRUPT_STATUS_2:
+		return 1;
+	default:
+		break;
+	}
+
+	if (reg >= ARRAY_SIZE(access_masks))
+		return 0;
+	return access_masks[reg].readable != 0;
+}
+
+/*
+ * initialise the WM8994 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int wm8994_init(struct wm8994_priv *wm8994_private,
+		       struct wm8994_platform_data *pdata)
+{
+	struct snd_soc_codec *codec = &wm8994_private->codec;
+	struct wm8994_priv *wm8994;
+	int ret = 0;
+	DEBUG_LOG("");
+	codec->drvdata = kzalloc(sizeof(struct wm8994_priv), GFP_KERNEL);
+	if (codec->drvdata == NULL)
+		return -ENOMEM;
+
+	wm8994 = codec->drvdata;
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	codec->name = "WM8994";
+	codec->owner = THIS_MODULE;
+	codec->read = wm8994_read;
+	codec->write = wm8994_write;
+	codec->readable_register = wm8994_readable_register;
+	codec->reg_cache_size = WM8994_IRQ_POLARITY; /* Skip write sequencer */
+	codec->set_bias_level = NULL;
+	codec->dai = &wm8994_dai;
+	codec->num_dai = 1;
+	wm8994->universal_playback_path = universal_wm8994_playback_paths;
+	wm8994->universal_voicecall_path = universal_wm8994_voicecall_paths;
+	wm8994->universal_mic_path = universal_wm8994_mic_paths;
+	wm8994->universal_clock_control = universal_clock_controls;
+	wm8994->stream_state = PCM_STREAM_DEACTIVE;
+	wm8994->cur_path = OFF;
+	wm8994->rec_path = MIC_OFF;
+	wm8994->power_state = CODEC_OFF;
+	wm8994->input_source = DEFAULT;
+	wm8994->ringtone_active = RING_OFF;
+	wm8994->pdata = pdata;
+
+	wm8994->gain_code = gain_code_check();
+
+	wm8994->codec_clk = clk_get(NULL, "usb_osc");
+
+	wm8994->universal_clock_control(codec, CODEC_ON);
+
+	if (IS_ERR(wm8994->codec_clk)) {
+		pr_err("failed to get MCLK clock from AP\n");
+		ret = PTR_ERR(wm8994->codec_clk);
+		goto card_err;
+	}
+
+	wm8994_write(codec, WM8994_SOFTWARE_RESET, 0x0000);
+
+	wm8994->hw_version = wm8994_read(codec, 0x100);
+
+	wm8994_socdev->card->codec = codec;
+	wm8994_codec = codec;
+
+#ifdef FEATURE_SS_AUDIO_CAL
+	init_tty_mode_procfs();
+	init_loopback_mode_procfs();
+
+	init_timer(&pop_noise_delete_timer);
+	init_timer(&override_timer);
+	
+	timer_on = 0;
+	pop_noise_delete_timer.function = pop_noise_delete_timer_handler;
+	pop_noise_delete_timer.expires = POP_NOISE_DELETE_DELAY_TIME;
+	pop_noise_delete_timer.data = (unsigned long)timer_on;;    // To prevent the phone reset.
+
+	override_timer.function = override_timer_handler;
+	override_timer.expires = OVERRIDE_TIME;
+	override_timer.data = (unsigned long)override_timer_on;
+//	  del_timer(&pop_noise_delete_timer);
+#endif
+
+	ret = snd_soc_new_pcms(wm8994_socdev, SNDRV_DEFAULT_IDX1,
+			       SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		DEBUG_LOG_ERR("failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	wm8994_add_controls(codec);
+	wm8994_add_widgets(codec);
+
+	return ret;
+
+card_err:
+	snd_soc_free_pcms(wm8994_socdev);
+	snd_soc_dapm_free(wm8994_socdev);
+pcm_err:
+
+	return ret;
+}
+
+/* If the i2c layer weren't so broken, we could pass this kind of data
+   around */
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+
+
+static void *control_data1;
+
+static int wm8994_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct snd_soc_codec *codec;
+	struct wm8994_priv *wm8994_priv;
+	int ret = -ENODEV;
+	struct wm8994_platform_data *pdata;
+
+	DEBUG_LOG("");
+
+	wm8994_priv = kzalloc(sizeof(struct wm8994_priv), GFP_KERNEL);
+	if (wm8994_priv == NULL)
+		return -ENOMEM;
+
+	codec = &wm8994_priv->codec;
+#ifdef PM_DEBUG
+	pm_codec = codec;
+#endif
+
+	pdata = i2c->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&i2c->dev, "failed to initialize WM8994\n");
+		goto err_bad_pdata;
+	}
+
+	if (!pdata->set_mic_bias) {
+		dev_err(&i2c->dev, "bad pdata WM8994\n");
+		goto err_bad_pdata;
+	}
+
+	/* CODEC LDO SETTING */
+	if (gpio_is_valid(pdata->ldo)) {
+		ret = gpio_request(pdata->ldo, "WM8994 LDO");
+		if (ret) {
+			pr_err("Failed to request CODEC_LDO_EN!\n");
+			goto err_ldo;
+		}
+		gpio_direction_output(pdata->ldo, 0);
+	}
+
+	s3c_gpio_setpull(pdata->ldo, S3C_GPIO_PULL_NONE);
+
+	/* For preserving output of codec related pins */
+	s3c_gpio_slp_cfgpin(pdata->ldo, S3C_GPIO_SLP_PREV);
+	s3c_gpio_slp_setpull_updown(pdata->ldo, S3C_GPIO_PULL_NONE);
+
+	/* EAR_SEL SETTING(only crespo HW) */
+	if (gpio_is_valid(pdata->ear_sel)) {
+		ret = gpio_request(pdata->ear_sel, "EAR SEL");
+		if (ret) {
+			pr_err("Failed to request EAR_SEL!\n");
+			goto err_earsel;
+		}
+		gpio_direction_output(pdata->ear_sel, 0);
+	}
+	s3c_gpio_setpull(pdata->ear_sel, S3C_GPIO_PULL_NONE);
+
+	s3c_gpio_slp_cfgpin(pdata->ear_sel, S3C_GPIO_SLP_PREV);
+	s3c_gpio_slp_setpull_updown(pdata->ear_sel, S3C_GPIO_PULL_NONE);
+
+	wm8994_ldo_control(pdata, 1);
+
+	codec->hw_write = (hw_write_t) i2c_master_send;
+	i2c_set_clientdata(i2c, wm8994_priv);
+	codec->control_data = i2c;
+	codec->dev = &i2c->dev;
+	control_data1 = i2c;
+
+	ret = wm8994_init(wm8994_priv, pdata);
+#ifdef CONFIG_SND_VOODOO
+  voodoo_hook_wm8994_pcm_probe(codec);
+#endif
+	if (ret) {
+		dev_err(&i2c->dev, "failed to initialize WM8994\n");
+		goto err_init;
+	}
+
+	return ret;
+
+err_init:
+	gpio_free(pdata->ear_sel);
+err_earsel:
+	gpio_free(pdata->ldo);
+err_ldo:
+err_bad_pdata:
+	kfree(wm8994_priv);
+	return ret;
+}
+
+static int wm8994_i2c_remove(struct i2c_client *client)
+{
+	struct wm8994_priv *wm8994_priv = i2c_get_clientdata(client);
+
+	gpio_free(wm8994_priv->pdata->ldo);
+	gpio_free(wm8994_priv->pdata->ear_sel);
+
+	kfree(wm8994_priv);
+	return 0;
+}
+
+static const struct i2c_device_id wm8994_i2c_id[] = {
+	{"wm8994", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, wm8994_i2c_id);
+
+static struct i2c_driver wm8994_i2c_driver = {
+	.driver = {
+		   .name = "WM8994 I2C Codec",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = wm8994_i2c_probe,
+	.remove = wm8994_i2c_remove,
+	.id_table = wm8994_i2c_id,
+};
+
+static int wm8994_add_i2c_device(struct platform_device *pdev,
+				 const struct wm8994_setup_data *setup)
+{
+	int ret;
+
+	ret = i2c_add_driver(&wm8994_i2c_driver);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "can't add i2c driver\n");
+		return ret;
+	}
+
+	return 0;
+
+err_driver:
+	i2c_del_driver(&wm8994_i2c_driver);
+	return -ENODEV;
+}
+#endif
+
+static int wm8994_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct wm8994_setup_data *setup;
+
+	int ret = 0;
+
+	pr_info("WM8994 Audio Codec %s\n", WM8994_VERSION);
+
+	setup = socdev->codec_data;
+	wm8994_socdev = socdev;
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	if (setup->i2c_address)
+		ret = wm8994_add_i2c_device(pdev, setup);
+#else
+	/* Add other interfaces here */
+#endif
+	return ret;
+}
+
+/* power down chip */
+static int wm8994_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = wm8994_codec;
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	i2c_unregister_device(codec->control_data);
+	i2c_del_driver(&wm8994_i2c_driver);
+#endif
+
+	kfree(codec->drvdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int wm8994_suspend(struct platform_device *pdev, pm_message_t msg)
+{
+	struct snd_soc_codec *codec = wm8994_codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("Codec State = [0x%X], Stream State = [0x%X]",
+			wm8994->codec_state, wm8994->stream_state);
+
+	if (wm8994->codec_state == DEACTIVE &&
+		wm8994->stream_state == PCM_STREAM_DEACTIVE) {
+		wm8994->power_state = CODEC_OFF;
+		wm8994_write(codec, WM8994_SOFTWARE_RESET, 0x0000);
+		wm8994_ldo_control(wm8994->pdata, 0);
+		wm8994->universal_clock_control(codec, CODEC_OFF);
+	}
+
+	return 0;
+}
+
+static int wm8994_resume(struct platform_device *pdev)
+{
+	struct snd_soc_codec *codec = wm8994_codec;
+	struct wm8994_priv *wm8994 = codec->drvdata;
+
+	DEBUG_LOG("%s..", __func__);
+	DEBUG_LOG_ERR("------WM8994 Revision = [%d]-------",
+		      wm8994->hw_version);
+
+	if (wm8994->power_state == CODEC_OFF) {
+		/* Turn on sequence by recommend Wolfson.*/
+		wm8994_ldo_control(wm8994->pdata, 1);
+		wm8994->universal_clock_control(codec, CODEC_ON);
+	}
+	return 0;
+}
+#endif
+
+struct snd_soc_codec_device soc_codec_dev_wm8994 = {
+	.probe = wm8994_probe,
+	.remove = wm8994_remove,
+#ifdef CONFIG_PM
+	.suspend = wm8994_suspend,
+	.resume = wm8994_resume,
+#endif
+};
+
+static int __init wm8994_modinit(void)
+{
+	int ret;
+	ret = snd_soc_register_dai(&wm8994_dai);
+	if (ret)
+		pr_err("..dai registration failed..\n");
+
+	return ret;
+}
+
+module_init(wm8994_modinit);
+
+static void __exit wm8994_exit(void)
+{
+	snd_soc_unregister_dai(&wm8994_dai);
+}
+
+module_exit(wm8994_exit);
+
+MODULE_DESCRIPTION("ASoC WM8994 driver");
+MODULE_AUTHOR("Shaju Abraham shaju.abraham@samsung.com");
+MODULE_LICENSE("GPL");
diff --git a/Kernel/sound/soc/codecs/wm8994_voodoo.c b/Kernel/sound/soc/codecs/wm8994_voodoo.c
new file mode 100644
index 0000000..d877d78
--- /dev/null
+++ b/Kernel/sound/soc/codecs/wm8994_voodoo.c
@@ -0,0 +1,1871 @@
+/*
+ * voodoo_sound.c  --  WM8994 ALSA Soc Audio driver related
+ *
+ *  Copyright (C) 2010/11 Franois SIMOND / twitter & XDA-developers @supercurio
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <sound/soc.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/version.h>
+#include "wm8994_voodoo.h"
+
+#ifndef MODULE
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) && !defined(GALAXY_TAB)
+#include "wm8994_samsung.h"
+#else
+#include "wm8994.h"
+#endif
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) && !defined(GALAXY_TAB)
+#include "../wm8994_samsung.h"
+#else
+#include "../wm8994.h"
+#endif
+#endif
+
+#define SUBJECT "wm8994_voodoo.c"
+
+#ifdef MODULE
+#include "tegrak_voodoo_sound.h"
+
+// wm8994_write -> tegrak_wm8994_write for dynamic link
+#ifdef wm8994_write
+#undef wm8994_write
+#endif
+
+// wm8994_read -> tegrak_wm8994_read for dynamic link
+#ifdef wm8994_read
+#undef wm8994_read
+#endif
+
+#define wm8994_write(codec, reg, value) tegrak_wm8994_write(codec, reg, value)
+#define wm8994_read(codec, reg) tegrak_wm8994_read(codec, reg)
+#endif
+
+bool bypass_write_hook = false;
+
+short unsigned int debug_log_level = LOG_OFF;
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+unsigned short hp_level[2] = { CONFIG_SND_VOODOO_HP_LEVEL,
+			       CONFIG_SND_VOODOO_HP_LEVEL };
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+bool fm_radio_headset_restore_bass = true;
+bool fm_radio_headset_restore_highs = true;
+bool fm_radio_headset_normalize_gain = true;
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+unsigned short recording_preset = 1;
+unsigned short origin_recgain;
+unsigned short origin_recgain_mixer;
+#endif
+
+#ifdef NEXUS_S
+bool speaker_tuning = false;
+#endif
+
+// global active or kill switch
+bool enable = false;
+
+bool dac_osr128 = true;
+bool adc_osr128 = false;
+#ifndef GALAXY_TAB_TEGRA
+bool fll_tuning = true;
+#endif
+bool dac_direct = true;
+bool mono_downmix = false;
+
+// equalizer
+
+// digital gain value in mili dB
+int digital_gain = 0;
+
+bool headphone_eq = false;
+short eq_gains[5] = { 0, 0, 0, 0, 0 };
+short eq_bands[5] = { 3, 4, 4, 4, 3 };
+char eq_band_coef_names[][2] = { "A", "B", "C", "PG" };
+
+unsigned int eq_band_values[5][4] = {
+	{0x0FCA, 0x0400, 0x00D8},
+	{0x1EB5, 0xF145, 0x0B75, 0x01C5},
+	{0x1C58, 0xF373, 0x0A54, 0x0558},
+	{0x168E, 0xF829, 0x07AD, 0x1103},
+	{0x0564, 0x0559, 0x4000}
+};
+
+// 3D effect
+bool stereo_expansion = false;
+short unsigned int stereo_expansion_gain = 16;
+
+// keep here a pointer to the codec structure
+struct snd_soc_codec *codec;
+
+#define DECLARE_BOOL_SHOW(name) 					       \
+static ssize_t name##_show(struct device *dev,				       \
+struct device_attribute *attr, char *buf)				       \
+{									       \
+	return sprintf(buf,"%u\n",(name ? 1 : 0));			       \
+}
+
+#define DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(name, updater, with_mute)	       \
+static ssize_t name##_store(struct device *dev, struct device_attribute *attr, \
+	const char *buf, size_t size)					       \
+{									       \
+	unsigned short state;						       \
+	if (sscanf(buf, "%hu", &state) == 1) {				       \
+		name = state == 0 ? false : true;			       \
+		if (debug_log(LOG_INFOS))				       \
+			printk("Voodoo sound: %s: %u\n", #updater, state);     \
+		updater(with_mute);					       \
+	}								       \
+	return size;							       \
+}
+
+#define DECLARE_EQ_GAIN_SHOW(band)					       \
+static ssize_t headphone_eq_b##band##_gain_show(struct device *dev,	       \
+					 struct device_attribute *attr,	       \
+					 char *buf)			       \
+{									       \
+	return sprintf(buf, "%d\n", eq_gains[band - 1]);		       \
+}
+
+#define DECLARE_EQ_GAIN_STORE(band)					       \
+static ssize_t headphone_eq_b##band##_gain_store(struct device *dev,	       \
+					  struct device_attribute *attr,       \
+					  const char *buf, size_t size)	       \
+{									       \
+	short new_gain;							       \
+	if (sscanf(buf, "%hd", &new_gain) == 1) {			       \
+		if (new_gain >= -12 && new_gain <= 12) {		       \
+			smooth_apply_eq_band_gain(band - 1,		       \
+						  eq_gains[band - 1],	       \
+						  new_gain,		       \
+						  headphone_eq);	       \
+			eq_gains[band - 1] = new_gain;			       \
+		}							       \
+	}								       \
+	return size;							       \
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+#define DECLARE_WM8994(codec) struct wm8994_priv *wm8994 = codec->drvdata;
+#else
+#define DECLARE_WM8994(codec) struct wm8994_priv *wm8994 = codec->private_data;
+#endif
+
+bool debug_log(short unsigned int level)
+{
+	if (debug_log_level >= level)
+		return true;
+
+	return false;
+}
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+int hpvol(int channel)
+{
+	int vol;
+
+	vol = hp_level[channel];
+
+	if (is_path_media_or_fm_no_call_no_record()) {
+		// negative digital gain compensation
+		if (digital_gain < 0)
+			vol = (vol - ((digital_gain / 100) + 5) / 10);
+
+		if (vol > 62)
+			return 62;
+	}
+
+	return vol;
+}
+
+void write_hpvol(unsigned short l, unsigned short r)
+{
+	unsigned short val;
+
+	// we don't need the Volume Update flag when sending the first volume
+	val = (WM8994_HPOUT1L_MUTE_N | l);
+	val |= WM8994_HPOUT1L_ZC;
+	wm8994_write(codec, WM8994_LEFT_OUTPUT_VOLUME, val);
+
+	// this time we write the right volume plus the Volume Update flag.
+	// This way, both volume are set at the same time
+	val = (WM8994_HPOUT1_VU | WM8994_HPOUT1R_MUTE_N | r);
+	val |= WM8994_HPOUT1L_ZC;
+	wm8994_write(codec, WM8994_RIGHT_OUTPUT_VOLUME, val);
+}
+
+void update_hpvol(bool with_fade)
+{
+	unsigned short val;
+	unsigned short i;
+	short steps;
+	int hp_level_old[2];
+	unsigned short hp_level_registers[2] = { WM8994_LEFT_OUTPUT_VOLUME,
+						 WM8994_RIGHT_OUTPUT_VOLUME };
+
+	DECLARE_WM8994(codec);
+
+	// don't affect headphone amplifier volume
+	// when not on heapdhones or if call is active
+	if (!is_path(HEADPHONES)
+	    || (wm8994->codec_state & CALL_ACTIVE))
+		return;
+
+
+	if (!with_fade) {
+		bypass_write_hook = true;
+		write_hpvol(hpvol(0), hpvol(1));
+		bypass_write_hook = false;
+		return;
+	}
+
+	// read previous levels
+	for (i = 0; i < 2; i++) {
+		val = wm8994_read(codec, hp_level_registers[i]);
+		val &= ~(WM8994_HPOUT1_VU_MASK);
+		val &= ~(WM8994_HPOUT1L_ZC_MASK);
+		val &= ~(WM8994_HPOUT1L_MUTE_N_MASK);
+		hp_level_old[i] = val + (digital_gain / 1000);
+
+		if (hp_level_old[i] < 0)
+			hp_level_old[i] = 0;
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: previous hp_level[%hu]: %d\n",
+			       i, hp_level_old[i]);
+	}
+
+	// calculate number of steps for volume fade
+	steps = hp_level[0] - hp_level_old[0];
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: volume change steps: %hd "
+		       "start: %hu, end: %hu\n",
+		       steps,
+		       hp_level_old[0],
+		       hp_level[0]);
+
+	while (steps != 0) {
+		if (hp_level[0] < hp_level_old[0])
+			steps++;
+		else
+			steps--;
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: volume: %hu\n",
+			       (hpvol(0) - steps));
+
+		bypass_write_hook = true;
+		write_hpvol(hpvol(0) - steps, hpvol(1) - steps);
+		bypass_write_hook = false;
+
+		if (steps != 0)
+			udelay(1000);
+	}
+
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+void update_fm_radio_headset_restore_freqs(bool with_mute)
+{
+	unsigned short val;
+	DECLARE_WM8994(codec);
+
+	bypass_write_hook = true;
+	// apply only when FM radio is active
+	if (wm8994->fmradio_path == FMR_OFF)
+		return;
+
+	if (with_mute) {
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1,
+			     WM8994_AIF2DAC_MUTE |
+			     WM8994_AIF2DAC_MUTERATE |
+			     WM8994_AIF2DAC_UNMUTE_RAMP |
+			     WM8994_AIF2DAC_DEEMP_MASK);
+		msleep(180);
+	}
+
+	if (fm_radio_headset_restore_bass) {
+		// disable Sidetone high-pass filter
+		// was designed for voice and not FM radio
+		wm8994_write(codec, WM8994_SIDETONE, 0x0000);
+		// disable 4FS ultrasonic mode and
+		// restore the hi-fi <4Hz hi pass filter
+		wm8994_write(codec, WM8994_AIF2_ADC_FILTERS,
+			     WM8994_AIF2ADCL_HPF |
+			     WM8994_AIF2ADCR_HPF);
+	} else {
+		// default settings in GT-I9000 Froyo XXJPX kernel sources
+		wm8994_write(codec, WM8994_SIDETONE, 0x01c0);
+		wm8994_write(codec, WM8994_AIF2_ADC_FILTERS, 0xF800);
+	}
+
+	if (fm_radio_headset_restore_highs) {
+		val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+		val &= ~(WM8994_AIF2DAC_DEEMP_MASK);
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+	} else {
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, 0x0036);
+	}
+
+	// un-mute
+	if (with_mute) {
+		val = wm8994_read(codec, WM8994_AIF2_DAC_FILTERS_1);
+		val &= ~(WM8994_AIF2DAC_MUTE_MASK);
+		wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val);
+	}
+	bypass_write_hook = false;
+}
+
+void update_fm_radio_headset_normalize_gain(bool with_mute)
+{
+	DECLARE_WM8994(codec);
+
+	bypass_write_hook = true;
+	// apply only when FM radio is active
+	if (wm8994->fmradio_path == FMR_OFF)
+		return;
+
+	if (fm_radio_headset_normalize_gain) {
+		// Bumped volume, change with Zero Cross
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_3_4_VOLUME, 0x52);
+		wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_3_4_VOLUME, 0x152);
+		wm8994_write(codec, WM8994_AIF2_DRC_2, 0x0840);
+		wm8994_write(codec, WM8994_AIF2_DRC_3, 0x2408);
+		wm8994_write(codec, WM8994_AIF2_DRC_4, 0x0082);
+		wm8994_write(codec, WM8994_AIF2_DRC_5, 0x0100);
+		wm8994_write(codec, WM8994_AIF2_DRC_1, 0x019C);
+	} else {
+		// Original volume, change with Zero Cross
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_3_4_VOLUME, 0x4B);
+		wm8994_write(codec, WM8994_RIGHT_LINE_INPUT_3_4_VOLUME, 0x14B);
+		wm8994_write(codec, WM8994_AIF2_DRC_2, 0x0840);
+		wm8994_write(codec, WM8994_AIF2_DRC_3, 0x2400);
+		wm8994_write(codec, WM8994_AIF2_DRC_4, 0x0000);
+		wm8994_write(codec, WM8994_AIF2_DRC_5, 0x0000);
+		wm8994_write(codec, WM8994_AIF2_DRC_1, 0x019C);
+	}
+	bypass_write_hook = false;
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+void update_recording_preset(bool with_mute)
+{
+	if (!is_path(MAIN_MICROPHONE))
+		return;
+
+	switch (recording_preset) {
+	case 0:
+		// Original:
+		// On Galaxy S: IN1L_VOL1=11000 (+19.5 dB)
+		// On Nexus S: variable value
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME,
+			     WM8994_IN1L_VU | origin_recgain);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3, origin_recgain_mixer);
+		// DRC disabled
+		wm8994_write(codec, WM8994_AIF1_DRC1_1, 0x0080);
+		break;
+	case 2:
+		// High sensitivy:
+		// Original - 4.5 dB, IN1L_VOL1=10101 (+15 dB)
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x0115);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+			     WM8994_IN1L_TO_MIXINL |
+			     WM8994_IN1L_MIXINL_VOL);
+		// DRC Input: -6dB, Ouptut -3.75dB
+		//     Above knee 1/8, Below knee 1/2
+		//     Max gain 24 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0426);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0019);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x0105);
+		break;
+	case 3:
+		// Concert new: IN1L_VOL1=10110 (+4.5 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x010F);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -4.5dB, Ouptut -6.75dB
+		//     Above knee 1/4, Below knee 1/2
+		//     Max gain 24 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0846);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0011);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00C9);
+		break;
+	case 4:
+		// ULTRA LOUD:
+		// Original - 36 dB - 30 dB IN1L_VOL1=00000 (-16.5 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x0100);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -7.5dB, Ouptut -6dB
+		//     Above knee 1/8, Below knee 1/4
+		//     Max gain 36 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0847);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x001A);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00C9);
+		break;
+	default:
+		// make sure recording_preset is the default
+		recording_preset = 1;
+		// New Balanced: Original - 16.5 dB
+		// IN1L_VOL1=01101 (+27 dB)
+		// +30dB input mixer gain deactivated
+		wm8994_write(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME, 0x055D);
+		wm8994_write(codec, WM8994_INPUT_MIXER_3,
+		             WM8994_IN1L_TO_MIXINL);
+		// DRC Input: -18.5dB, Ouptut -9dB
+		//     Above knee 1/8, Below knee 1/2
+		//     Max gain 18 / Min gain -12
+		wm8994_write(codec, WM8994_AIF1_DRC1_1,
+			     WM8994_AIF1DRC1_SIG_DET_MODE |
+			     WM8994_AIF1DRC1_QR |
+			     WM8994_AIF1DRC1_ANTICLIP |
+			     WM8994_AIF1ADC1L_DRC_ENA);
+		wm8994_write(codec, WM8994_AIF1_DRC1_2, 0x0845);
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0019);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x030C);
+		break;
+	}
+}
+#endif
+
+bool is_path(int unified_path)
+{
+	DECLARE_WM8994(codec);
+
+	switch (unified_path) {
+	// speaker
+	case SPEAKER:
+#ifdef GALAXY_TAB
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == RING_SPK
+			|| wm8994->fmradio_path == FMR_SPK
+			|| wm8994->fmradio_path == FMR_SPK_MIX);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == SPK_HP);
+#else
+		return (wm8994->cur_path == SPK
+			|| wm8994->cur_path == RING_SPK);
+#endif
+#endif
+
+	// headphones
+	case HEADPHONES:
+
+#ifdef NEXUS_S
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+#ifdef GALAXY_TAB
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+		return (wm8994->cur_path == HP3P
+			|| wm8994->cur_path == HP4P
+			|| wm8994->fmradio_path == FMR_HP);
+#endif
+#else
+#ifdef M110S
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+		return (wm8994->cur_path == HP);
+#endif
+#else
+#ifdef GALAXY_TAB_TEGRA
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		return (wm8994->cur_path == HP
+			|| wm8994->cur_path == HP_NO_MIC
+			|| wm8994->fmradio_path == FMR_HP);
+#else
+		return (wm8994->cur_path == HP
+			|| wm8994->fmradio_path == FMR_HP);
+#endif
+#endif
+#endif
+#endif
+#endif
+
+	// FM Radio on headphones
+	case RADIO_HEADPHONES:
+#ifdef NEXUS_S
+		return false;
+#else
+#ifdef M110S
+		return false;
+#else
+#ifdef GALAXY_TAB_TEGRA
+		return false;
+#else
+#ifdef GALAXY_TAB
+		return false;
+#else
+		return (wm8994->codec_state & FMRADIO_ACTIVE)
+		    && (wm8994->fmradio_path == FMR_HP);
+#endif
+#endif
+#endif
+#endif
+
+	// Standard recording presets
+	// for M110S Gingerbread: added check non call
+	case MAIN_MICROPHONE:
+		return (wm8994->codec_state & CAPTURE_ACTIVE)
+		    && (wm8994->rec_path == MAIN)
+		    && !(wm8994->codec_state & CALL_ACTIVE);
+
+	}
+	return false;
+}
+
+bool is_path_media_or_fm_no_call_no_record()
+{
+
+	DECLARE_WM8994(codec);
+
+	if ((is_path(HEADPHONES)
+	     && (wm8994->codec_state & PLAYBACK_ACTIVE)
+	     && (wm8994->stream_state & PCM_STREAM_PLAYBACK)
+	     && !(wm8994->codec_state & CALL_ACTIVE)
+	     && (wm8994->rec_path == MIC_OFF)
+	    ) || is_path(RADIO_HEADPHONES))
+		return true;
+
+	return false;
+}
+
+#ifdef NEXUS_S
+void update_speaker_tuning(bool with_mute)
+{
+	DECLARE_WM8994(codec);
+
+	if (!(is_path(SPEAKER) || (wm8994->codec_state & CALL_ACTIVE)))
+		return;
+
+	if (speaker_tuning) {
+		// DRC settings
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0010);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x00EB);
+
+		// hardware EQ
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1,   0x041D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2,   0x4C00);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_A,  0x0FE3);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_B,  0x0403);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_PG, 0x0074);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_A,  0x1F03);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_B,  0xF0F9);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_PG, 0x03DA);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_A,  0x1ED2);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_B,  0xF11A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_PG, 0x045D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_A,  0x0E76);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_B,  0xFCE4);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_4_PG, 0x330D);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_A,  0xFC8F);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_B,  0x0400);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_5_PG, 0x323C);
+
+		// Speaker Boost tuning
+		wm8994_write(codec, WM8994_CLASSD,                 0x0170);
+	} else {
+		// DRC settings
+		wm8994_write(codec, WM8994_AIF1_DRC1_3, 0x0028);
+		wm8994_write(codec, WM8994_AIF1_DRC1_4, 0x0186);
+
+		// hardware EQ
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1,   0x0019);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2,   0x6280);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_A,  0x0FC3);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_B,  0x03FD);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_1_PG, 0x00F4);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_A,  0x1F30);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_B,  0xF0CD);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_2_PG, 0x032C);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_A,  0x1C52);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_B,  0xF379);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_C,  0x040A);
+		wm8994_write(codec, WM8994_AIF1_DAC1_EQ_BAND_3_PG, 0x0DC1);
+		wm8994_write(codec, WM8994_CLASSD,                 0x0170);
+
+		// Speaker Boost tuning
+		wm8994_write(codec, WM8994_CLASSD,                 0x0168);
+	}
+}
+#endif
+
+unsigned short osr128_get_value(unsigned short val)
+{
+	if (dac_osr128 == 1)
+		val |= WM8994_DAC_OSR128;
+	else
+		val &= ~WM8994_DAC_OSR128;
+
+	if (adc_osr128 == 1)
+		val |= WM8994_ADC_OSR128;
+	else
+		val &= ~WM8994_ADC_OSR128;
+
+	return val;
+}
+
+void update_osr128(bool with_mute)
+{
+	unsigned short val;
+	val = osr128_get_value(wm8994_read(codec, WM8994_OVERSAMPLING));
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_OVERSAMPLING, val);
+	bypass_write_hook = false;
+}
+
+#ifndef GALAXY_TAB_TEGRA
+unsigned short fll_tuning_get_value(unsigned short val)
+{
+	val = (val >> WM8994_FLL1_GAIN_WIDTH << WM8994_FLL1_GAIN_WIDTH);
+	if (fll_tuning == 1)
+		val |= 5;
+
+	return val;
+}
+
+void update_fll_tuning(bool with_mute)
+{
+	unsigned short val;
+	val = fll_tuning_get_value(wm8994_read(codec, WM8994_FLL1_CONTROL_4));
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_FLL1_CONTROL_4, val);
+	bypass_write_hook = false;
+}
+#endif
+
+unsigned short mono_downmix_get_value(unsigned short val, bool can_reverse)
+{
+	DECLARE_WM8994(codec);
+
+	// Takes care not switching to Stereo on speaker or during a call
+	if (!is_path(SPEAKER) && !(wm8994->codec_state & CALL_ACTIVE)) {
+		if (mono_downmix) {
+			val |= WM8994_AIF1DAC1_MONO;
+		} else {
+			if (can_reverse)
+				val &= ~WM8994_AIF1DAC1_MONO;
+		}
+	}
+
+	return val;
+}
+
+void update_mono_downmix(bool with_mute)
+{
+	unsigned short val1, val2, val3;
+	val1 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF1_DAC1_FILTERS_1),
+				      true);
+	val2 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF1_DAC2_FILTERS_1),
+				      true);
+	val3 = mono_downmix_get_value(wm8994_read
+				      (codec, WM8994_AIF2_DAC_FILTERS_1),
+				      true);
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_1, val1);
+	wm8994_write(codec, WM8994_AIF1_DAC2_FILTERS_1, val2);
+	wm8994_write(codec, WM8994_AIF2_DAC_FILTERS_1, val3);
+	bypass_write_hook = false;
+}
+
+unsigned short dac_direct_get_value(unsigned short val, bool can_reverse)
+{
+	if (is_path_media_or_fm_no_call_no_record()) {
+
+		if (dac_direct) {
+			if (val == WM8994_DAC1L_TO_MIXOUTL)
+				return WM8994_DAC1L_TO_HPOUT1L;
+		} else {
+			if (val == WM8994_DAC1L_TO_HPOUT1L && can_reverse)
+				return WM8994_DAC1L_TO_MIXOUTL;
+		}
+	}
+
+	return val;
+}
+
+void update_dac_direct(bool with_mute)
+{
+	unsigned short val1, val2;
+	val1 = dac_direct_get_value(wm8994_read(codec,
+						WM8994_OUTPUT_MIXER_1), true);
+	val2 = dac_direct_get_value(wm8994_read(codec,
+						WM8994_OUTPUT_MIXER_2), true);
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_1, val1);
+	wm8994_write(codec, WM8994_OUTPUT_MIXER_2, val2);
+	bypass_write_hook = false;
+}
+
+unsigned short digital_gain_get_value(unsigned short val)
+{
+	// AIF gain to 0dB
+	int aif_gain = 0xC0;
+	int i;
+	int step = -375;
+
+	if (is_path_media_or_fm_no_call_no_record()) {
+
+		if (digital_gain <= 0) {
+			// clear the actual DAC volume for this value
+			val &= ~(WM8994_DAC1R_VOL_MASK);
+
+			// calculation with round
+			i = ((digital_gain * 10 / step) + 5) / 10;
+			aif_gain -= i;
+			val |= aif_gain;
+
+			if (debug_log(LOG_INFOS))
+				printk("Voodoo sound: digital gain: %d mdB, "
+				       "%d mdB steps: %d, "
+				       "real AIF gain: %d mdB\n",
+				       digital_gain, step, i, i * step);
+		}
+	}
+
+	return val;
+}
+
+void update_digital_gain(bool with_mute)
+{
+	unsigned short val1, val2;
+	val1 = digital_gain_get_value(wm8994_read(codec,
+						WM8994_AIF1_DAC1_LEFT_VOLUME));
+	val2 = digital_gain_get_value(wm8994_read(codec,
+						WM8994_AIF1_DAC1_RIGHT_VOLUME));
+
+	bypass_write_hook = true;
+	wm8994_write(codec, WM8994_AIF1_DAC1_LEFT_VOLUME,
+		     WM8994_DAC1_VU | val1);
+	wm8994_write(codec, WM8994_AIF1_DAC1_RIGHT_VOLUME,
+		     WM8994_DAC1_VU | val2);
+	bypass_write_hook = false;
+}
+
+void update_headphone_eq(bool update_bands)
+{
+	int gains_1;
+	int gains_2;
+
+	if (!is_path_media_or_fm_no_call_no_record()) {
+		// don't apply the EQ
+		return;
+	}
+
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: EQ gains (dB): %hd, %hd, %hd, %hd, %hd\n",
+		       eq_gains[0], eq_gains[1], eq_gains[2],
+		       eq_gains[3], eq_gains[4]);
+
+	gains_1 =
+	    ((eq_gains[0] + 12) << WM8994_AIF1DAC1_EQ_B1_GAIN_SHIFT) |
+	    ((eq_gains[1] + 12) << WM8994_AIF1DAC1_EQ_B2_GAIN_SHIFT) |
+	    ((eq_gains[2] + 12) << WM8994_AIF1DAC1_EQ_B3_GAIN_SHIFT) |
+	    headphone_eq;
+
+	gains_2 =
+	    ((eq_gains[3] + 12) << WM8994_AIF1DAC1_EQ_B4_GAIN_SHIFT) |
+	    ((eq_gains[4] + 12) << WM8994_AIF1DAC1_EQ_B5_GAIN_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_1, gains_1);
+	wm8994_write(codec, WM8994_AIF1_DAC1_EQ_GAINS_2, gains_2);
+
+	// don't send EQ configuration if its not enabled
+	if (!headphone_eq)
+		return;
+
+	if (update_bands)
+		update_headphone_eq_bands();
+}
+
+void update_headphone_eq_bands()
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+
+	for (i = 0; i < ARRAY_SIZE(eq_band_values); i++) {
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: send EQ Band %d\n", i + 1);
+
+		for (j = 0; j < eq_bands[i]; j++) {
+			wm8994_write(codec,
+				     first_reg + k, eq_band_values[i][j]);
+			k++;
+		}
+	}
+}
+
+void smooth_apply_eq_band_gain(int band, int start, int end, bool current_state)
+{
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: EQ smooth transition for Band %d "
+		       "from %d to %d\n", band + 1, start, end);
+
+	if (start == end) {
+		if (end != 0)
+			update_headphone_eq(true);
+		else
+			update_headphone_eq(false);
+		return;
+	}
+
+	if (current_state)
+		update_headphone_eq_bands();
+
+	while (start != end) {
+		if (start < end)
+			start++;
+		else
+			start--;
+
+		eq_gains[band] = start;
+		update_headphone_eq(false);
+	}
+}
+
+void update_stereo_expansion(bool with_mute)
+{
+	short unsigned int val;
+
+	val = wm8994_read(codec, WM8994_AIF1_DAC1_FILTERS_2);
+	if (stereo_expansion) {
+		val &= ~(WM8994_AIF1DAC1_3D_GAIN_MASK);
+		val |= (stereo_expansion_gain << WM8994_AIF1DAC1_3D_GAIN_SHIFT);
+	}
+	val &= ~(WM8994_AIF1DAC1_3D_ENA_MASK);
+	val |= (stereo_expansion << WM8994_AIF1DAC1_3D_ENA_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DAC1_FILTERS_2, val);
+}
+
+void load_current_eq_values()
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+
+	for (i = 0; i < ARRAY_SIZE(eq_band_values); i++)
+		for (j = 0; j < eq_bands[i]; j++) {
+			eq_band_values[i][j] =
+			    wm8994_read(codec, first_reg + k);
+			k++;
+		}
+}
+
+void apply_saturation_prevention_drc()
+{
+	unsigned short val;
+	unsigned short drc_gain = 0;
+	int i;
+	int step = 750;
+
+	// don't apply the limiter if not playing media
+	// (exclude FM radio, it has its own DRC settings)
+	if (!is_path_media_or_fm_no_call_no_record()
+	    || is_path(RADIO_HEADPHONES))
+		return;
+
+	// don't apply the limiter without stereo_expansion or headphone_eq
+	// or a positive digital gain
+	if (!(stereo_expansion
+	      || headphone_eq
+	      || digital_gain >= 0))
+		return;
+
+	if (debug_log(LOG_INFOS))
+		printk("Voodoo sound: apply saturation prevention DRC\n");
+
+	// configure the DRC to avoid saturation: not actually compress signal
+	// gain is unmodified. Should affect only what's higher than 0 dBFS
+
+	// tune Attack & Decacy values
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_2);
+	val &= ~(WM8994_AIF1DRC1_ATK_MASK);
+	val &= ~(WM8994_AIF1DRC1_DCY_MASK);
+	val |= (0x1 << WM8994_AIF1DRC1_ATK_SHIFT);
+	val |= (0x4 << WM8994_AIF1DRC1_DCY_SHIFT);
+
+	// set DRC maximum gain to 36 dB
+	val &= ~(WM8994_AIF1DRC1_MAXGAIN_MASK);
+	val |= (0x3 << WM8994_AIF1DRC1_MAXGAIN_SHIFT);
+
+	wm8994_write(codec, WM8994_AIF1_DRC1_2, val);
+
+	// Above knee: flat (what really avoid the saturation)
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_3);
+	val |= (0x5 << WM8994_AIF1DRC1_HI_COMP_SHIFT);
+	wm8994_write(codec, WM8994_AIF1_DRC1_3, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_1);
+	// disable Quick Release and Anti Clip
+	// both do do more harm than good for this particular usage
+	val &= ~(WM8994_AIF1DRC1_QR_MASK);
+	val &= ~(WM8994_AIF1DRC1_ANTICLIP_MASK);
+
+	// enable DRC
+	val &= ~(WM8994_AIF1DAC1_DRC_ENA_MASK);
+	val |= WM8994_AIF1DAC1_DRC_ENA;
+	wm8994_write(codec, WM8994_AIF1_DRC1_1, val);
+
+	val = wm8994_read(codec, WM8994_AIF1_DRC1_4);
+	val &= ~(WM8994_AIF1DRC1_KNEE_IP_MASK);
+
+	if (digital_gain >= 0) {
+		// deal with positive digital gains
+		i = ((digital_gain * 10 / step) + 5) / 10;
+		drc_gain += i;
+		val |= (drc_gain << WM8994_AIF1DRC1_KNEE_IP_SHIFT);
+
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: digital gain: %d mdB, "
+			       "%d mdB steps: %d, real DRC gain: %d mdB\n",
+			       digital_gain, step, i, i * step);
+
+	}
+	wm8994_write(codec, WM8994_AIF1_DRC1_4, val);
+}
+
+/*
+ *
+ * Declaring the controling misc devices
+ *
+ */
+static ssize_t debug_log_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%u\n", debug_log_level);
+}
+
+static ssize_t debug_log_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	sscanf(buf, "%hu", &debug_log_level);
+	return size;
+}
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+static ssize_t headphone_amplifier_level_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	// output median of left and right headphone amplifier volumes
+	return sprintf(buf, "%u\n", (hp_level[0] + hp_level[1]) / 2);
+}
+
+static ssize_t headphone_amplifier_level_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t size)
+{
+	unsigned short vol;
+	if (sscanf(buf, "%hu", &vol) == 1) {
+
+		// hard limit to 62 because 63 introduces distortions
+		if (vol > 62)
+			vol = 62;
+
+		// left and right are set to the same volumes by this control
+		hp_level[0] = hp_level[1] = vol;
+
+		update_digital_gain(false);
+		update_hpvol(true);
+	}
+	return size;
+}
+#endif
+
+#ifdef NEXUS_S
+DECLARE_BOOL_SHOW(speaker_tuning);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(speaker_tuning,
+				    update_speaker_tuning,
+				    false);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+DECLARE_BOOL_SHOW(fm_radio_headset_restore_bass);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_restore_bass,
+				    update_fm_radio_headset_restore_freqs,
+				    true);
+
+DECLARE_BOOL_SHOW(fm_radio_headset_restore_highs);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_restore_highs,
+				    update_fm_radio_headset_restore_freqs,
+				    true);
+
+DECLARE_BOOL_SHOW(fm_radio_headset_normalize_gain);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fm_radio_headset_normalize_gain,
+				    update_fm_radio_headset_normalize_gain,
+				    false);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+static ssize_t recording_preset_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", recording_preset);
+}
+
+static ssize_t recording_preset_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	unsigned short preset_number;
+	if (sscanf(buf, "%hu", &preset_number) == 1) {
+		recording_preset = preset_number;
+		update_recording_preset(false);
+	}
+	return size;
+}
+#endif
+
+DECLARE_BOOL_SHOW(dac_osr128);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(dac_osr128,
+				    update_osr128,
+				    false);
+
+DECLARE_BOOL_SHOW(adc_osr128);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(adc_osr128,
+				    update_osr128,
+				    false);
+
+#ifndef GALAXY_TAB_TEGRA
+DECLARE_BOOL_SHOW(fll_tuning);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(fll_tuning,
+				    update_fll_tuning,
+				    false);
+#endif
+
+DECLARE_BOOL_SHOW(mono_downmix);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(mono_downmix,
+				    update_mono_downmix,
+				    false);
+
+DECLARE_BOOL_SHOW(dac_direct);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(dac_direct,
+				    update_dac_direct,
+				    false);
+
+static ssize_t digital_gain_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", digital_gain);
+}
+
+static ssize_t digital_gain_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	int new_digital_gain;
+	if (sscanf(buf, "%d", &new_digital_gain) == 1) {
+		if (new_digital_gain <= 36000 && new_digital_gain >= -71625) {
+			if (new_digital_gain > digital_gain) {
+				// reduce analog volume first
+				digital_gain = new_digital_gain;
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+				update_hpvol(false);
+#endif
+				update_digital_gain(false);
+			} else {
+				// reduce digital volume first
+				digital_gain = new_digital_gain;
+				update_digital_gain(false);
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+				update_hpvol(false);
+#endif
+			}
+		}
+		apply_saturation_prevention_drc();
+	}
+	return size;
+}
+
+DECLARE_BOOL_SHOW(headphone_eq);
+static ssize_t headphone_eq_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	unsigned short state;
+	bool current_state;
+	int i;
+	short eq_gains_copy[ARRAY_SIZE(eq_gains)];
+
+	if (sscanf(buf, "%hu", &state) == 1) {
+		current_state = state == 0 ? false : true;
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: EQ activation: %u\n", state);
+
+		if (current_state) {
+			// fade from 0dB each EQ band
+			headphone_eq = current_state;
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++)
+				smooth_apply_eq_band_gain(i, 0, eq_gains[i],
+							  current_state);
+		} else {
+			// fade to 0dB each EQ band
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++) {
+				eq_gains_copy[i] = eq_gains[i];
+				smooth_apply_eq_band_gain(i, eq_gains[i], 0,
+							  current_state);
+			}
+			// restore original gains in driver memory not codec
+			for (i = 0; i < ARRAY_SIZE(eq_bands); i++)
+				eq_gains[i] = eq_gains_copy[i];
+			headphone_eq = current_state;
+		}
+	}
+	return size;
+}
+
+DECLARE_EQ_GAIN_SHOW(1);
+DECLARE_EQ_GAIN_STORE(1);
+DECLARE_EQ_GAIN_SHOW(2);
+DECLARE_EQ_GAIN_STORE(2);
+DECLARE_EQ_GAIN_SHOW(3);
+DECLARE_EQ_GAIN_STORE(3);
+DECLARE_EQ_GAIN_SHOW(4);
+DECLARE_EQ_GAIN_STORE(4);
+DECLARE_EQ_GAIN_SHOW(5);
+DECLARE_EQ_GAIN_STORE(5);
+
+static ssize_t headphone_eq_bands_values_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	int i;
+	int j;
+	int k = 0;
+	int first_reg = WM8994_AIF1_DAC1_EQ_BAND_1_A;
+	int bands_size = ARRAY_SIZE(eq_bands);
+	char *name;
+
+	for (i = 0; i < bands_size; i++)
+		for (j = 0; j < eq_bands[i]; j++) {
+
+			// display 3-coef bands properly (hi & lo shelf)
+			if (j + 1 == eq_bands[i])
+				name = eq_band_coef_names[3];
+			else
+				name = eq_band_coef_names[j];
+
+			sprintf(buf, "%s%d %s 0x%04X\n", buf,
+				i + 1, name,
+				wm8994_read(codec, first_reg + k));
+			k++;
+		}
+
+	return sprintf(buf, "%s", buf);
+}
+
+static ssize_t headphone_eq_bands_values_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t size)
+{
+	int i;
+	short unsigned int val;
+	short unsigned int band;
+	char coef_name[2];
+	unsigned int bytes_read = 0;
+
+	while (sscanf(buf, "%hu %s %hx%n",
+		      &band, coef_name, &val, &bytes_read) == 3) {
+
+		buf += bytes_read;
+
+		if (band < 1 || band > 5)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(eq_band_coef_names); i++) {
+			// loop through band coefficient letters
+			if (strncmp(eq_band_coef_names[i], coef_name, 2) == 0) {
+				if (eq_bands[band - 1] == 3 && i == 3)
+					// deal with high and low shelves
+					eq_band_values[band - 1][2] = val;
+				else
+					// parametric bands
+					eq_band_values[band - 1][i] = val;
+
+				if (debug_log(LOG_INFOS))
+					printk("Voodoo sound: read EQ from "
+					       "sysfs: EQ Band %hd %s: 0x%04X\n"
+					       , band, coef_name, val);
+				break;
+			}
+		}
+	}
+
+	return size;
+}
+
+DECLARE_BOOL_SHOW(stereo_expansion);
+DECLARE_BOOL_STORE_UPDATE_WITH_MUTE(stereo_expansion,
+				    update_stereo_expansion,
+				    false);
+
+static ssize_t stereo_expansion_gain_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%u\n", stereo_expansion_gain);
+}
+
+static ssize_t stereo_expansion_gain_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t size)
+{
+	short unsigned val;
+
+	if (sscanf(buf, "%hu", &val) == 1)
+		if (val >= 0 && val < 32) {
+			stereo_expansion_gain = val;
+			update_stereo_expansion(false);
+		}
+
+	return size;
+}
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+static ssize_t show_wm8994_register_dump(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	// modified version of register_dump from wm8994_aries.c
+	// r = wm8994 register
+	int r;
+
+	for (r = 0; r <= 0x6; r++)
+		sprintf(buf, "0x%X 0x%X\n", r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x15, wm8994_read(codec, 0x15));
+
+	for (r = 0x18; r <= 0x3C; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x4C, wm8994_read(codec, 0x4C));
+
+	for (r = 0x51; r <= 0x5C; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x60, wm8994_read(codec, 0x60));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x101, wm8994_read(codec, 0x101));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x110, wm8994_read(codec, 0x110));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x111, wm8994_read(codec, 0x111));
+
+	for (r = 0x200; r <= 0x212; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x220; r <= 0x224; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x240; r <= 0x244; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x300; r <= 0x317; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x400; r <= 0x411; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x420; r <= 0x423; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x440; r <= 0x444; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x450; r <= 0x454; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x480; r <= 0x493; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x4A0; r <= 0x4B3; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x500; r <= 0x503; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x510, wm8994_read(codec, 0x510));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x520, wm8994_read(codec, 0x520));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x521, wm8994_read(codec, 0x521));
+
+	for (r = 0x540; r <= 0x544; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x580; r <= 0x593; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	for (r = 0x600; r <= 0x614; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x620, wm8994_read(codec, 0x620));
+	sprintf(buf, "%s0x%X 0x%X\n", buf, 0x621, wm8994_read(codec, 0x621));
+
+	for (r = 0x700; r <= 0x70A; r++)
+		sprintf(buf, "%s0x%X 0x%X\n", buf, r, wm8994_read(codec, r));
+
+	return sprintf(buf, "%s", buf);
+}
+
+static ssize_t store_wm8994_write(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	short unsigned int reg = 0;
+	short unsigned int val = 0;
+	int unsigned bytes_read = 0;
+
+	while (sscanf(buf, "%hx %hx%n", &reg, &val, &bytes_read) == 2) {
+		buf += bytes_read;
+		if (debug_log(LOG_INFOS))
+			printk("Voodoo sound: read from sysfs: %X, %X\n",
+			       reg, val);
+
+		bypass_write_hook = true;
+		wm8994_write(codec, reg, val);
+		bypass_write_hook = false;
+	}
+	return size;
+}
+#endif
+
+static ssize_t voodoo_sound_version(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", VOODOO_SOUND_VERSION);
+}
+
+#ifndef MODULE
+DECLARE_BOOL_SHOW(enable);
+static ssize_t enable_store(struct device *dev,
+			    struct device_attribute *attr, const char *buf,
+			    size_t size)
+{
+	unsigned short state;
+	bool bool_state;
+	if (sscanf(buf, "%hu", &state) == 1) {
+		bool_state = state == 0 ? false : true;
+		if (state != enable) {
+			enable = bool_state;
+			update_enable();
+		}
+	}
+	return size;
+}
+#endif
+
+static DEVICE_ATTR(debug_log, S_IRUGO | S_IWUGO,
+		   debug_log_show,
+		   debug_log_store);
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+static DEVICE_ATTR(headphone_amplifier_level, S_IRUGO | S_IWUGO,
+		   headphone_amplifier_level_show,
+		   headphone_amplifier_level_store);
+#endif
+
+#ifdef NEXUS_S
+static DEVICE_ATTR(speaker_tuning, S_IRUGO | S_IWUGO,
+		   speaker_tuning_show,
+		   speaker_tuning_store);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+static DEVICE_ATTR(fm_radio_headset_restore_bass, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_restore_bass_show,
+		   fm_radio_headset_restore_bass_store);
+
+static DEVICE_ATTR(fm_radio_headset_restore_highs, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_restore_highs_show,
+		   fm_radio_headset_restore_highs_store);
+
+static DEVICE_ATTR(fm_radio_headset_normalize_gain, S_IRUGO | S_IWUGO,
+		   fm_radio_headset_normalize_gain_show,
+		   fm_radio_headset_normalize_gain_store);
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+static DEVICE_ATTR(recording_preset, S_IRUGO | S_IWUGO,
+		   recording_preset_show,
+		   recording_preset_store);
+#endif
+
+static DEVICE_ATTR(dac_osr128, S_IRUGO | S_IWUGO,
+		   dac_osr128_show,
+		   dac_osr128_store);
+
+static DEVICE_ATTR(adc_osr128, S_IRUGO | S_IWUGO,
+		   adc_osr128_show,
+		   adc_osr128_store);
+
+#ifndef GALAXY_TAB_TEGRA
+static DEVICE_ATTR(fll_tuning, S_IRUGO | S_IWUGO,
+		   fll_tuning_show,
+		   fll_tuning_store);
+#endif
+
+static DEVICE_ATTR(dac_direct, S_IRUGO | S_IWUGO,
+		   dac_direct_show,
+		   dac_direct_store);
+
+static DEVICE_ATTR(digital_gain, S_IRUGO | S_IWUGO,
+		   digital_gain_show,
+		   digital_gain_store);
+
+static DEVICE_ATTR(headphone_eq, S_IRUGO | S_IWUGO,
+		   headphone_eq_show,
+		   headphone_eq_store);
+
+static DEVICE_ATTR(headphone_eq_b1_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b1_gain_show,
+		   headphone_eq_b1_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b2_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b2_gain_show,
+		   headphone_eq_b2_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b3_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b3_gain_show,
+		   headphone_eq_b3_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b4_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b4_gain_show,
+		   headphone_eq_b4_gain_store);
+
+static DEVICE_ATTR(headphone_eq_b5_gain, S_IRUGO | S_IWUGO,
+		   headphone_eq_b5_gain_show,
+		   headphone_eq_b5_gain_store);
+
+static DEVICE_ATTR(headphone_eq_bands_values, S_IRUGO | S_IWUGO,
+		   headphone_eq_bands_values_show,
+		   headphone_eq_bands_values_store);
+
+static DEVICE_ATTR(stereo_expansion, S_IRUGO | S_IWUGO,
+		   stereo_expansion_show,
+		   stereo_expansion_store);
+
+static DEVICE_ATTR(stereo_expansion_gain, S_IRUGO | S_IWUGO,
+		   stereo_expansion_gain_show,
+		   stereo_expansion_gain_store);
+
+static DEVICE_ATTR(mono_downmix, S_IRUGO | S_IWUGO,
+		   mono_downmix_show,
+		   mono_downmix_store);
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+static DEVICE_ATTR(wm8994_register_dump, S_IRUGO,
+		   show_wm8994_register_dump,
+		   NULL);
+
+static DEVICE_ATTR(wm8994_write, S_IWUSR,
+		   NULL,
+		   store_wm8994_write);
+#endif
+
+static DEVICE_ATTR(version, S_IRUGO,
+		   voodoo_sound_version,
+		   NULL);
+
+#ifndef MODULE
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUGO,
+		   enable_show,
+		   enable_store);
+#endif
+
+#ifdef MODULE
+static DEVICE_ATTR(module, 0,
+		   NULL,
+		   NULL);
+#endif
+
+static struct attribute *voodoo_sound_attributes[] = {
+	&dev_attr_debug_log.attr,
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+	&dev_attr_headphone_amplifier_level.attr,
+#endif
+#ifdef NEXUS_S
+	&dev_attr_speaker_tuning.attr,
+#endif
+#ifdef CONFIG_SND_VOODOO_FM
+	&dev_attr_fm_radio_headset_restore_bass.attr,
+	&dev_attr_fm_radio_headset_restore_highs.attr,
+	&dev_attr_fm_radio_headset_normalize_gain.attr,
+#endif
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+	&dev_attr_recording_preset.attr,
+#endif
+	&dev_attr_dac_osr128.attr,
+	&dev_attr_adc_osr128.attr,
+#ifndef GALAXY_TAB_TEGRA
+	&dev_attr_fll_tuning.attr,
+#endif
+	&dev_attr_dac_direct.attr,
+	&dev_attr_digital_gain.attr,
+	&dev_attr_headphone_eq.attr,
+	&dev_attr_headphone_eq_b1_gain.attr,
+	&dev_attr_headphone_eq_b2_gain.attr,
+	&dev_attr_headphone_eq_b3_gain.attr,
+	&dev_attr_headphone_eq_b4_gain.attr,
+	&dev_attr_headphone_eq_b5_gain.attr,
+	&dev_attr_headphone_eq_bands_values.attr,
+	&dev_attr_stereo_expansion.attr,
+	&dev_attr_stereo_expansion_gain.attr,
+	&dev_attr_mono_downmix.attr,
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+	&dev_attr_wm8994_register_dump.attr,
+	&dev_attr_wm8994_write.attr,
+#endif
+#ifdef MODULE
+	&dev_attr_module.attr,
+#endif
+	&dev_attr_version.attr,
+	NULL
+};
+
+#ifndef MODULE
+static struct attribute *voodoo_sound_control_attributes[] = {
+	&dev_attr_enable.attr,
+	NULL
+};
+#endif
+
+static struct attribute_group voodoo_sound_group = {
+	.attrs = voodoo_sound_attributes,
+};
+
+#ifndef MODULE
+static struct attribute_group voodoo_sound_control_group = {
+	.attrs = voodoo_sound_control_attributes,
+};
+#endif
+
+static struct miscdevice voodoo_sound_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "voodoo_sound",
+};
+
+#ifndef MODULE
+static struct miscdevice voodoo_sound_control_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "voodoo_sound_control",
+};
+#endif
+
+void voodoo_hook_wm8994_pcm_remove()
+{
+	printk("Voodoo sound: removing driver v%d\n", VOODOO_SOUND_VERSION);
+	sysfs_remove_group(&voodoo_sound_device.this_device->kobj,
+			   &voodoo_sound_group);
+	misc_deregister(&voodoo_sound_device);
+}
+
+void update_enable()
+{
+	if (enable) {
+		printk("Voodoo sound: initializing driver v%d\n",
+		       VOODOO_SOUND_VERSION);
+
+#ifdef CONFIG_SND_VOODOO_DEVELOPMENT
+		printk("Voodoo sound: codec development tools enabled\n");
+#endif
+
+		misc_register(&voodoo_sound_device);
+		if (sysfs_create_group(&voodoo_sound_device.this_device->kobj,
+				       &voodoo_sound_group) < 0) {
+			printk("%s sysfs_create_group fail\n", __FUNCTION__);
+			pr_err("Failed to create sysfs group for (%s)!\n",
+			       voodoo_sound_device.name);
+		}
+	} else
+		voodoo_hook_wm8994_pcm_remove();
+}
+
+/*
+ *
+ * Driver Hooks
+ *
+ */
+
+#ifdef CONFIG_SND_VOODOO_FM
+void voodoo_hook_fmradio_headset()
+{
+	// global kill switch
+	if (!enable)
+		return;
+
+	if (!fm_radio_headset_restore_bass
+	    && !fm_radio_headset_restore_highs
+	    && !fm_radio_headset_normalize_gain)
+		return;
+
+	update_fm_radio_headset_restore_freqs(false);
+	update_fm_radio_headset_normalize_gain(false);
+}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_RECORD_PRESETS
+void voodoo_hook_record_main_mic()
+{
+	// global kill switch
+	if (!enable)
+		return;
+
+	if (recording_preset == 0)
+		return;
+
+	origin_recgain = wm8994_read(codec, WM8994_LEFT_LINE_INPUT_1_2_VOLUME);
+	origin_recgain_mixer = wm8994_read(codec, WM8994_INPUT_MIXER_3);
+	update_recording_preset(false);
+}
+#endif
+
+#ifdef NEXUS_S
+void voodoo_hook_playback_speaker()
+{
+	// global kill switch
+	if (!enable)
+		return;
+	if (!speaker_tuning)
+		return;
+
+	update_speaker_tuning(false);
+}
+#endif
+
+unsigned int voodoo_hook_wm8994_write(struct snd_soc_codec *codec_,
+				      unsigned int reg, unsigned int value)
+{
+	DECLARE_WM8994(codec_);
+
+	// global kill switch
+	if (!enable)
+		return value;
+
+	// modify some registers before those being written to the codec
+	// be sure our pointer to codec is up to date
+	codec = codec_;
+
+	if (!bypass_write_hook) {
+
+#ifdef CONFIG_SND_VOODOO_HP_LEVEL_CONTROL
+		if (is_path(HEADPHONES)
+		    && !(wm8994->codec_state & CALL_ACTIVE)) {
+
+			if (reg == WM8994_LEFT_OUTPUT_VOLUME)
+				value =
+				    (WM8994_HPOUT1_VU |
+				     WM8994_HPOUT1L_MUTE_N |
+				     hpvol(0));
+
+			if (reg == WM8994_RIGHT_OUTPUT_VOLUME)
+				value =
+				    (WM8994_HPOUT1_VU |
+				     WM8994_HPOUT1R_MUTE_N |
+				     hpvol(1));
+		}
+#endif
+
+#ifdef CONFIG_SND_VOODOO_FM
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		// FM tuning virtual hook for Gingerbread
+		if (is_path(RADIO_HEADPHONES)) {
+			if (reg == WM8994_AIF2_DRC_1
+			    || reg == WM8994_AIF2_DAC_FILTERS_1)
+				voodoo_hook_fmradio_headset();
+		}
+#else
+		// FM tuning virtual hook for Froyo
+		if (is_path(RADIO_HEADPHONES)) {
+			if (reg == WM8994_INPUT_MIXER_2
+			    || reg == WM8994_AIF2_DRC_1
+			    || reg == WM8994_ANALOGUE_HP_1)
+				voodoo_hook_fmradio_headset();
+		}
+#endif
+#endif
+		// global Oversampling tuning
+		if (reg == WM8994_OVERSAMPLING)
+			value = osr128_get_value(value);
+
+#ifndef GALAXY_TAB_TEGRA
+		// global Anti-Jitter tuning
+		if (reg == WM8994_FLL1_CONTROL_4)
+			value = fll_tuning_get_value(value);
+#endif
+
+		// global Mono downmix tuning
+		if (reg == WM8994_AIF1_DAC1_FILTERS_1
+		    || reg == WM8994_AIF1_DAC2_FILTERS_1
+		    || reg == WM8994_AIF2_DAC_FILTERS_1)
+			value = mono_downmix_get_value(value, false);
+
+		// DAC direct tuning virtual hook
+		if (reg == WM8994_OUTPUT_MIXER_1
+		    || reg == WM8994_OUTPUT_MIXER_2)
+			value = dac_direct_get_value(value, false);
+
+		// Digital Headroom virtual hook
+		if (reg == WM8994_AIF1_DAC1_LEFT_VOLUME
+		    || reg == WM8994_AIF1_DAC1_RIGHT_VOLUME)
+			value = digital_gain_get_value(value);
+
+		// Headphones EQ & 3D virtual hook
+		if (reg == WM8994_AIF1_DAC1_FILTERS_1
+		    || reg == WM8994_AIF1_DAC2_FILTERS_1
+		    || reg == WM8994_AIF2_DAC_FILTERS_1) {
+			bypass_write_hook = true;
+			apply_saturation_prevention_drc();
+			update_headphone_eq(true);
+			update_stereo_expansion(false);
+			bypass_write_hook = false;
+		}
+
+	}
+	if (debug_log(LOG_VERBOSE))
+	// log every write to dmesg
+		printk("Voodoo sound: wm8994_write 0x%03X 0x%04X "
+#ifdef NEXUS_S
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+		       "power_state=%i\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+		       wm8994->cur_path, wm8994->rec_path,
+		       wm8994->power_state);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "fmradio_path=%i, fmr_mix_path=%i, "
+#endif
+#ifndef GALAXY_TAB
+		       "input_source=%i, "
+#endif
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA) && !defined(GALAXY_TAB)
+		       "output_source=%i, "
+#endif
+		       "power_state=%i\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       wm8994->fmradio_path, wm8994->fmr_mix_path,
+#endif
+		       wm8994->cur_path, wm8994->rec_path,
+#ifndef GALAXY_TAB
+		       wm8994->input_source,
+#endif
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA) && !defined(GALAXY_TAB)
+		       wm8994->output_source,
+#endif
+		       wm8994->power_state);
+#else
+		       "codec_state=%u, stream_state=%u, "
+		       "cur_path=%i, rec_path=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "fmradio_path=%i, fmr_mix_path=%i, "
+#endif
+#ifdef CONFIG_S5PC110_KEPLER_BOARD
+		       "call_record_path=%i, call_record_ch=%i, "
+		       "AUDIENCE_state=%i, "
+		       "Fac_SUB_MIC_state=%i, TTY_state=%i, "
+#endif
+		       "power_state=%i, "
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       "recognition_active=%i, ringtone_active=%i"
+#endif
+		       "\n",
+		       reg, value,
+		       wm8994->codec_state, wm8994->stream_state,
+		       wm8994->cur_path, wm8994->rec_path,
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       wm8994->fmradio_path, wm8994->fmr_mix_path,
+#endif
+#ifdef CONFIG_S5PC110_KEPLER_BOARD
+		       wm8994->call_record_path, wm8994->call_record_ch,
+		       wm8994->AUDIENCE_state,
+		       wm8994->Fac_SUB_MIC_state, wm8994->TTY_state,
+#endif
+		       wm8994->power_state
+#if !defined(M110S) && !defined(GALAXY_TAB_TEGRA)
+		       ,wm8994->recognition_active,
+		       wm8994->ringtone_active
+#endif
+		);
+#endif
+#endif
+	return value;
+}
+
+void voodoo_hook_wm8994_pcm_probe(struct snd_soc_codec *codec_)
+{
+	enable = true;
+	update_enable();
+
+#ifndef MODULE
+	misc_register(&voodoo_sound_control_device);
+	if (sysfs_create_group(&voodoo_sound_control_device.this_device->kobj,
+			       &voodoo_sound_control_group) < 0) {
+		printk("%s sysfs_create_group fail\n", __FUNCTION__);
+		pr_err("Failed to create sysfs group for device (%s)!\n",
+		       voodoo_sound_control_device.name);
+	}
+#endif
+
+	// make a copy of the codec pointer
+	codec = codec_;
+
+	// initialize eq_band_values[] from default codec EQ values
+	load_current_eq_values();
+}
diff --git a/Kernel/sound/soc/codecs/wm8994_voodoo.h b/Kernel/sound/soc/codecs/wm8994_voodoo.h
new file mode 100644
index 0000000..8ca0c2f
--- /dev/null
+++ b/Kernel/sound/soc/codecs/wm8994_voodoo.h
@@ -0,0 +1,68 @@
+/*
+ * wm8994.h  --  WM8994 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define VOODOO_SOUND_VERSION 10
+
+#if defined(CONFIG_MACH_HERRING) || defined (CONFIG_SAMSUNG_GALAXYS)	       \
+	|| defined (CONFIG_SAMSUNG_GALAXYSB)				       \
+	|| defined (CONFIG_SAMSUNG_CAPTIVATE)				       \
+	|| defined (CONFIG_SAMSUNG_VIBRANT)				       \
+	|| defined (CONFIG_SAMSUNG_FASCINATE)				       \
+	|| defined (CONFIG_SAMSUNG_EPIC)				       \
+	|| defined (CONFIG_ARCH_S5PV210)
+#define NEXUS_S
+#endif
+
+#if defined(CONFIG_FB_S3C_AMS701KA) || defined(CONFIG_KOR_MODEL_M180S)
+#define GALAXY_TAB
+#endif
+
+#ifdef CONFIG_M110S
+#define M110S
+#endif
+
+#ifdef CONFIG_MACH_SAMSUNG_VARIATION_TEGRA
+#define GALAXY_TAB_TEGRA
+#endif
+
+#ifdef CONFIG_TDMB_T3700
+#define M110S
+#endif
+
+enum debug_log { LOG_OFF, LOG_INFOS, LOG_VERBOSE };
+bool debug_log(short unsigned int level);
+
+enum unified_path { HEADPHONES, RADIO_HEADPHONES, SPEAKER, MAIN_MICROPHONE };
+
+bool is_path(int unified_path);
+bool is_path_media_or_fm_no_call_no_record(void);
+unsigned int voodoo_hook_wm8994_write(struct snd_soc_codec *codec,
+				      unsigned int reg, unsigned int value);
+void voodoo_hook_fmradio_headset(void);
+void voodoo_hook_wm8994_pcm_probe(struct snd_soc_codec *codec);
+void voodoo_hook_wm8994_pcm_remove(void);
+void voodoo_hook_record_main_mic(void);
+void voodoo_hook_playback_speaker(void);
+
+void load_current_eq_values(void);
+void apply_saturation_prevention_drc(void);
+
+void update_hpvol(bool with_fade);
+void update_fm_radio_headset_restore_freqs(bool with_mute);
+void update_fm_radio_headset_normalize_gain(bool with_mute);
+void update_recording_preset(bool with_mute);
+void update_full_bitwidth(bool with_mute);
+void update_osr128(bool with_mute);
+void update_fll_tuning(bool with_mute);
+void update_mono_downmix(bool with_mute);
+void update_dac_direct(bool with_mute);
+void update_digital_gain(bool with_mute);
+void update_stereo_expansion(bool with_mute);
+void update_headphone_eq(bool update_bands);
+void update_headphone_eq_bands(void);
+void update_enable(void);
-- 
1.7.5.4

